###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Aug/2019  12:13:01
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\hal\target\CC2530EB\hal_io.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWC40A.tmp
#        (E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\hal\target\CC2530EB\hal_io.c
#        -D ZIGBEEPRO -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D SAPP_ZSTACK -lC
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        -lA
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00800000 -DZDAPP_CONFIG_PAN_ID=0x0057
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List\hal_io.lst
#    Object file        =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj\hal_io.r51
#
###############################################################################

E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\hal\target\CC2530EB\hal_io.c
      1          #include "hal_io.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8a
   \   unsigned char volatile __sfr P1IFG
   \                     P1IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr P2IFG
   \                     P2IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr P1IEN
   \                     P1IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xac
   \   unsigned char volatile __sfr P2IEN
   \                     P2IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf6
   \   unsigned char volatile __sfr P1INP
   \                     P1INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
      2          #include "OSAL.h"
      3          #include <string.h>
      4          
      5          static struct {
      6              uint8 ioIntTskId;
      7              uint8 intInUse[MAX_IOGROUP + 1];
      8              uint8 endPointMap[MAX_IOPORT + 1];
      9              void *endPointArgMap[MAX_IOPORT + 1];

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     10          } ioIntResMap;
   \                     ioIntResMap:
   \   000000                DS 67
   \   000043                REQUIRE __INIT_XDATA_Z

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     11          void HalIOInit(uint8 taskId)
   \                     HalIOInit:
     12          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
     13              memset(&ioIntResMap, 0, sizeof(ioIntResMap));
   \   000007                ; Setup parameters for call to function memset
   \   000007   75..43       MOV       ?V0,#0x43
   \   00000A   75..00       MOV       ?V1,#0x0
   \   00000D   78..         MOV       R0,#?V0
   \   00000F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000012   7C00         MOV       R4,#0x0
   \   000014   7D00         MOV       R5,#0x0
   \   000016   7A..         MOV       R2,#ioIntResMap & 0xff
   \   000018   7B..         MOV       R3,#(ioIntResMap >> 8) & 0xff
   \   00001A   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   00001D   7402         MOV       A,#0x2
   \   00001F   12....       LCALL     ?DEALLOC_XSTACK8
     14              ioIntResMap.ioIntTskId = taskId;
   \   000022   EE           MOV       A,R6
   \   000023   90....       MOV       DPTR,#ioIntResMap
   \   000026   F0           MOVX      @DPTR,A
     15          }
   \   000027                REQUIRE ?Subroutine0
   \   000027                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
     16          /***********************************************************
     17          **  函数名称: HalIOSetInput
     18          **  实现功能: 设置端口为普通输入IO
     19          **  入口参数: group:Port;
     20          **            bit:Bit;
     21          **            pull:(Pull_None:无上下拉; Pull_Up:上拉; Pull_Down:下拉;);
     22          **  返回结果: IOInt_None
     23          **  注意事项: CC2530的通用IO上下拉电阻是对整个端口的设置，
     24          **            不能实现将同一端口的不同位配置为上下拉不同
     25          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     26          void HalIOSetInput(uint8 group, uint8 bit, PullSet_t pull)
   \                     HalIOSetInput:
     27          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
     28              switch(group)
   \   000005   600C         JZ        ??HalIOSetInput_0
   \   000007   14           DEC       A
   \   000008   606E         JZ        ??HalIOSetInput_1
   \   00000A   14           DEC       A
   \   00000B   7003         JNZ       $+5
   \   00000D   02....       LJMP      ??HalIOSetInput_2 & 0xFFFF
   \   000010   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     29              {
     30              case 0:
     31                  //设置为通用输入IO
     32                  CLRBIT(P0DIR, bit);
   \                     ??HalIOSetInput_0:
   \   000013   75..01       MOV       ?V0,#0x1
   \   000016   75..00       MOV       ?V1,#0x0
   \   000019   EA           MOV       A,R2
   \   00001A   78..         MOV       R0,#?V0
   \   00001C   12....       LCALL     ?S_SHL
   \   00001F   E5..         MOV       A,?V0
   \   000021   F8           MOV       R0,A
   \   000022   F4           CPL       A
   \   000023   52FD         ANL       0xfd,A
     33                  CLRBIT(P0SEL, bit);
   \   000025   52F3         ANL       0xf3,A
     34                  //设置内部上下拉电阻状态
     35                  if(Pull_None == pull)
   \   000027   EB           MOV       A,R3
   \   000028   7013         JNZ       ??HalIOSetInput_4
     36                      SETBIT(P0INP, bit);     //P0INP[7-0]:(0:上下拉有效; 1:无效;)
   \   00002A   75..01       MOV       ?V0,#0x1
   \   00002D   75..00       MOV       ?V1,#0x0
   \   000030   EA           MOV       A,R2
   \   000031   78..         MOV       R0,#?V0
   \   000033   12....       LCALL     ?S_SHL
   \   000036   E5..         MOV       A,?V0
   \   000038   428F         ORL       0x8f,A
   \   00003A   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     37                  else if(Pull_Up == pull)
   \                     ??HalIOSetInput_4:
   \   00003D   7401         MOV       A,#0x1
   \   00003F   6B           XRL       A,R3
   \   000040   7017         JNZ       ??HalIOSetInput_5
     38                  {
     39                      CLRBIT(P0INP, bit);     //P0INP[7-0]:(0:上下拉有效; 1:无效;)
   \   000042   75..01       MOV       ?V0,#0x1
   \   000045   75..00       MOV       ?V1,#0x0
   \   000048   EA           MOV       A,R2
   \   000049   78..         MOV       R0,#?V0
   \   00004B   12....       LCALL     ?S_SHL
   \   00004E   E5..         MOV       A,?V0
   \   000050   F4           CPL       A
   \   000051   528F         ANL       0x8f,A
     40                      CLRBIT(P2INP, 5);       //P2INP[5  ]:(0:Port0 上拉; 1:Port0 下拉;)
   \   000053   53F7DF       ANL       0xf7,#0xdf
   \   000056   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     41                  }
     42                  else if(Pull_Down == pull)
   \                     ??HalIOSetInput_5:
   \   000059   7402         MOV       A,#0x2
   \   00005B   6B           XRL       A,R3
   \   00005C   6003         JZ        $+5
   \   00005E   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     43                  {
     44                      CLRBIT(P0INP, bit);     //P0INP[7-0]:(0:上下拉有效; 1:无效;)
   \   000061   75..01       MOV       ?V0,#0x1
   \   000064   75..00       MOV       ?V1,#0x0
   \   000067   EA           MOV       A,R2
   \   000068   78..         MOV       R0,#?V0
   \   00006A   12....       LCALL     ?S_SHL
   \   00006D   E5..         MOV       A,?V0
   \   00006F   F4           CPL       A
   \   000070   528F         ANL       0x8f,A
     45                      SETBIT(P2INP, 5);       //P2INP[5  ]:(0:Port0 上拉; 1:Port0 下拉;)
   \   000072   43F720       ORL       0xf7,#0x20
   \   000075   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     46                  }
     47                  break;
     48              case 1:
     49                  //设置为通用输入IO
     50                  CLRBIT(P1DIR, bit);
   \                     ??HalIOSetInput_1:
   \   000078   75..01       MOV       ?V0,#0x1
   \   00007B   75..00       MOV       ?V1,#0x0
   \   00007E   EA           MOV       A,R2
   \   00007F   78..         MOV       R0,#?V0
   \   000081   12....       LCALL     ?S_SHL
   \   000084   E5..         MOV       A,?V0
   \   000086   F8           MOV       R0,A
   \   000087   F4           CPL       A
   \   000088   52FE         ANL       0xfe,A
     51                  CLRBIT(P1SEL, bit);
   \   00008A   52F4         ANL       0xf4,A
     52                  //设置内部上下拉电阻状态
     53                  if(Pull_None == pull)
   \   00008C   EB           MOV       A,R3
   \   00008D   7013         JNZ       ??HalIOSetInput_6
     54                      SETBIT(P1INP, bit);     //P1INP[7-2]:(0:上下拉有效; 1:无效;) P[1-0] 写无效，读为0.
   \   00008F   75..01       MOV       ?V0,#0x1
   \   000092   75..00       MOV       ?V1,#0x0
   \   000095   EA           MOV       A,R2
   \   000096   78..         MOV       R0,#?V0
   \   000098   12....       LCALL     ?S_SHL
   \   00009B   E5..         MOV       A,?V0
   \   00009D   42F6         ORL       0xf6,A
   \   00009F   02....       LJMP      ??HalIOSetInput_3 & 0xFFFF
     55                  else if(Pull_Up == pull)
   \                     ??HalIOSetInput_6:
   \   0000A2   7401         MOV       A,#0x1
   \   0000A4   6B           XRL       A,R3
   \   0000A5   7016         JNZ       ??HalIOSetInput_7
     56                  {
     57                      CLRBIT(P1INP, bit);     //P1INP[7-2]:(0:上下拉有效; 1:无效;) P[1-0] 写无效，读为0.
   \   0000A7   75..01       MOV       ?V0,#0x1
   \   0000AA   75..00       MOV       ?V1,#0x0
   \   0000AD   EA           MOV       A,R2
   \   0000AE   78..         MOV       R0,#?V0
   \   0000B0   12....       LCALL     ?S_SHL
   \   0000B3   E5..         MOV       A,?V0
   \   0000B5   F4           CPL       A
   \   0000B6   52F6         ANL       0xf6,A
     58                      CLRBIT(P2INP, 6);       //P2INP[6  ]:(0:Port1 上拉; 1:Port1 下拉;)
   \   0000B8   53F7BF       ANL       0xf7,#0xbf
   \   0000BB   8078         SJMP      ??HalIOSetInput_3
     59                  }
     60                  else if(Pull_Down == pull)
   \                     ??HalIOSetInput_7:
   \   0000BD   7402         MOV       A,#0x2
   \   0000BF   6B           XRL       A,R3
   \   0000C0   7073         JNZ       ??HalIOSetInput_3
     61                  {
     62                      CLRBIT(P1INP, bit);     //P1INP[7-2]:(0:上下拉有效; 1:无效;) P[1-0] 写无效，读为0.
   \   0000C2   75..01       MOV       ?V0,#0x1
   \   0000C5   75..00       MOV       ?V1,#0x0
   \   0000C8   EA           MOV       A,R2
   \   0000C9   78..         MOV       R0,#?V0
   \   0000CB   12....       LCALL     ?S_SHL
   \   0000CE   E5..         MOV       A,?V0
   \   0000D0   F4           CPL       A
   \   0000D1   52F6         ANL       0xf6,A
     63                      SETBIT(P2INP, 6);       //P2INP[6  ]:(0:Port1 上拉; 1:Port1 下拉;)
   \   0000D3   43F740       ORL       0xf7,#0x40
   \   0000D6   805D         SJMP      ??HalIOSetInput_3
     64                  }
     65                  break;
     66              case 2:
     67                  //设置为通用输入IO
     68                  CLRBIT(P2DIR, bit);
   \                     ??HalIOSetInput_2:
   \   0000D8   75..01       MOV       ?V0,#0x1
   \   0000DB   75..00       MOV       ?V1,#0x0
   \   0000DE   EA           MOV       A,R2
   \   0000DF   78..         MOV       R0,#?V0
   \   0000E1   12....       LCALL     ?S_SHL
   \   0000E4   E5..         MOV       A,?V0
   \   0000E6   F8           MOV       R0,A
   \   0000E7   F4           CPL       A
   \   0000E8   52FF         ANL       0xff,A
     69                  CLRBIT(P2SEL, bit);
   \   0000EA   52F5         ANL       0xf5,A
     70                  //设置内部上下拉电阻状态
     71                  if(Pull_None == pull)
   \   0000EC   EB           MOV       A,R3
   \   0000ED   7012         JNZ       ??HalIOSetInput_8
     72                      SETBIT(P2INP, bit);     //P2INP[4-0]:(0:上下拉有效; 1:无效;)
   \   0000EF   75..01       MOV       ?V0,#0x1
   \   0000F2   75..00       MOV       ?V1,#0x0
   \   0000F5   EA           MOV       A,R2
   \   0000F6   78..         MOV       R0,#?V0
   \   0000F8   12....       LCALL     ?S_SHL
   \   0000FB   E5..         MOV       A,?V0
   \   0000FD   42F7         ORL       0xf7,A
   \   0000FF   8034         SJMP      ??HalIOSetInput_3
     73                  else if(Pull_Up == pull)
   \                     ??HalIOSetInput_8:
   \   000101   7401         MOV       A,#0x1
   \   000103   6B           XRL       A,R3
   \   000104   7016         JNZ       ??HalIOSetInput_9
     74                  {
     75                      CLRBIT(P2INP, bit);     //P2INP[4-0]:(0:上下拉有效; 1:无效;)
   \   000106   75..01       MOV       ?V0,#0x1
   \   000109   75..00       MOV       ?V1,#0x0
   \   00010C   EA           MOV       A,R2
   \   00010D   78..         MOV       R0,#?V0
   \   00010F   12....       LCALL     ?S_SHL
   \   000112   E5..         MOV       A,?V0
   \   000114   F4           CPL       A
   \   000115   52F7         ANL       0xf7,A
     76                      CLRBIT(P2INP, 7);       //P2INP[7  ]:(0:Port2 上拉; 1:Port2 下拉;)
   \   000117   53F77F       ANL       0xf7,#0x7f
   \   00011A   8019         SJMP      ??HalIOSetInput_3
     77                  }
     78                  else if(Pull_Down == pull)
   \                     ??HalIOSetInput_9:
   \   00011C   7402         MOV       A,#0x2
   \   00011E   6B           XRL       A,R3
   \   00011F   7014         JNZ       ??HalIOSetInput_3
     79                  {
     80                      CLRBIT(P2INP, bit);     //P2INP[4-0]:(0:上下拉有效; 1:无效;)
   \   000121   75..01       MOV       ?V0,#0x1
   \   000124   75..00       MOV       ?V1,#0x0
   \   000127   EA           MOV       A,R2
   \   000128   78..         MOV       R0,#?V0
   \   00012A   12....       LCALL     ?S_SHL
   \   00012D   E5..         MOV       A,?V0
   \   00012F   F4           CPL       A
   \   000130   52F7         ANL       0xf7,A
     81                      SETBIT(P2INP, 7);       //P2INP[7  ]:(0:Port2 上拉; 1:Port2 下拉;)
   \   000132   43F780       ORL       0xf7,#0x80
     82                  }
     83                  break;
     84              default:
     85                  break;
     86              }
     87          }
   \                     ??HalIOSetInput_3:
   \   000135   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   000138                REQUIRE P0DIR
   \   000138                REQUIRE P0SEL
   \   000138                REQUIRE P0INP
   \   000138                REQUIRE P2INP
   \   000138                REQUIRE P1DIR
   \   000138                REQUIRE P1SEL
   \   000138                REQUIRE P1INP
   \   000138                REQUIRE P2DIR
   \   000138                REQUIRE P2SEL

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D0..         POP       ?V1
   \   000002   D0..         POP       ?V0
   \   000004   02....       LJMP      ?BRET
     88          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     89          void HalIOSetOutput(uint8 group, uint8 bit)
   \                     HalIOSetOutput:
     90          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
     91             switch(group)
   \   000005   6008         JZ        ??HalIOSetOutput_0
   \   000007   14           DEC       A
   \   000008   601A         JZ        ??HalIOSetOutput_1
   \   00000A   14           DEC       A
   \   00000B   602C         JZ        ??HalIOSetOutput_2
   \   00000D   803D         SJMP      ??HalIOSetOutput_3
     92             {
     93             case 0: P0DIR |= (1 << bit); P0SEL &= ~(1 << bit); break;
   \                     ??HalIOSetOutput_0:
   \   00000F   75..01       MOV       ?V0,#0x1
   \   000012   75..00       MOV       ?V1,#0x0
   \   000015   EA           MOV       A,R2
   \   000016   78..         MOV       R0,#?V0
   \   000018   12....       LCALL     ?S_SHL
   \   00001B   E5..         MOV       A,?V0
   \   00001D   42FD         ORL       0xfd,A
   \   00001F   F4           CPL       A
   \   000020   52F3         ANL       0xf3,A
   \   000022   8028         SJMP      ??HalIOSetOutput_3
     94             case 1: P1DIR |= (1 << bit); P1SEL &= ~(1 << bit); break;
   \                     ??HalIOSetOutput_1:
   \   000024   75..01       MOV       ?V0,#0x1
   \   000027   75..00       MOV       ?V1,#0x0
   \   00002A   EA           MOV       A,R2
   \   00002B   78..         MOV       R0,#?V0
   \   00002D   12....       LCALL     ?S_SHL
   \   000030   E5..         MOV       A,?V0
   \   000032   42FE         ORL       0xfe,A
   \   000034   F4           CPL       A
   \   000035   52F4         ANL       0xf4,A
   \   000037   8013         SJMP      ??HalIOSetOutput_3
     95             case 2: P2DIR |= (1 << bit); P2SEL &= ~(1 << bit); break;
   \                     ??HalIOSetOutput_2:
   \   000039   75..01       MOV       ?V0,#0x1
   \   00003C   75..00       MOV       ?V1,#0x0
   \   00003F   EA           MOV       A,R2
   \   000040   78..         MOV       R0,#?V0
   \   000042   12....       LCALL     ?S_SHL
   \   000045   E5..         MOV       A,?V0
   \   000047   42FF         ORL       0xff,A
   \   000049   F4           CPL       A
   \   00004A   52F5         ANL       0xf5,A
     96             }
     97          }
   \                     ??HalIOSetOutput_3:
   \   00004C   80..         SJMP      ?Subroutine1
   \   00004E                REQUIRE P0DIR
   \   00004E                REQUIRE P0SEL
   \   00004E                REQUIRE P1DIR
   \   00004E                REQUIRE P1SEL
   \   00004E                REQUIRE P2DIR
   \   00004E                REQUIRE P2SEL

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     98          uint8 HalIOGetLevel(uint8 group, uint8 bit)
   \                     HalIOGetLevel:
     99          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
    100              switch(group)
   \   000005   6008         JZ        ??HalIOGetLevel_0
   \   000007   14           DEC       A
   \   000008   6017         JZ        ??HalIOGetLevel_1
   \   00000A   14           DEC       A
   \   00000B   6028         JZ        ??HalIOGetLevel_2
   \   00000D   803C         SJMP      ??HalIOGetLevel_3
    101              {
    102              case 0: return !!(P0 & (1 << bit));
   \                     ??HalIOGetLevel_0:
   \   00000F   75..01       MOV       ?V0,#0x1
   \   000012   75..00       MOV       ?V1,#0x0
   \   000015   EA           MOV       A,R2
   \   000016   78..         MOV       R0,#?V0
   \   000018   12....       LCALL     ?S_SHL
   \   00001B   E5..         MOV       A,?V0
   \   00001D   5580         ANL       A,0x80
   \   00001F   8010         SJMP      ??HalIOGetLevel_4
    103              case 1: return !!(P1 & (1 << bit));
   \                     ??HalIOGetLevel_1:
   \   000021   75..01       MOV       ?V0,#0x1
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   EA           MOV       A,R2
   \   000028   78..         MOV       R0,#?V0
   \   00002A   12....       LCALL     ?S_SHL
   \   00002D   E5..         MOV       A,?V0
   \   00002F   5590         ANL       A,0x90
   \                     ??HalIOGetLevel_4:
   \   000031   6018         JZ        ??HalIOGetLevel_3
   \   000033   8012         SJMP      ??HalIOGetLevel_5
    104              case 2: return !!(P2 & (1 << bit));
   \                     ??HalIOGetLevel_2:
   \   000035   75..01       MOV       ?V0,#0x1
   \   000038   75..00       MOV       ?V1,#0x0
   \   00003B   EA           MOV       A,R2
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?S_SHL
   \   000041   E5..         MOV       A,?V0
   \   000043   55A0         ANL       A,0xa0
   \   000045   6004         JZ        ??HalIOGetLevel_3
   \                     ??HalIOGetLevel_5:
   \   000047   7901         MOV       R1,#0x1
   \   000049   8002         SJMP      ??HalIOGetLevel_6
    105              }
    106              return 0;
   \                     ??HalIOGetLevel_3:
   \   00004B   7900         MOV       R1,#0x0
   \                     ??HalIOGetLevel_6:
   \   00004D                REQUIRE ?Subroutine1
   \   00004D                REQUIRE _A_P0
   \   00004D                REQUIRE _A_P1
   \   00004D                REQUIRE _A_P2
   \   00004D                ; // Fall through to label ?Subroutine1
    107          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    108          void HalIOSetLevel(uint8 group, uint8 bit, uint8 value)
   \                     HalIOSetLevel:
    109          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   C0..         PUSH      ?V0
   \   000002   C0..         PUSH      ?V1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    110              switch(group)
   \   000004   E9           MOV       A,R1
   \   000005   6008         JZ        ??HalIOSetLevel_0
   \   000007   14           DEC       A
   \   000008   6027         JZ        ??HalIOSetLevel_1
   \   00000A   14           DEC       A
   \   00000B   6046         JZ        ??HalIOSetLevel_2
   \   00000D   8064         SJMP      ??HalIOSetLevel_3
    111              {
    112              case 0:
    113                  if(value)
   \                     ??HalIOSetLevel_0:
   \   00000F   EB           MOV       A,R3
   \   000010   75..01       MOV       ?V0,#0x1
   \   000013   75..00       MOV       ?V1,#0x0
   \   000016   600C         JZ        ??HalIOSetLevel_4
    114                      SETBIT(P0, bit);
   \   000018   EA           MOV       A,R2
   \   000019   78..         MOV       R0,#?V0
   \   00001B   12....       LCALL     ?S_SHL
   \   00001E   E5..         MOV       A,?V0
   \   000020   4280         ORL       0x80,A
   \   000022   804F         SJMP      ??HalIOSetLevel_3
    115                  else
    116                      CLRBIT(P0, bit);
   \                     ??HalIOSetLevel_4:
   \   000024   EA           MOV       A,R2
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?S_SHL
   \   00002A   E5..         MOV       A,?V0
   \   00002C   F4           CPL       A
   \   00002D   5280         ANL       0x80,A
   \   00002F   8042         SJMP      ??HalIOSetLevel_3
    117                  break;
    118              case 1:
    119                  if(value)
   \                     ??HalIOSetLevel_1:
   \   000031   EB           MOV       A,R3
   \   000032   75..01       MOV       ?V0,#0x1
   \   000035   75..00       MOV       ?V1,#0x0
   \   000038   600C         JZ        ??HalIOSetLevel_5
    120                      SETBIT(P1, bit);
   \   00003A   EA           MOV       A,R2
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?S_SHL
   \   000040   E5..         MOV       A,?V0
   \   000042   4290         ORL       0x90,A
   \   000044   802D         SJMP      ??HalIOSetLevel_3
    121                  else
    122                      CLRBIT(P1, bit);
   \                     ??HalIOSetLevel_5:
   \   000046   EA           MOV       A,R2
   \   000047   78..         MOV       R0,#?V0
   \   000049   12....       LCALL     ?S_SHL
   \   00004C   E5..         MOV       A,?V0
   \   00004E   F4           CPL       A
   \   00004F   5290         ANL       0x90,A
   \   000051   8020         SJMP      ??HalIOSetLevel_3
    123                  break;
    124              case 2:
    125                  if(value)
   \                     ??HalIOSetLevel_2:
   \   000053   EB           MOV       A,R3
   \   000054   75..01       MOV       ?V0,#0x1
   \   000057   75..00       MOV       ?V1,#0x0
   \   00005A   600C         JZ        ??HalIOSetLevel_6
    126                      SETBIT(P2, bit);
   \   00005C   EA           MOV       A,R2
   \   00005D   78..         MOV       R0,#?V0
   \   00005F   12....       LCALL     ?S_SHL
   \   000062   E5..         MOV       A,?V0
   \   000064   42A0         ORL       0xa0,A
   \   000066   800B         SJMP      ??HalIOSetLevel_3
    127                  else
    128                      CLRBIT(P2, bit);
   \                     ??HalIOSetLevel_6:
   \   000068   EA           MOV       A,R2
   \   000069   78..         MOV       R0,#?V0
   \   00006B   12....       LCALL     ?S_SHL
   \   00006E   E5..         MOV       A,?V0
   \   000070   F4           CPL       A
   \   000071   52A0         ANL       0xa0,A
    129                  break;
    130              }
    131          }
   \                     ??HalIOSetLevel_3:
   \   000073   80..         SJMP      ?Subroutine1
   \   000075                REQUIRE _A_P0
   \   000075                REQUIRE _A_P1
   \   000075                REQUIRE _A_P2
    132          /***********************************************************
    133          **  函数名称: IOIntteruptSet
    134          **  实现功能: 设置端口中断触发方式
    135          **  入口参数: group:Port;
    136          **            bit:Bit;
    137          **            trigger:(IOInt_Rising:上升沿触发; IOInt_Falling:下降沿触发;)
    138          **  返回结果: IOInt_None
    139          **  注意事项: CC2530的通用IO中断触发方式是对整个端口的设置，
    140          **            只有P1口的高四位和第四位触发方式可以设置为不同
    141          **            P0端口和P2端口的所有端口触发方式以最后一次设置为准。
    142          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    143          void HalIOIntSet(uint8 endPoint, uint8 group, uint8 bit, IntSel_t trigger, void *arg)
   \                     HalIOIntSet:
    144          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    145              if(HAL_IOPORT(group, bit) > MAX_IOPORT)
   \   000005   EA           MOV       A,R2
   \   000006   F5..         MOV       ?V0,A
   \   000008   75..00       MOV       ?V1,#0x0
   \   00000B   7403         MOV       A,#0x3
   \   00000D   78..         MOV       R0,#?V0
   \   00000F   12....       LCALL     ?S_SHL
   \   000012   EB           MOV       A,R3
   \   000013   FE           MOV       R6,A
   \   000014   E5..         MOV       A,?V0
   \   000016   4E           ORL       A,R6
   \   000017   AF..         MOV       R7,?V1
   \   000019   C3           CLR       C
   \   00001A   9415         SUBB      A,#0x15
   \   00001C   EF           MOV       A,R7
   \   00001D   9400         SUBB      A,#0x0
   \   00001F   C3           CLR       C
   \   000020   65D0         XRL       A,PSW
   \   000022   33           RLC       A
   \   000023   4003         JC        $+5
   \   000025   02....       LJMP      ??HalIOIntSet_0 & 0xFFFF
    146                  return;
    147              if(trigger == IOInt_None)
   \   000028   EC           MOV       A,R4
   \   000029   75..01       MOV       ?V0,#0x1
   \   00002C   75..00       MOV       ?V1,#0x0
   \   00002F   7010         JNZ       ??HalIOIntSet_1
    148              {
    149                  CLRBIT(ioIntResMap.intInUse[group], bit);
   \   000031   EB           MOV       A,R3
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?S_SHL
   \   000037   E5..         MOV       A,?V0
   \   000039   F4           CPL       A
   \   00003A   F8           MOV       R0,A
   \   00003B   12....       LCALL     ?Subroutine4 & 0xFFFF
    150              }
   \                     ??CrossCallReturnLabel_6:
   \   00003E   58           ANL       A,R0
   \   00003F   804A         SJMP      ??HalIOIntSet_2
    151              else
    152              {
    153                  SETBIT(ioIntResMap.intInUse[group], bit);
   \                     ??HalIOIntSet_1:
   \   000041   EB           MOV       A,R3
   \   000042   78..         MOV       R0,#?V0
   \   000044   12....       LCALL     ?S_SHL
   \   000047   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00004A   45..         ORL       A,?V0
   \   00004C   F0           MOVX      @DPTR,A
    154                  ioIntResMap.endPointMap[HAL_IOPORT(group, bit)] = endPoint;
   \   00004D   8A..         MOV       ?V0,R2
   \   00004F   75..00       MOV       ?V1,#0x0
   \   000052   7403         MOV       A,#0x3
   \   000054   78..         MOV       R0,#?V0
   \   000056   12....       LCALL     ?S_SHL
   \   000059   E5..         MOV       A,?V0
   \   00005B   4E           ORL       A,R6
   \   00005C   FE           MOV       R6,A
   \   00005D   74..         MOV       A,#(ioIntResMap + 4) & 0xff
   \   00005F   2E           ADD       A,R6
   \   000060   F582         MOV       DPL,A
   \   000062   74..         MOV       A,#((ioIntResMap + 4) >> 8) & 0xff
   \   000064   3F           ADDC      A,R7
   \   000065   F583         MOV       DPH,A
   \   000067   E9           MOV       A,R1
   \   000068   F0           MOVX      @DPTR,A
    155                  ioIntResMap.endPointArgMap[HAL_IOPORT(group, bit)] = arg;
   \   000069   740A         MOV       A,#0xa
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   F5..         MOV       ?V0,A
   \   000071   A3           INC       DPTR
   \   000072   E0           MOVX      A,@DPTR
   \   000073   F5..         MOV       ?V1,A
   \   000075   EE           MOV       A,R6
   \   000076   2E           ADD       A,R6
   \   000077   FE           MOV       R6,A
   \   000078   EF           MOV       A,R7
   \   000079   33           RLC       A
   \   00007A   FF           MOV       R7,A
   \   00007B   74..         MOV       A,#(ioIntResMap + 25) & 0xff
   \   00007D   2E           ADD       A,R6
   \   00007E   F582         MOV       DPL,A
   \   000080   74..         MOV       A,#((ioIntResMap + 25) >> 8) & 0xff
   \   000082   3F           ADDC      A,R7
   \   000083   F583         MOV       DPH,A
   \   000085   E5..         MOV       A,?V0
   \   000087   F0           MOVX      @DPTR,A
   \   000088   A3           INC       DPTR
   \   000089   E5..         MOV       A,?V1
   \                     ??HalIOIntSet_2:
   \   00008B   F0           MOVX      @DPTR,A
    156              }
    157              switch(group)
   \   00008C   EA           MOV       A,R2
   \   00008D   600C         JZ        ??HalIOIntSet_3
   \   00008F   14           DEC       A
   \   000090   6040         JZ        ??HalIOIntSet_4
   \   000092   14           DEC       A
   \   000093   7003         JNZ       $+5
   \   000095   02....       LJMP      ??HalIOIntSet_5 & 0xFFFF
   \   000098   02....       LJMP      ??HalIOIntSet_0 & 0xFFFF
    158              {
    159              case 0:
    160                  if(trigger == IOInt_None)
   \                     ??HalIOIntSet_3:
   \   00009B   EC           MOV       A,R4
   \   00009C   75..01       MOV       ?V0,#0x1
   \   00009F   75..00       MOV       ?V1,#0x0
   \   0000A2   700D         JNZ       ??HalIOIntSet_6
    161                      CLRBIT(P0IEN, bit);
   \   0000A4   EB           MOV       A,R3
   \   0000A5   78..         MOV       R0,#?V0
   \   0000A7   12....       LCALL     ?S_SHL
   \   0000AA   E5..         MOV       A,?V0
   \   0000AC   F4           CPL       A
   \   0000AD   52AB         ANL       0xab,A
   \   0000AF   8017         SJMP      ??HalIOIntSet_7
    162                  else
    163                  {
    164                      SETBIT(P0IEN, bit);
   \                     ??HalIOIntSet_6:
   \   0000B1   EB           MOV       A,R3
   \   0000B2   78..         MOV       R0,#?V0
   \   0000B4   12....       LCALL     ?S_SHL
   \   0000B7   E5..         MOV       A,?V0
   \   0000B9   42AB         ORL       0xab,A
    165                      if(trigger == IOInt_Rising)
   \   0000BB   7401         MOV       A,#0x1
   \   0000BD   6C           XRL       A,R4
   \   0000BE   7005         JNZ       ??HalIOIntSet_8
    166                          CLRBIT(PICTL, 0);
   \   0000C0   538CFE       ANL       0x8c,#0xfe
   \   0000C3   8003         SJMP      ??HalIOIntSet_7
    167                      else
    168                          SETBIT(PICTL, 0);
   \                     ??HalIOIntSet_8:
   \   0000C5   438C01       ORL       0x8c,#0x1
    169                  }
    170                  P0IFG = 0x00;       //清除P0相应位中断标志
   \                     ??HalIOIntSet_7:
   \   0000C8   758900       MOV       0x89,#0x0
    171                  P0IF = 0;           //清除P0端口总中断标志
   \   0000CB   C2C5         CLR       0xc0.5
    172                  //SETBIT(IEN1, 5);  //P0总中断允许
    173                  CLRBIT(IEN1, 5);    //P0总中断禁止
   \   0000CD   C2BD         CLR       0xb8.5
    174                  break;
   \   0000CF   02....       LJMP      ??HalIOIntSet_0 & 0xFFFF
    175              case 1:
    176                  if(trigger == IOInt_None)
   \                     ??HalIOIntSet_4:
   \   0000D2   EC           MOV       A,R4
   \   0000D3   7013         JNZ       ??HalIOIntSet_9
    177                      CLRBIT(P1IEN, bit);
   \   0000D5   75..01       MOV       ?V0,#0x1
   \   0000D8   75..00       MOV       ?V1,#0x0
   \   0000DB   EB           MOV       A,R3
   \   0000DC   78..         MOV       R0,#?V0
   \   0000DE   12....       LCALL     ?S_SHL
   \   0000E1   E5..         MOV       A,?V0
   \   0000E3   F4           CPL       A
   \   0000E4   528D         ANL       0x8d,A
   \   0000E6   8042         SJMP      ??HalIOIntSet_10
    178                  else
    179                  {
    180                      uint8 ctlBit = (bit <= 3) ? 1 : 2;
   \                     ??HalIOIntSet_9:
   \   0000E8   EB           MOV       A,R3
   \   0000E9   C3           CLR       C
   \   0000EA   9404         SUBB      A,#0x4
   \   0000EC   5004         JNC       ??HalIOIntSet_11
   \   0000EE   7D01         MOV       R5,#0x1
   \   0000F0   8002         SJMP      ??HalIOIntSet_12
   \                     ??HalIOIntSet_11:
   \   0000F2   7D02         MOV       R5,#0x2
    181                      SETBIT(P1IEN, bit);
   \                     ??HalIOIntSet_12:
   \   0000F4   75..01       MOV       ?V0,#0x1
   \   0000F7   75..00       MOV       ?V1,#0x0
   \   0000FA   EB           MOV       A,R3
   \   0000FB   78..         MOV       R0,#?V0
   \   0000FD   12....       LCALL     ?S_SHL
   \   000100   E5..         MOV       A,?V0
   \   000102   428D         ORL       0x8d,A
    182                      if(trigger == IOInt_Rising)
   \   000104   7401         MOV       A,#0x1
   \   000106   6C           XRL       A,R4
   \   000107   7012         JNZ       ??HalIOIntSet_13
    183                          CLRBIT(PICTL, ctlBit);
   \   000109   ED           MOV       A,R5
   \   00010A   F8           MOV       R0,A
   \   00010B   7401         MOV       A,#0x1
   \   00010D   B80002       CJNE      R0,#0x0,??HalIOIntSet_14
   \   000110   8004         SJMP      ??HalIOIntSet_15
   \                     ??HalIOIntSet_14:
   \   000112   C3           CLR       C
   \   000113   33           RLC       A
   \   000114   D8FC         DJNZ      R0,??HalIOIntSet_14
   \                     ??HalIOIntSet_15:
   \   000116   F4           CPL       A
   \   000117   528C         ANL       0x8c,A
   \   000119   800F         SJMP      ??HalIOIntSet_10
    184                      else
    185                          SETBIT(PICTL, ctlBit);
   \                     ??HalIOIntSet_13:
   \   00011B   ED           MOV       A,R5
   \   00011C   F8           MOV       R0,A
   \   00011D   7401         MOV       A,#0x1
   \   00011F   B80002       CJNE      R0,#0x0,??HalIOIntSet_16
   \   000122   8004         SJMP      ??HalIOIntSet_17
   \                     ??HalIOIntSet_16:
   \   000124   C3           CLR       C
   \   000125   33           RLC       A
   \   000126   D8FC         DJNZ      R0,??HalIOIntSet_16
   \                     ??HalIOIntSet_17:
   \   000128   428C         ORL       0x8c,A
    186                  }
    187                  P1IFG = 0X00;     //清除P0相应位中断标志
   \                     ??HalIOIntSet_10:
   \   00012A   758A00       MOV       0x8a,#0x0
    188                  P1IF = 0;         //清除P0端口总中断标志
   \   00012D   C2EB         CLR       0xe8.3
    189                  //SETBIT(IEN2, 4);  //P1总中断允许
    190                  CLRBIT(IEN2, 4);    //P1总中断禁止
   \   00012F   539AEF       ANL       0x9a,#0xef
    191                  break;
   \   000132   8035         SJMP      ??HalIOIntSet_0
    192              case 2:
    193                  if(trigger == IOInt_None)
   \                     ??HalIOIntSet_5:
   \   000134   EC           MOV       A,R4
   \   000135   75..01       MOV       ?V0,#0x1
   \   000138   75..00       MOV       ?V1,#0x0
   \   00013B   700D         JNZ       ??HalIOIntSet_18
    194                      CLRBIT(P2IEN, bit);
   \   00013D   EB           MOV       A,R3
   \   00013E   78..         MOV       R0,#?V0
   \   000140   12....       LCALL     ?S_SHL
   \   000143   E5..         MOV       A,?V0
   \   000145   F4           CPL       A
   \   000146   52AC         ANL       0xac,A
   \   000148   8017         SJMP      ??HalIOIntSet_19
    195                  else
    196                  {
    197                      SETBIT(P2IEN, bit);
   \                     ??HalIOIntSet_18:
   \   00014A   EB           MOV       A,R3
   \   00014B   78..         MOV       R0,#?V0
   \   00014D   12....       LCALL     ?S_SHL
   \   000150   E5..         MOV       A,?V0
   \   000152   42AC         ORL       0xac,A
    198                      if(trigger == IOInt_Rising)
   \   000154   7401         MOV       A,#0x1
   \   000156   6C           XRL       A,R4
   \   000157   7005         JNZ       ??HalIOIntSet_20
    199                          CLRBIT(PICTL, 3);
   \   000159   538CF7       ANL       0x8c,#0xf7
   \   00015C   8003         SJMP      ??HalIOIntSet_19
    200                      else
    201                          SETBIT(PICTL, 3);
   \                     ??HalIOIntSet_20:
   \   00015E   438C08       ORL       0x8c,#0x8
    202                  }
    203                  P2IFG = 0X00;     //清除P0相应位中断标志
   \                     ??HalIOIntSet_19:
   \   000161   758B00       MOV       0x8b,#0x0
    204                  P2IF = 0;         //清除P0端口总中断标志
   \   000164   C2E8         CLR       0xe8.0
    205                  //SETBIT(IEN2, 1);  //P2总中断允许
    206                  CLRBIT(IEN2, 1);    //P2总中断禁止
   \   000166   539AFD       ANL       0x9a,#0xfd
    207                  break;
    208              default :
    209                  break;
    210              }
    211          }
   \                     ??HalIOIntSet_0:
   \   000169   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   00016C                REQUIRE P0IEN
   \   00016C                REQUIRE PICTL
   \   00016C                REQUIRE P0IFG
   \   00016C                REQUIRE _A_IRCON
   \   00016C                REQUIRE _A_IEN1
   \   00016C                REQUIRE P1IEN
   \   00016C                REQUIRE P1IFG
   \   00016C                REQUIRE _A_IRCON2
   \   00016C                REQUIRE IEN2
   \   00016C                REQUIRE P2IEN
   \   00016C                REQUIRE P2IFG

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   74..         MOV       A,#(ioIntResMap + 1) & 0xff
   \   000002   2A           ADD       A,R2
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   34..         ADDC      A,#((ioIntResMap + 1) >> 8) & 0xff
   \   000008   F583         MOV       DPH,A
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   22           RET
    212          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    213          void HalIOPortPoll()
   \                     HalIOPortPoll:
    214          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    215              OSALIOIntData_t* IOIntData;
    216          
    217              uint8 idx;
    218              uint8 flag = ioIntResMap.intInUse[0] & P0IFG;
   \   000005   90....       MOV       DPTR,#ioIntResMap + 1
   \   000008   E0           MOVX      A,@DPTR
   \   000009   5589         ANL       A,0x89
   \   00000B   FF           MOV       R7,A
    219              for(idx = 0; flag && (idx < 8); idx++)
   \   00000C   7E00         MOV       R6,#0x0
   \   00000E   601E         JZ        ??HalIOPortPoll_0
    220              {
    221                  if(BV(idx) & flag)
   \                     ??HalIOPortPoll_1:
   \   000010   75..01       MOV       ?V0,#0x1
   \   000013   75..00       MOV       ?V1,#0x0
   \   000016   EE           MOV       A,R6
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?S_SHL
   \   00001C   E5..         MOV       A,?V0
   \   00001E   5F           ANL       A,R7
   \   00001F   6006         JZ        ??CrossCallReturnLabel_0
    222                  {
    223                      IOIntData = (OSALIOIntData_t *)osal_msg_allocate(sizeof(OSALIOIntData_t));
   \   000021                ; Setup parameters for call to function osal_msg_allocate
   \   000021   12....       LCALL     ?Subroutine3 & 0xFFFF
    224                      IOIntData->hdr.event = IOPORT_INT_EVENT;
    225                      IOIntData->endPoint = ioIntResMap.endPointMap[HAL_IOPORT(0, idx)];
    226                      IOIntData->arg = ioIntResMap.endPointArgMap[HAL_IOPORT(0, idx)];
    227                      osal_msg_send(ioIntResMap.ioIntTskId, (uint8*)(IOIntData));
    228                  }
    229              }
   \                     ??CrossCallReturnLabel_3:
   \   000024   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000027   0E           INC       R6
   \   000028   EE           MOV       A,R6
   \   000029   C3           CLR       C
   \   00002A   9408         SUBB      A,#0x8
   \   00002C   40E2         JC        ??HalIOPortPoll_1
    230              flag = ioIntResMap.intInUse[1] & P1IFG;
   \                     ??HalIOPortPoll_0:
   \   00002E   90....       MOV       DPTR,#ioIntResMap + 2
   \   000031   E0           MOVX      A,@DPTR
   \   000032   558A         ANL       A,0x8a
   \   000034   FF           MOV       R7,A
    231              for(idx = 0; flag && (idx < 8); idx++)
   \   000035   7E00         MOV       R6,#0x0
   \   000037   6020         JZ        ??HalIOPortPoll_2
    232              {
    233                  if(BV(idx) & flag)
   \                     ??HalIOPortPoll_3:
   \   000039   75..01       MOV       ?V0,#0x1
   \   00003C   75..00       MOV       ?V1,#0x0
   \   00003F   EE           MOV       A,R6
   \   000040   78..         MOV       R0,#?V0
   \   000042   12....       LCALL     ?S_SHL
   \   000045   E5..         MOV       A,?V0
   \   000047   5F           ANL       A,R7
   \   000048   6008         JZ        ??CrossCallReturnLabel_1
    234                  {
    235                      IOIntData = (OSALIOIntData_t *)osal_msg_allocate(sizeof(OSALIOIntData_t));
   \   00004A                ; Setup parameters for call to function osal_msg_allocate
   \   00004A   12....       LCALL     ?Subroutine3 & 0xFFFF
    236                      IOIntData->hdr.event = IOPORT_INT_EVENT;
    237                      IOIntData->endPoint = ioIntResMap.endPointMap[HAL_IOPORT(1, idx)];
    238                      IOIntData->arg = ioIntResMap.endPointArgMap[HAL_IOPORT(1, idx)];
    239                      osal_msg_send(ioIntResMap.ioIntTskId, (uint8*)(IOIntData));
    240                  }
    241              }
   \                     ??CrossCallReturnLabel_4:
   \   00004D   4408         ORL       A,#0x8
   \   00004F   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000052   0E           INC       R6
   \   000053   EE           MOV       A,R6
   \   000054   C3           CLR       C
   \   000055   9408         SUBB      A,#0x8
   \   000057   40E0         JC        ??HalIOPortPoll_3
    242              flag = ioIntResMap.intInUse[2] & P2IFG;
   \                     ??HalIOPortPoll_2:
   \   000059   90....       MOV       DPTR,#ioIntResMap + 3
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   558B         ANL       A,0x8b
   \   00005F   FF           MOV       R7,A
    243              for(idx = 0; flag && (idx < 5); idx++)
   \   000060   7E00         MOV       R6,#0x0
   \   000062   6020         JZ        ??HalIOPortPoll_4
    244              {
    245                  if(BV(idx) & flag)
   \                     ??HalIOPortPoll_5:
   \   000064   75..01       MOV       ?V0,#0x1
   \   000067   75..00       MOV       ?V1,#0x0
   \   00006A   EE           MOV       A,R6
   \   00006B   78..         MOV       R0,#?V0
   \   00006D   12....       LCALL     ?S_SHL
   \   000070   E5..         MOV       A,?V0
   \   000072   5F           ANL       A,R7
   \   000073   6008         JZ        ??CrossCallReturnLabel_2
    246                  {
    247                      IOIntData = (OSALIOIntData_t *)osal_msg_allocate(sizeof(OSALIOIntData_t));
   \   000075                ; Setup parameters for call to function osal_msg_allocate
   \   000075   12....       LCALL     ?Subroutine3 & 0xFFFF
    248                      IOIntData->hdr.event = IOPORT_INT_EVENT;
    249                      IOIntData->endPoint = ioIntResMap.endPointMap[HAL_IOPORT(2, idx)];
    250                      IOIntData->arg = ioIntResMap.endPointArgMap[HAL_IOPORT(2, idx)];
    251                      osal_msg_send(ioIntResMap.ioIntTskId, (uint8*)(IOIntData));
    252                  }
    253              }
   \                     ??CrossCallReturnLabel_5:
   \   000078   4410         ORL       A,#0x10
   \   00007A   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00007D   0E           INC       R6
   \   00007E   EE           MOV       A,R6
   \   00007F   C3           CLR       C
   \   000080   9405         SUBB      A,#0x5
   \   000082   40E0         JC        ??HalIOPortPoll_5
    254              // 中断事件处理完毕,清除硬件中断标志位。
    255              P0IFG = 0;
   \                     ??HalIOPortPoll_4:
   \   000084   758900       MOV       0x89,#0x0
    256              P1IFG = 0;
   \   000087   758A00       MOV       0x8a,#0x0
    257              P2IFG = 0;
   \   00008A   758B00       MOV       0x8b,#0x0
    258          }
   \   00008D   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000090                REQUIRE P0IFG
   \   000090                REQUIRE P1IFG
   \   000090                REQUIRE P2IFG

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7A05         MOV       R2,#0x5
   \   000002   7B00         MOV       R3,#0x0
   \   000004   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000007   8A82         MOV       DPL,R2
   \   000009   8B83         MOV       DPH,R3
   \   00000B   74F0         MOV       A,#-0x10
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   EE           MOV       A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   F8           MOV       R0,A
   \   000001   74..         MOV       A,#(ioIntResMap + 4) & 0xff
   \   000003   28           ADD       A,R0
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   34..         ADDC      A,#((ioIntResMap + 4) >> 8) & 0xff
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   8A82         MOV       DPL,R2
   \   00000E   8B83         MOV       DPH,R3
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   F0           MOVX      @DPTR,A
   \   000013   E8           MOV       A,R0
   \   000014   28           ADD       A,R0
   \   000015   F8           MOV       R0,A
   \   000016   E4           CLR       A
   \   000017   33           RLC       A
   \   000018   F9           MOV       R1,A
   \   000019   74..         MOV       A,#(ioIntResMap + 25) & 0xff
   \   00001B   28           ADD       A,R0
   \   00001C   F582         MOV       DPL,A
   \   00001E   74..         MOV       A,#((ioIntResMap + 25) >> 8) & 0xff
   \   000020   39           ADDC      A,R1
   \   000021   F583         MOV       DPH,A
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F8           MOV       R0,A
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   F9           MOV       R1,A
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   E8           MOV       A,R0
   \   000030   F0           MOVX      @DPTR,A
   \   000031   A3           INC       DPTR
   \   000032   E9           MOV       A,R1
   \   000033   F0           MOVX      @DPTR,A
   \   000034                ; Setup parameters for call to function osal_msg_send
   \   000034                ; Setup parameters for call to function osal_msg_send
   \   000034                ; Setup parameters for call to function osal_msg_send
   \   000034   90....       MOV       DPTR,#ioIntResMap
   \   000037   E0           MOVX      A,@DPTR
   \   000038   F9           MOV       R1,A
   \   000039   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   00003C   22           RET

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   HalIOGetLevel
      0     12   HalIOInit
        0     12   -> memset
      1     12   HalIOIntSet
      1     10   HalIOPortPoll
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   HalIOSetInput
      2      0   HalIOSetLevel
      2      0   HalIOSetOutput


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?Subroutine0
       7  ?Subroutine1
      61  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
      77  HalIOGetLevel
      39  HalIOInit
     364  HalIOIntSet
     144  HalIOPortPoll
     312  HalIOSetInput
     117  HalIOSetLevel
      78  HalIOSetOutput
       1  IEN2
       1  P0DIR
       1  P0IEN
       1  P0IFG
       1  P0INP
       1  P0SEL
       1  P1DIR
       1  P1IEN
       1  P1IFG
       1  P1INP
       1  P1SEL
       1  P2DIR
       1  P2IEN
       1  P2IFG
       1  P2INP
       1  P2SEL
       1  PICTL
       1  _A_IEN1
       1  _A_IRCON
       1  _A_IRCON2
       1  _A_P0
       1  _A_P1
       1  _A_P2
      67  ioIntResMap
      42  -- Other

 
 1 232 bytes in segment BANKED_CODE
    42 bytes in segment BANK_RELAYS
    23 bytes in segment SFR_AN
    67 bytes in segment XDATA_Z
 
    42 bytes of CODE     memory
     0 bytes of DATA     memory (+ 23 bytes shared)
 1 232 bytes of HUGECODE memory
    67 bytes of XDATA    memory

Errors: none
Warnings: none
