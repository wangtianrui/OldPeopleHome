###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               22/Aug/2019  20:42:34
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Components\mac\low_level\srf04\mac_backoff_timer.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWE819.tmp
#        (E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Components\mac\low_level\srf04\mac_backoff_timer.c
#        -D ZIGBEEPRO -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D SAPP_ZSTACK -lC
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        -lA
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0057
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List\mac_backoff_timer.lst
#    Object file        =  
#        E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj\mac_backoff_timer.r51
#
###############################################################################

E:\gitRepository\OldPeopleHome\zigbee\ZStack-CC2530-r200\Components\mac\low_level\srf04\mac_backoff_timer.c
      1          /**************************************************************************************************
      2            Filename:       mac_backoff_timer.c
      3            Revised:        $Date: 2007-09-11 10:58:41 -0700 (Tue, 11 Sep 2007) $
      4            Revision:       $Revision: 15371 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                           Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     48          
     49          /* high-level specific */
     50          #include "mac_spec.h"
     51          
     52          /* exported low-level */
     53          #include "mac_low_level.h"
     54          
     55          /* low-level specific */
     56          #include "mac_backoff_timer.h"
     57          #include "mac_tx.h"
     58          
     59          /* target specific */
     60          #include "mac_radio_defs.h"
     61          
     62          /* debug */
     63          #include "mac_assert.h"
     64          
     65          
     66          /* ------------------------------------------------------------------------------------------------
     67           *                                            Defines
     68           * ------------------------------------------------------------------------------------------------
     69           */
     70          #define COMPARE_STATE_ROLLOVER_BV                 BV(0)
     71          #define COMPARE_STATE_TRIGGER_BV                  BV(1)
     72          #define COMPARE_STATE_ARM_BV                      BV(2)
     73          
     74          #define COMPARE_STATE_TRIGGER                     COMPARE_STATE_TRIGGER_BV
     75          #define COMPARE_STATE_ROLLOVER                    COMPARE_STATE_ROLLOVER_BV
     76          #define COMPARE_STATE_ROLLOVER_AND_TRIGGER        (COMPARE_STATE_ROLLOVER_BV | COMPARE_STATE_TRIGGER_BV)
     77          #define COMPARE_STATE_ROLLOVER_AND_ARM_TRIGGER    (COMPARE_STATE_ROLLOVER_BV | COMPARE_STATE_ARM_BV)
     78          
     79          
     80          /*
     81           *  The datasheet mentions a small delay on both receive and transmit side of approximately
     82           *  two microseconds.  The precise characterization is given below.
     83           *  (This data is not given in rev 1.03 datasheet)
     84           */
     85          #define RX_TX_PROP_DELAY_AVG_USEC         ((MAC_RADIO_RX_TX_PROP_DELAY_MIN_USEC + MAC_RADIO_RX_TX_PROP_DELAY_MAX_USEC) / 2)
     86          #define RX_TX_PROP_DELAY_AVG_TIMER_TICKS  ((uint16)(MAC_RADIO_TIMER_TICKS_PER_USEC() * RX_TX_PROP_DELAY_AVG_USEC + 0.5))
     87          
     88          /*
     89           *  For slotted receives, the SFD signal is expected to occur on a specifc symbol boundary.
     90           *  This does *not* correspond to the backoff boundary.  The SFD signal occurs at an
     91           *  offset from the backoff boundary.  This is done for efficiency of related algorithms.
     92           *
     93           *  Once transmit is strobed there is a fixed delay until the SFD signal occurs.  The frame
     94           *  does not start over-the-air transmit until after an internal radio delay of 12 symbols.
     95           *  Once transmitting over-the-air, the preamble is sent (8 symbols) followed by the
     96           *  SFD field (2 symbols). After the SFD field completes, the SFD signal occurs.  This
     97           *  adds up to a total of 22 symbols from strobe to SFD signal.
     98           *
     99           *  Since 22 symbols spans more than a backoff (20 symbols) the modulus operation is used
    100           *  to find the symbol offset which is 2 symbols.
    101           *
    102           *  This math is derived formally via the pre-processor.
    103           */
    104          #define SYMBOLS_FROM_STROBE_TO_PREAMBLE   12 /* from datasheet */
    105          #define SYMBOLS_FROM_PREAMBLE_TO_SFD      (MAC_SPEC_PREAMBLE_FIELD_LENGTH + MAC_SPEC_SFD_FIELD_LENGTH)
    106          #define SYMBOLS_FROM_STROBE_TO_SFD        (SYMBOLS_FROM_STROBE_TO_PREAMBLE + SYMBOLS_FROM_PREAMBLE_TO_SFD)
    107          #define SYMBOLS_EXPECTED_AT_SFD           (SYMBOLS_FROM_STROBE_TO_SFD % MAC_A_UNIT_BACKOFF_PERIOD)
    108          
    109          /* after all that formal math, make sure the result is as expected */
    110          #if (SYMBOLS_EXPECTED_AT_SFD != 2)
    111          #error "ERROR! Internal problem with pre-processor math of slotted alignment."
    112          #endif
    113          
    114          
    115          /*
    116           *  The expected SFD signal occurs at the symbol offset *plus* a small internal propagation delay
    117           *  internal to the radio.  This delay is given as the sum of a receive side delay and a transmit
    118           *  side delay.  When this delay is subtracted from the internal timer, the internal time base
    119           *  actually becomes the actual receive time *minus* the transmit delay.  This works out though.
    120           *  The transmit logic does *not* take into account this delay.  Since the timer is skewed by the
    121           *  transmit delay already, the transmits go out precisely on time.
    122           */
    123          #define TIMER_TICKS_EXPECTED_AT_SFD   ((SYMBOLS_EXPECTED_AT_SFD * MAC_RADIO_TIMER_TICKS_PER_SYMBOL()) \
    124                                                    + RX_TX_PROP_DELAY_AVG_TIMER_TICKS)
    125          
    126          
    127          /* ------------------------------------------------------------------------------------------------
    128           *                                         Local Variables
    129           * ------------------------------------------------------------------------------------------------
    130           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    131          static uint32 backoffTimerRollover;
   \                     backoffTimerRollover:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    132          static uint32 backoffTimerTrigger;
   \                     backoffTimerTrigger:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    133          
    134          
    135          /**************************************************************************************************
    136           * @fn          macBackoffTimerInit
    137           *
    138           * @brief       Intializes backoff timer.
    139           *
    140           * @param       none
    141           *
    142           * @return      none
    143           **************************************************************************************************
    144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          MAC_INTERNAL_API void macBackoffTimerInit(void)
   \                     macBackoffTimerInit:
    146          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    147            MAC_RADIO_BACKOFF_SET_COUNT(0);
   \   000004                ; Setup parameters for call to function macMcuOverflowSetCount
   \   000004   90....       MOV       DPTR,#__Constant_0
   \   000007   12....       LCALL     ?XLOAD_R2345
   \   00000A   12....       LCALL     `??macMcuOverflowSetCount::?relay`; Banked call to: macMcuOverflowSetCount
    148            macBackoffTimerSetRollover(MAC_BACKOFF_TIMER_DEFAULT_ROLLOVER);
   \   00000D                ; Setup parameters for call to function macBackoffTimerSetRollover
   \   00000D   90....       MOV       DPTR,#__Constant_c0000
   \   000010   12....       LCALL     ?XLOAD_R2345
   \   000013   12....       LCALL     `??macBackoffTimerSetRollover::?relay`; Banked call to: macBackoffTimerSetRollover
    149            MAC_RADIO_BACKOFF_PERIOD_CLEAR_INTERRUPT();
   \   000016   75A1F7       MOV       0xa1,#-0x9
    150            MAC_RADIO_BACKOFF_PERIOD_ENABLE_INTERRUPT();
   \   000019   43A708       ORL       0xa7,#0x8
    151            MAC_RADIO_BACKOFF_COMPARE_CLEAR_INTERRUPT();
   \   00001C   75A1EF       MOV       0xa1,#-0x11
    152            MAC_RADIO_BACKOFF_COMPARE_ENABLE_INTERRUPT();
   \   00001F   43A710       ORL       0xa7,#0x10
    153          }
   \   000022   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000025                REQUIRE T2IRQF
   \   000025                REQUIRE T2IRQM

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    154          
    155          
    156          /**************************************************************************************************
    157           * @fn          macBackoffTimerReset
    158           *
    159           * @brief       Resets backoff timer.
    160           *
    161           * @param       none
    162           *
    163           * @return      none
    164           **************************************************************************************************
    165           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          MAC_INTERNAL_API void macBackoffTimerReset(void)
   \                     macBackoffTimerReset:
    167          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    168            MAC_RADIO_BACKOFF_COMPARE_DISABLE_INTERRUPT();
   \   000004   53A7EF       ANL       0xa7,#0xef
    169            MAC_RADIO_BACKOFF_PERIOD_DISABLE_INTERRUPT();
   \   000007   53A7F7       ANL       0xa7,#0xf7
    170            macBackoffTimerInit();
   \   00000A                ; Setup parameters for call to function macBackoffTimerInit
   \   00000A   12....       LCALL     `??macBackoffTimerInit::?relay`; Banked call to: macBackoffTimerInit
    171          }
   \   00000D   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000010                REQUIRE T2IRQM
    172          
    173          
    174          /**************************************************************************************************
    175           * @fn          macBackoffTimerSetRollover
    176           *
    177           * @brief       Set rollover count of backoff timer.
    178           *
    179           * @param       rolloverBackoff - backoff count where count is reset to zero
    180           *
    181           * @return      none
    182           **************************************************************************************************
    183           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    184          MAC_INTERNAL_API void macBackoffTimerSetRollover(uint32 rolloverBackoff)
   \                     macBackoffTimerSetRollover:
    185          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
    186            halIntState_t  s;
    187          
    188            MAC_ASSERT(rolloverBackoff > MAC_RADIO_BACKOFF_COUNT());  /* rollover value must be greater than count */
   \   00000D                ; Setup parameters for call to function macMcuOverflowCount
   \   00000D   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000010   12....       LCALL     ?UL_GT
   \   000013   4003         JC        ??macBackoffTimerSetRollover_0
   \   000015                ; Setup parameters for call to function halAssertHandler
   \   000015   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    189          
    190            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macBackoffTimerSetRollover_0:
   \   000018   AEA8         MOV       R6,0xa8+0x0
   \   00001A   C2AF         CLR       0xa8.7
    191            backoffTimerRollover = rolloverBackoff;
   \   00001C   90....       MOV       DPTR,#backoffTimerRollover
   \   00001F   78..         MOV       R0,#?V0
   \   000021   12....       LCALL     ?L_MOV_TO_X
    192            MAC_RADIO_BACKOFF_SET_PERIOD(rolloverBackoff);
   \   000024                ; Setup parameters for call to function macMcuOverflowSetPeriod
   \   000024   AA..         MOV       R2,?V0
   \   000026   AB..         MOV       R3,?V1
   \   000028   AC..         MOV       R4,?V2
   \   00002A   AD..         MOV       R5,?V3
   \   00002C   12....       LCALL     `??macMcuOverflowSetPeriod::?relay`; Banked call to: macMcuOverflowSetPeriod
    193            HAL_EXIT_CRITICAL_SECTION(s);
   \   00002F   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   000032                REQUIRE _A_IEN0
    194          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   000003   8A..         MOV       ?V4,R2
   \   000005   8B..         MOV       ?V5,R3
   \   000007   8C..         MOV       ?V6,R4
   \   000009   8D..         MOV       ?V7,R5
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   79..         MOV       R1,#?V4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   EE           MOV       A,R6
   \   000001   A2E7         MOV       C,0xE0 /* A   */.7
   \   000003   92AF         MOV       0xa8.7,C
   \   000005                REQUIRE ??Subroutine5_0
   \   000005                ; // Fall through to label ??Subroutine5_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    195          
    196          
    197          /**************************************************************************************************
    198           * @fn          macBackoffTimerSetCount
    199           *
    200           * @brief       Sets the count of the backoff timer.
    201           *
    202           * @param       backoff - new count
    203           *
    204           * @return      none
    205           **************************************************************************************************
    206           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    207          MAC_INTERNAL_API void macBackoffTimerSetCount(uint32 backoff)
   \                     macBackoffTimerSetCount:
    208          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V4,R2
   \   000007   8B..         MOV       ?V5,R3
   \   000009   8C..         MOV       ?V6,R4
   \   00000B   8D..         MOV       ?V7,R5
    209            halIntState_t  s;
    210          
    211            MAC_ASSERT(backoff < backoffTimerRollover);  /* count must be less than rollover value */
   \   00000D   90....       MOV       DPTR,#backoffTimerRollover
   \   000010   78..         MOV       R0,#?V4
   \   000012   12....       LCALL     ?UL_GE_X
   \   000015   5003         JNC       ??macBackoffTimerSetCount_0
   \   000017                ; Setup parameters for call to function halAssertHandler
   \   000017   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    212            MAC_ASSERT(!(backoff & 0x80000000));  /* count must not represent negative value for int32 */
   \                     ??macBackoffTimerSetCount_0:
   \   00001A   85....       MOV       ?V0,?V4
   \   00001D   85....       MOV       ?V1,?V5
   \   000020   85....       MOV       ?V2,?V6
   \   000023   85....       MOV       ?V3,?V7
   \   000026   90....       MOV       DPTR,#__Constant_80000000
   \   000029   78..         MOV       R0,#?V0
   \   00002B   12....       LCALL     ?L_AND_X
   \   00002E   E5..         MOV       A,?V0
   \   000030   45..         ORL       A,?V1
   \   000032   45..         ORL       A,?V2
   \   000034   45..         ORL       A,?V3
   \   000036   6003         JZ        ??macBackoffTimerSetCount_1
   \   000038                ; Setup parameters for call to function halAssertHandler
   \   000038   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    213          
    214            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macBackoffTimerSetCount_1:
   \   00003B   AEA8         MOV       R6,0xa8+0x0
   \   00003D   C2AF         CLR       0xa8.7
    215            MAC_RADIO_BACKOFF_SET_COUNT(backoff);
   \   00003F                ; Setup parameters for call to function macMcuOverflowSetCount
   \   00003F   AA..         MOV       R2,?V4
   \   000041   AB..         MOV       R3,?V5
   \   000043   AC..         MOV       R4,?V6
   \   000045   AD..         MOV       R5,?V7
   \   000047   12....       LCALL     `??macMcuOverflowSetCount::?relay`; Banked call to: macMcuOverflowSetCount
    216            HAL_EXIT_CRITICAL_SECTION(s);
   \   00004A   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   00004D                REQUIRE _A_IEN0
    217          }
    218          
    219          
    220          /**************************************************************************************************
    221           * @fn          macBackoffTimerCount
    222           *
    223           * @brief       Returns the current backoff count.
    224           *
    225           * @param       none
    226           *
    227           * @return      current backoff count
    228           **************************************************************************************************
    229           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          MAC_INTERNAL_API uint32 macBackoffTimerCount(void)
   \                     macBackoffTimerCount:
    231          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    232            halIntState_t  s;
    233            uint32 backoffCount;
    234          
    235            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   AEA8         MOV       R6,0xa8+0x0
   \   000007   C2AF         CLR       0xa8.7
    236            backoffCount = MAC_RADIO_BACKOFF_COUNT();
   \   000009                ; Setup parameters for call to function macMcuOverflowCount
   \   000009   12....       LCALL     ?Subroutine4 & 0xFFFF
    237            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??CrossCallReturnLabel_2:
   \   00000C   EE           MOV       A,R6
   \   00000D   A2E7         MOV       C,0xE0 /* A   */.7
   \   00000F   92AF         MOV       0xa8.7,C
    238            
    239          #ifdef MAC_RADIO_FEATURE_HARDWARE_OVERFLOW_NO_ROLLOVER
    240            /*
    241             *  Extra processing is required if the radio has a special hardware overflow
    242             *  count feature.  Unfortunately this feature does not provide for setting a
    243             *  rollover value.  This must be done manually.
    244             *
    245             *  This means there is a small window in time when reading the hardware count
    246             *  will be inaccurate.  It's possible it could be one more than the allowable
    247             *  count.  This happens if the count has just incremented beyond the maximum
    248             *  and is queried before the ISR has a chance to run and reset the backoff
    249             *  count back to zero.  (Pure software implementation of backoff count does
    250             *  not have this problem.)
    251             *
    252             *  To solve this, before returning a value for the backoff count, the value
    253             *  must be tested to see if it is beyond the maximum value.  If so, a rollover
    254             *  interrupt that will set backoff count to zero is imminent.  In that case,
    255             *  the correct backoff count of zero is returned.
    256             */
    257            if (backoffCount >= backoffTimerRollover)
   \   000011   90....       MOV       DPTR,#backoffTimerRollover
   \   000014   78..         MOV       R0,#?V0
   \   000016   12....       LCALL     ?UL_GE_X
   \   000019   5008         JNC       ??macBackoffTimerCount_0
    258            {
    259              return(0);
   \   00001B   7A00         MOV       R2,#0x0
   \   00001D   7B00         MOV       R3,#0x0
   \   00001F   7C00         MOV       R4,#0x0
   \   000021   7D00         MOV       R5,#0x0
    260            }
    261          #endif
    262            
    263            return(backoffCount);
   \                     ??macBackoffTimerCount_0:
   \   000023                REQUIRE ?Subroutine2
   \   000023                REQUIRE _A_IEN0
   \   000023                ; // Fall through to label ?Subroutine2
    264          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   8C..         MOV       ?V2,R4
   \   000009   8D..         MOV       ?V3,R5
   \   00000B   22           RET
    265          
    266          
    267          /**************************************************************************************************
    268           * @fn          macBackoffTimerCapture
    269           *
    270           * @brief       Returns the most recently captured backoff count
    271           *
    272           * @param       none
    273           *
    274           * @return      last backoff count that was captured
    275           **************************************************************************************************
    276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    277          MAC_INTERNAL_API uint32 macBackoffTimerCapture(void)
   \                     macBackoffTimerCapture:
    278          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    279            halIntState_t  s;
    280            uint32 backoffCapture;
    281          
    282            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   AEA8         MOV       R6,0xa8+0x0
   \   000007   C2AF         CLR       0xa8.7
    283            backoffCapture = MAC_RADIO_BACKOFF_CAPTURE();
   \   000009                ; Setup parameters for call to function macMcuOverflowCapture
   \   000009   12....       LCALL     `??macMcuOverflowCapture::?relay`; Banked call to: macMcuOverflowCapture
   \   00000C   8A..         MOV       ?V0,R2
   \   00000E   8B..         MOV       ?V1,R3
   \   000010   8C..         MOV       ?V2,R4
   \   000012   8D..         MOV       ?V3,R5
    284            HAL_EXIT_CRITICAL_SECTION(s);
   \   000014   EE           MOV       A,R6
   \   000015   A2E7         MOV       C,0xE0 /* A   */.7
   \   000017   92AF         MOV       0xa8.7,C
    285          
    286          #ifdef MAC_RADIO_FEATURE_HARDWARE_OVERFLOW_NO_ROLLOVER
    287            /*
    288             *  See other instance of this #ifdef for detailed comments.
    289             *  Those comments apply to the backoff capture value too.
    290             */
    291            if (backoffCapture >= backoffTimerRollover)
   \   000019   90....       MOV       DPTR,#backoffTimerRollover
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?UL_GE_X
   \   000021   5008         JNC       ??macBackoffTimerCapture_0
    292            {
    293              return(0);
   \   000023   7A00         MOV       R2,#0x0
   \   000025   7B00         MOV       R3,#0x0
   \   000027   7C00         MOV       R4,#0x0
   \   000029   7D00         MOV       R5,#0x0
    294            }
    295          #endif
    296            
    297            return(backoffCapture);
   \                     ??macBackoffTimerCapture_0:
   \   00002B   80..         SJMP      ?Subroutine2
   \   00002D                REQUIRE _A_IEN0
    298          }
    299          
    300          
    301          /**************************************************************************************************
    302           * @fn          macBackoffTimerGetTrigger
    303           *
    304           * @brief       Returns the trigger set for the backoff timer.
    305           *
    306           * @param       none
    307           *
    308           * @return      backoff count of trigger
    309           **************************************************************************************************
    310           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    311          MAC_INTERNAL_API uint32 macBackoffTimerGetTrigger(void)
   \                     macBackoffTimerGetTrigger:
    312          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    313            return(backoffTimerTrigger);
   \   000004   90....       MOV       DPTR,#backoffTimerTrigger
   \   000007   12....       LCALL     ?XLOAD_R2345
   \   00000A                REQUIRE ?Subroutine0
   \   00000A                ; // Fall through to label ?Subroutine0
    314          }
    315          
    316          
    317          /**************************************************************************************************
    318           * @fn          macBackoffTimerSetTrigger
    319           *
    320           * @brief       Sets the trigger count for the backoff counter.  A callback is exectuted when
    321           *              the backoff count reaches the trigger
    322           *
    323           * @param       triggerBackoff - backoff count for new trigger
    324           *
    325           * @return      none
    326           **************************************************************************************************
    327           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    328          MAC_INTERNAL_API void macBackoffTimerSetTrigger(uint32 triggerBackoff)
   \                     macBackoffTimerSetTrigger:
    329          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
    330            halIntState_t  s;
    331          
    332            MAC_ASSERT(triggerBackoff < backoffTimerRollover); /* trigger backoff must be less than rollover backoff */
   \   00000D   90....       MOV       DPTR,#backoffTimerRollover
   \   000010   78..         MOV       R0,#?V0
   \   000012   12....       LCALL     ?UL_GE_X
   \   000015   5003         JNC       ??macBackoffTimerSetTrigger_0
   \   000017                ; Setup parameters for call to function halAssertHandler
   \   000017   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    333          
    334            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macBackoffTimerSetTrigger_0:
   \   00001A   A2AF         MOV       C,0xa8.7
   \   00001C   E4           CLR       A
   \   00001D   33           RLC       A
   \   00001E   FE           MOV       R6,A
   \   00001F   C2AF         CLR       0xa8.7
    335            backoffTimerTrigger = triggerBackoff;
   \   000021   90....       MOV       DPTR,#backoffTimerTrigger
   \   000024   78..         MOV       R0,#?V0
   \   000026   12....       LCALL     ?L_MOV_TO_X
    336            MAC_RADIO_BACKOFF_SET_COMPARE(triggerBackoff);
   \   000029                ; Setup parameters for call to function macMcuOverflowSetCompare
   \   000029   AA..         MOV       R2,?V0
   \   00002B   AB..         MOV       R3,?V1
   \   00002D   AC..         MOV       R4,?V2
   \   00002F   AD..         MOV       R5,?V3
   \   000031   12....       LCALL     `??macMcuOverflowSetCompare::?relay`; Banked call to: macMcuOverflowSetCompare
    337            if (triggerBackoff == MAC_RADIO_BACKOFF_COUNT())
   \   000034                ; Setup parameters for call to function macMcuOverflowCount
   \   000034   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000037   12....       LCALL     ?L_EQ
   \   00003A   700D         JNZ       ??macBackoffTimerSetTrigger_1
    338            {
    339              /* Clear the interrupt and fire it manually */
    340              MAC_RADIO_BACKOFF_COMPARE_CLEAR_INTERRUPT();
   \   00003C   75A1EF       MOV       0xa1,#-0x11
    341              HAL_EXIT_CRITICAL_SECTION(s);
   \   00003F   EE           MOV       A,R6
   \   000040   A2E0         MOV       C,0xE0 /* A   */.0
   \   000042   92AF         MOV       0xa8.7,C
    342              macBackoffTimerTriggerCallback();
   \   000044                ; Setup parameters for call to function macBackoffTimerTriggerCallback
   \   000044   12....       LCALL     `??macBackoffTimerTriggerCallback::?relay`; Banked call to: macBackoffTimerTriggerCallback
   \   000047   8005         SJMP      ??macBackoffTimerSetTrigger_2
    343            }
    344            else
    345            {
    346              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macBackoffTimerSetTrigger_1:
   \   000049   EE           MOV       A,R6
   \   00004A   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004C   92AF         MOV       0xa8.7,C
    347            }
    348          }
   \                     ??macBackoffTimerSetTrigger_2:
   \   00004E   80..         SJMP      ??Subroutine5_0
   \   000050                REQUIRE _A_IEN0
   \   000050                REQUIRE T2IRQF
    349          
    350          
    351          /**************************************************************************************************
    352           * @fn          macBackoffTimerCancelTrigger
    353           *
    354           * @brief       Cancels the trigger for the backoff counter - obselete for CC2530.
    355           *
    356           * @param       none
    357           *
    358           * @return      none
    359           **************************************************************************************************
    360           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    361          MAC_INTERNAL_API void macBackoffTimerCancelTrigger(void)
   \                     macBackoffTimerCancelTrigger:
    362          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    363            /* Stub for high level MAC */
    364          }
   \   000000   02....       LJMP      ?BRET
    365          
    366          
    367          /**************************************************************************************************
    368           * @fn          macBackoffTimerRealign
    369           *
    370           * @brief       
    371           *
    372           *  Realignment is accomplished by adjusting the internal time base to align with the expected
    373           *  reception time of an incoming frame.  The difference between the expected reception time and
    374           *  the actual reception time is computed and this difference is used to adjust the hardware
    375           *  timer count and backoff count.
    376           *
    377           *  The realignment is based on the SFD signal for the incoming frame.  The timer is aligned
    378           *  by adjusting it with the difference between the expected SFD time and the actual SFD time.
    379           *
    380           * @param       none
    381           *
    382           * @return      none
    383           **************************************************************************************************
    384           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    385          MAC_INTERNAL_API int32 macBackoffTimerRealign(macRx_t *pMsg)
   \                     macBackoffTimerRealign:
    386          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    387            uint16 timerDelayTicks;
    388            int32 backoffDelta;
    389            int32 backoffCount;
    390          
    391            MAC_ASSERT(!MAC_TX_IS_PHYSICALLY_ACTIVE()); /* realignment during actual transmit corrupts timing */
   \   000009   90....       MOV       DPTR,#macTxActive
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   A2E7         MOV       C,0xE0 /* A   */.7
   \   00000F   5003         JNC       ??macBackoffTimerRealign_0
   \   000011                ; Setup parameters for call to function halAssertHandler
   \   000011   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    392          
    393            /*-------------------------------------------------------------------------------
    394             *  Calculate the delta backoff difference between expected backoff count,
    395             *  which is zero, and the backoff count of the received frame.
    396             */
    397          
    398            /* since expected receive time is zero, the delta is simply the receive time */
    399            backoffDelta = pMsg->mac.timestamp;
   \                     ??macBackoffTimerRealign_0:
   \   000014   EE           MOV       A,R6
   \   000015   2424         ADD       A,#0x24
   \   000017   F582         MOV       DPL,A
   \   000019   E4           CLR       A
   \   00001A   3F           ADDC      A,R7
   \   00001B   F583         MOV       DPH,A
   \   00001D   78..         MOV       R0,#?V4
   \   00001F   12....       LCALL     ?L_MOV_X
    400          
    401            /* if the frame was received more than halfway to the rollover count, use a negative delta value */
    402            if (((uint32) backoffDelta) > (backoffTimerRollover / 2))
   \   000022   90....       MOV       DPTR,#backoffTimerRollover
   \   000025   78..         MOV       R0,#?V0
   \   000027   12....       LCALL     ?L_MOV_X
   \   00002A   7401         MOV       A,#0x1
   \   00002C   78..         MOV       R0,#?V0
   \   00002E   12....       LCALL     ?UL_SHR
   \   000031   78..         MOV       R0,#?V4
   \   000033   79..         MOV       R1,#?V0
   \   000035   12....       LCALL     ?UL_GT
   \   000038   5008         JNC       ??macBackoffTimerRealign_1
    403            {
    404              backoffDelta = backoffDelta - backoffTimerRollover;    /* result will be negative */
   \   00003A   90....       MOV       DPTR,#backoffTimerRollover
   \   00003D   78..         MOV       R0,#?V4
   \   00003F   12....       LCALL     ?L_SUB_X
    405            }
    406          
    407            /*-------------------------------------------------------------------------------
    408             *  Calculate the number of timer ticks to delay that will align the internal
    409             *  time base with the received frame.
    410             */
    411          
    412            /* retrieve the timer count when frame was received */
    413            timerDelayTicks = pMsg->mac.timestamp2;
   \                     ??macBackoffTimerRealign_1:
   \   000042   EE           MOV       A,R6
   \   000043   2428         ADD       A,#0x28
   \   000045   F582         MOV       DPL,A
   \   000047   E4           CLR       A
   \   000048   3F           ADDC      A,R7
   \   000049   F583         MOV       DPH,A
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   FE           MOV       R6,A
   \   00004D   A3           INC       DPTR
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   FF           MOV       R7,A
    414          
    415            /*
    416             *  Subtract the expected SFD time from the actual SFD time to find the needed
    417             *  timer adjustment. If subtracting the offset would result in a negative value,
    418             *  the tick delay must wrap around.
    419             */
    420            if (timerDelayTicks >= TIMER_TICKS_EXPECTED_AT_SFD)
   \   000050   C3           CLR       C
   \   000051   EE           MOV       A,R6
   \   000052   9466         SUBB      A,#0x66
   \   000054   EF           MOV       A,R7
   \   000055   9404         SUBB      A,#0x4
   \   000057   EE           MOV       A,R6
   \   000058   4009         JC        ??macBackoffTimerRealign_2
    421            {
    422              /* since delay count is greater than or equal to offset, subtract it directly */
    423              timerDelayTicks = timerDelayTicks - TIMER_TICKS_EXPECTED_AT_SFD;
   \   00005A   249A         ADD       A,#-0x66
   \   00005C   FE           MOV       R6,A
   \   00005D   EF           MOV       A,R7
   \   00005E   34FB         ADDC      A,#-0x5
   \   000060   FF           MOV       R7,A
   \   000061   800F         SJMP      ??macBackoffTimerRealign_3
    424            }
    425            else
    426            {
    427              /*
    428               *  The expected time is greater that actualy time so it cannot be subtracted directly.
    429               *  The tick count per backoff is added to wrap around within the backoff.
    430               *  Since a wrap around did happen, the backoff delta is adjusted by one.
    431               */
    432              timerDelayTicks = timerDelayTicks - TIMER_TICKS_EXPECTED_AT_SFD + MAC_RADIO_TIMER_TICKS_PER_BACKOFF();
   \                     ??macBackoffTimerRealign_2:
   \   000063   249A         ADD       A,#-0x66
   \   000065   FE           MOV       R6,A
   \   000066   EF           MOV       A,R7
   \   000067   3423         ADDC      A,#0x23
   \   000069   FF           MOV       R7,A
    433              backoffDelta--;
   \   00006A   90....       MOV       DPTR,#__Constant_ffffffff
   \   00006D   78..         MOV       R0,#?V4
   \   00006F   12....       LCALL     ?L_ADD_X
    434            }
    435          
    436            /*-------------------------------------------------------------------------------
    437             *  Calculate the new backoff count.
    438             */
    439          
    440            backoffCount = MAC_RADIO_BACKOFF_COUNT() - backoffDelta;
   \                     ??macBackoffTimerRealign_3:
   \   000072                ; Setup parameters for call to function macMcuOverflowCount
   \   000072   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000075   78..         MOV       R0,#?V0
   \   000077   79..         MOV       R1,#?V4
   \   000079   12....       LCALL     ?L_SUB
    441          
    442            if (backoffCount >= ((int32) backoffTimerRollover))
   \   00007C   90....       MOV       DPTR,#backoffTimerRollover
   \   00007F   78..         MOV       R0,#?V0
   \   000081   12....       LCALL     ?SL_GE_X
   \   000084   500A         JNC       ??macBackoffTimerRealign_4
    443            {
    444              backoffCount -= backoffTimerRollover;
   \   000086   90....       MOV       DPTR,#backoffTimerRollover
   \   000089   78..         MOV       R0,#?V0
   \   00008B   12....       LCALL     ?L_SUB_X
   \   00008E   8012         SJMP      ??macBackoffTimerRealign_5
    445            }
    446            else if (backoffCount < 0)
   \                     ??macBackoffTimerRealign_4:
   \   000090   90....       MOV       DPTR,#__Constant_0
   \   000093   78..         MOV       R0,#?V0
   \   000095   12....       LCALL     ?SL_GE_X
   \   000098   4008         JC        ??macBackoffTimerRealign_5
    447            {
    448              backoffCount += backoffTimerRollover;
   \   00009A   90....       MOV       DPTR,#backoffTimerRollover
   \   00009D   78..         MOV       R0,#?V0
   \   00009F   12....       LCALL     ?L_ADD_X
    449            }
    450          
    451            MAC_RADIO_TIMER_FORCE_DELAY(timerDelayTicks);
   \                     ??macBackoffTimerRealign_5:
   \   0000A2                ; Setup parameters for call to function macMcuTimerForceDelay
   \   0000A2   EE           MOV       A,R6
   \   0000A3   FA           MOV       R2,A
   \   0000A4   EF           MOV       A,R7
   \   0000A5   FB           MOV       R3,A
   \   0000A6   12....       LCALL     `??macMcuTimerForceDelay::?relay`; Banked call to: macMcuTimerForceDelay
    452            MAC_RADIO_BACKOFF_SET_COUNT(backoffCount);
   \   0000A9                ; Setup parameters for call to function macMcuOverflowSetCount
   \   0000A9   AA..         MOV       R2,?V0
   \   0000AB   AB..         MOV       R3,?V1
   \   0000AD   AC..         MOV       R4,?V2
   \   0000AF   AD..         MOV       R5,?V3
   \   0000B1   12....       LCALL     `??macMcuOverflowSetCount::?relay`; Banked call to: macMcuOverflowSetCount
    453          
    454            return(backoffDelta);
   \   0000B4   AA..         MOV       R2,?V4
   \   0000B6   AB..         MOV       R3,?V5
   \   0000B8   AC..         MOV       R4,?V6
   \   0000BA   AD..         MOV       R5,?V7
   \   0000BC   02....       LJMP      ??Subroutine5_0 & 0xFFFF
    455          }
    456          
    457          
    458          /**************************************************************************************************
    459           * @fn          macBackoffTimerCompareIsr
    460           *
    461           * @brief       Interrupt service routine that fires when the backoff count is equal
    462           *              to the trigger count.
    463           *
    464           * @param       none
    465           *
    466           * @return      none
    467           **************************************************************************************************
    468           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    469          MAC_INTERNAL_API void macBackoffTimerCompareIsr(void)
   \                     macBackoffTimerCompareIsr:
    470          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    471            macBackoffTimerTriggerCallback();
   \   000004                ; Setup parameters for call to function macBackoffTimerTriggerCallback
   \   000004   12....       LCALL     `??macBackoffTimerTriggerCallback::?relay`; Banked call to: macBackoffTimerTriggerCallback
    472          }
   \   000007   02....       LJMP      ?Subroutine0 & 0xFFFF
    473          
    474          /**************************************************************************************************
    475           * @fn          macBackoffTimerPeriodIsr
    476           *
    477           * @brief       Interrupt service routine that fires when the backoff count rolls over on
    478           *              overflow period.
    479           *
    480           * @param       none
    481           *
    482           * @return      none
    483           **************************************************************************************************
    484           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    485          MAC_INTERNAL_API void macBackoffTimerPeriodIsr(void)
   \                     macBackoffTimerPeriodIsr:
    486          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    487            macBackoffTimerRolloverCallback();
   \   000004                ; Setup parameters for call to function macBackoffTimerRolloverCallback
   \   000004   12....       LCALL     `??macBackoffTimerRolloverCallback::?relay`; Banked call to: macBackoffTimerRolloverCallback
    488          }
   \   000007   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c0000:
   \   000000   00000C00     DD 786432

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_80000000:
   \   000000   00000080     DD 2147483648

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffff:
   \   000000   FFFFFFFF     DD -1
    489          
    490          
    491          /**************************************************************************************************
    492          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      0   macBackoffTimerCancelTrigger
      0     12   macBackoffTimerCapture
        0     12   -> macMcuOverflowCapture
      2      0   macBackoffTimerCompareIsr
        2      0   -> macBackoffTimerTriggerCallback
      0     12   macBackoffTimerCount
        0     12   -> macMcuOverflowCount
      2      0   macBackoffTimerGetTrigger
      2      0   macBackoffTimerInit
        2      0   -> macBackoffTimerSetRollover
        2      0   -> macMcuOverflowSetCount
      2      0   macBackoffTimerPeriodIsr
        2      0   -> macBackoffTimerRolloverCallback
      0     16   macBackoffTimerRealign
        0     16   -> halAssertHandler
        0     16   -> macMcuOverflowCount
        0     16   -> macMcuOverflowSetCount
        0     16   -> macMcuTimerForceDelay
      2      0   macBackoffTimerReset
        2      0   -> macBackoffTimerInit
      0     16   macBackoffTimerSetCount
        0     16   -> halAssertHandler
        0     16   -> macMcuOverflowSetCount
      0     16   macBackoffTimerSetRollover
        0     16   -> halAssertHandler
        0     16   -> macMcuOverflowCount
        0     16   -> macMcuOverflowSetPeriod
      0     16   macBackoffTimerSetTrigger
        0     16   -> halAssertHandler
        0     16   -> macBackoffTimerTriggerCallback
        0     16   -> macMcuOverflowCount
        0     16   -> macMcuOverflowSetCompare


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ??Subroutine5_0
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
       1  T2IRQF
       1  T2IRQM
       1  _A_IEN0
       4  __Constant_0
       4  __Constant_80000000
       4  __Constant_c0000
       4  __Constant_ffffffff
       4  backoffTimerRollover
       4  backoffTimerTrigger
       3  macBackoffTimerCancelTrigger
      45  macBackoffTimerCapture
      10  macBackoffTimerCompareIsr
      35  macBackoffTimerCount
      10  macBackoffTimerGetTrigger
      37  macBackoffTimerInit
      10  macBackoffTimerPeriodIsr
     191  macBackoffTimerRealign
      16  macBackoffTimerReset
      77  macBackoffTimerSetCount
      50  macBackoffTimerSetRollover
      80  macBackoffTimerSetTrigger
      72  -- Other

 
 614 bytes in segment BANKED_CODE
  72 bytes in segment BANK_RELAYS
   3 bytes in segment SFR_AN
  16 bytes in segment XDATA_ROM_C
   8 bytes in segment XDATA_Z
 
  72 bytes of CODE     memory
   0 bytes of CONST    memory (+ 16 bytes shared)
   0 bytes of DATA     memory (+  3 bytes shared)
 614 bytes of HUGECODE memory
   8 bytes of XDATA    memory

Errors: none
Warnings: none
