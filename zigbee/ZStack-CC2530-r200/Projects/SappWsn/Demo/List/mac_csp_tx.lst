###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               21/May/2019  08:36:41
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
#    Command line       =  
#        -f C:\Users\97110\AppData\Local\Temp\EW7703.tmp
#        (C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK_DEMO -lC
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        -lA
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0031
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List\mac_csp_tx.lst
#    Object file        =  
#        C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj\mac_csp_tx.r51
#
###############################################################################

C:\Users\97110\Desktop\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_csp_tx.c
      3            Revised:        $Date: 2010-10-05 11:47:04 -0700 (Tue, 05 Oct 2010) $
      4            Revision:       $Revision: 23996 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                           Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9c
   \   unsigned char volatile __sfr T2CSPCFG
   \                     T2CSPCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe1
   \   unsigned char volatile __sfr RFST
   \                     RFST:
   \   000000                DS 1
     48          
     49          /* high-level */
     50          #include "mac_spec.h"
     51          #include "mac_pib.h"
     52          
     53          /* exported low-level */
     54          #include "mac_low_level.h"
     55          
     56          /* low-level specific */
     57          #include "mac_csp_tx.h"
     58          #include "mac_tx.h"
     59          #include "mac_rx.h"
     60          #include "mac_rx_onoff.h"
     61          
     62          /* target specific */
     63          #include "mac_radio_defs.h"
     64          
     65          /* debug */
     66          #include "mac_assert.h"
     67          
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                   CSP Defines / Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          /* immediate strobe commands */
     74          #define ISSTART     0xE1
     75          #define ISSTOP      0xE2
     76          #define ISCLEAR     0xFF
     77          
     78          /* strobe processor instructions */
     79          #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
     80          #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
     81          #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
     82          #define WEVENT1     (0xB8)                 /* wait for MAC timer compare                          */
     83          #define WAITX       (0xBC)                 /* wait for CSPX number of MAC timer overflows         */
     84          #define LABEL       (0xBB)                 /* set next instruction as start of loop               */
     85          #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
     86          #define INT         (0xBA)                 /* assert IRQ_CSP_INT interrupt                        */
     87          #define INCY        (0xC1)                 /* increment CSPY                                      */
     88          #define INCMAXY(m)  (0xC8 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
     89          #define DECY        (0xC4)                 /* decrement CSPY                                      */
     90          #define DECZ        (0xC5)                 /* decrement CSPZ                                      */
     91          #define RANDXY      (0xBD)                 /* load the lower CSPY bits of CSPX with random value  */
     92          
     93          /* strobe processor command instructions */
     94          #define SSTOP       (0xD2)    /* stop program execution                                      */
     95          #define SNOP        (0xD0)    /* no operation                                                */
     96          #define STXCAL      (0xDC)    /* enable and calibrate frequency synthesizer for TX           */
     97          #define SRXON       (0xD3)    /* turn on receiver                                            */
     98          #define STXON       (0xD9)    /* transmit after calibration                                  */
     99          #define STXONCCA    (0xDA)    /* transmit after calibration if CCA indicates clear channel   */
    100          #define SRFOFF      (0xDF)    /* turn off RX/TX                                              */
    101          #define SFLUSHRX    (0xDD)    /* flush receive FIFO                                          */
    102          #define SFLUSHTX    (0xDE)    /* flush transmit FIFO                                         */
    103          #define SACK        (0xD6)    /* send ACK frame                                              */
    104          #define SACKPEND    (0xD7)    /* send ACK frame with pending bit set                         */
    105          
    106          /* conditions for use with instructions SKIP and RPT */
    107          #define C_CCA_IS_VALID        0x00
    108          #define C_SFD_IS_ACTIVE       0x01
    109          #define C_CPU_CTRL_IS_ON      0x02
    110          #define C_END_INSTR_MEM       0x03
    111          #define C_CSPX_IS_ZERO        0x04
    112          #define C_CSPY_IS_ZERO        0x05
    113          #define C_CSPZ_IS_ZERO        0x06
    114          #define C_RSSI_IS_VALID       0x07
    115          
    116          /* negated conditions for use with instructions SKIP and RPT */
    117          #define C_NEGATE(c)   ((c) | 0x08)
    118          #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
    119          #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
    120          #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
    121          #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
    122          #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
    123          #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
    124          #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
    125          #define C_RSSI_IS_INVALID     C_NEGATE(C_RSSI_IS_VALID)
    126          
    127          
    128          /* ------------------------------------------------------------------------------------------------
    129           *                                         Defines
    130           * ------------------------------------------------------------------------------------------------
    131           */
    132          
    133          /* CSPZ return values from CSP program */
    134          #define CSPZ_CODE_TX_DONE           0
    135          #define CSPZ_CODE_CHANNEL_BUSY      1
    136          #define CSPZ_CODE_TX_ACK_TIME_OUT   2
    137          
    138          
    139          /* ------------------------------------------------------------------------------------------------
    140           *                                     Local Programs
    141           * ------------------------------------------------------------------------------------------------
    142           */
    143          static void  cspPrepForTxProgram(void);
    144          static void  cspWeventSetTriggerNow(void);
    145          static void  cspWeventSetTriggerSymbols(uint8 symbols);
    146          static uint8 cspReadCountSymbols(void);
    147          
    148          
    149          
    150          /* ------------------------------------------------------------------------------------------------
    151           *                                          Macros
    152           * ------------------------------------------------------------------------------------------------
    153           */
    154          #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP; RFST = ISCLEAR; )
    155          #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
    156          
    157          /*
    158           *  These macros improve readability of using T2CMP in conjunction with WEVENT.
    159           *
    160           *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
    161           *  It is configurable and has been set to compare against the upper byte of the timer value.
    162           *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
    163           *  the value of T2CMP.
    164           *
    165           *  Reading the timer value is done by reading the low byte first.  This latches the
    166           *  high byte.  A trick with the ternary operator is used by a macro below to force a
    167           *  read of the low byte when returning the value of the high byte.
    168           *
    169           *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT1 trigger point at the current timer count
    170           *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT1 trigger point in symbols
    171           *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
    172           */
    173          #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
    174          
    175          #define CSP_WEVENT_CLEAR_TRIGGER()            st( T2IRQF = ~TIMER2_COMPARE1F; )
    176          #define CSP_WEVENT_SET_TRIGGER_NOW()          cspWeventSetTriggerNow()
    177          #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     cspWeventSetTriggerSymbols(x)
    178          #define CSP_WEVENT_READ_COUNT_SYMBOLS()       cspReadCountSymbols()
    179          
    180          /*
    181           *  Number of bits used for aligning a slotted transmit to the backoff count (plus
    182           *  derived values).  There are restrictions on this value.  Compile time integrity
    183           *  checks will catch an illegal setting of this value.  A full explanation accompanies
    184           *  this compile time check (see bottom of this file).
    185           */
    186          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
    187          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
    188          #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
    189          
    190          
    191          /**************************************************************************************************
    192           * @fn          macCspTxReset
    193           *
    194           * @brief       Reset the CSP.  Immediately halts any running program.
    195           *
    196           * @param       none
    197           *
    198           * @return      none
    199           **************************************************************************************************
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          MAC_INTERNAL_API void macCspTxReset(void)
   \                     macCspTxReset:
    202          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    203            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV       DPTR,#0x61a4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   C2E4         CLR       0xE0 /* A   */.4
   \   00000A   F0           MOVX      @DPTR,A
    204            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   C2E3         CLR       0xE0 /* A   */.3
   \   00000E                REQUIRE ?Subroutine1
   \   00000E                REQUIRE RFST
   \   00000E                ; // Fall through to label ?Subroutine1
    205            CSP_STOP_AND_CLEAR_PROGRAM();
    206          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   75E1E2       MOV       0xe1,#-0x1e
   \   000004   75E1FF       MOV       0xe1,#-0x1
   \   000007   02....       LJMP      ??Subroutine5_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine5_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    207          
    208          
    209          /*=================================================================================================
    210           * @fn          cspWeventSetTriggerNow
    211           *
    212           * @brief       sets the WEVENT1 trigger point at the current timer count
    213           *
    214           * @param       none
    215           *
    216           * @return      symbols
    217           *=================================================================================================
    218           */
    219          static void cspWeventSetTriggerNow(void)
    220          {
    221            halIntState_t  s;
    222            uint8          temp0, temp1;
    223          
    224            /* Clear the compare interrupt flag for debugging purpose. */
    225            CSP_WEVENT_CLEAR_TRIGGER();
    226          
    227            /* copy current timer count to compare */
    228            HAL_ENTER_CRITICAL_SECTION(s);
    229            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    230            temp0 = T2M0;
    231            temp1 = T2M1;
    232          
    233            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    234             * compare = 0 for both the timer and the overflow counter.
    235             */
    236            if ((macChipVersion <= REV_B) && (temp0 == 0) && (temp1 == 0))
    237            {
    238              temp0++;
    239            }
    240          
    241            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    242            T2M0 = temp0;
    243            T2M1 = temp1;
    244            HAL_EXIT_CRITICAL_SECTION(s);
    245          }
    246          
    247          
    248          /*=================================================================================================
    249           * @fn          cspWeventSetTriggerSymbols
    250           *
    251           * @brief       sets the WEVENT1 trigger point in symbols
    252           *
    253           * @param       symbols
    254           *
    255           * @return      none
    256           *=================================================================================================
    257           */
    258          static void cspWeventSetTriggerSymbols(uint8 symbols)
    259          {
    260            halIntState_t  s;
    261            uint16         cmp;
    262          
    263            MAC_ASSERT(symbols <= MAC_A_UNIT_BACKOFF_PERIOD);
    264          
    265            /* Clear the compare interrupt flag for debugging purpose. */
    266            CSP_WEVENT_CLEAR_TRIGGER();
    267          
    268            HAL_ENTER_CRITICAL_SECTION(s);
    269            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    270            cmp  = (symbols) * MAC_RADIO_TIMER_TICKS_PER_SYMBOL();
    271          
    272            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    273             * compare = 0 for both the timer and the overflow counter.
    274             */
    275            if ((macChipVersion <= REV_B) && (cmp == 0))
    276            {
    277              cmp++;
    278            }
    279            T2M0 = (cmp & 0xFF);
    280            T2M1 = (cmp >> 8);
    281            HAL_EXIT_CRITICAL_SECTION(s);
    282          }
    283          
    284          
    285          /*=================================================================================================
    286           * @fn          cspReadCountSymbols
    287           *
    288           * @brief       reads the current timer count in symbols
    289           *
    290           * @param       none
    291           *
    292           * @return      symbols
    293           *=================================================================================================
    294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    295          static uint8 cspReadCountSymbols(void)
   \                     cspReadCountSymbols:
    296          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    297            uint8          countLow, countHigh;
    298            halIntState_t  s;
    299          
    300            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A9A8         MOV       R1,0xa8+0x0
   \   000002   C2AF         CLR       0xa8.7
    301            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000004   75C300       MOV       0xc3,#0x0
    302            countLow  = T2M0;
   \   000007   AAA2         MOV       R2,0xa2+0x0
    303            countHigh = T2M1;
   \   000009   A8A3         MOV       R0,0xa3+0x0
    304            HAL_EXIT_CRITICAL_SECTION(s);
   \   00000B   E9           MOV       A,R1
   \   00000C   A2E7         MOV       C,0xE0 /* A   */.7
   \   00000E   92AF         MOV       0xa8.7,C
    305          
    306            return (((countHigh << 8) | countLow) / MAC_RADIO_TIMER_TICKS_PER_SYMBOL());
   \   000010   E8           MOV       A,R0
   \   000011   F9           MOV       R1,A
   \   000012   EA           MOV       A,R2
   \   000013   F8           MOV       R0,A
   \   000014   7A00         MOV       R2,#0x0
   \   000016   7B02         MOV       R3,#0x2
   \   000018   12....       LCALL     ?S_DIV_MOD
   \   00001B   E8           MOV       A,R0
   \   00001C   F9           MOV       R1,A
   \   00001D   02....       LJMP      ?BRET
   \   000020                REQUIRE _A_IEN0
   \   000020                REQUIRE T2MSEL
   \   000020                REQUIRE T2M0
   \   000020                REQUIRE T2M1
    307          }
    308          
    309          
    310          /*=================================================================================================
    311           * @fn          cspPrepForTxProgram
    312           *
    313           * @brief       Prepare and initialize for transmit CSP program.
    314           *              Call *before* loading the CSP program!
    315           *
    316           * @param       none
    317           *
    318           * @return      none
    319           *=================================================================================================
    320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    321          static void cspPrepForTxProgram(void)
   \                     cspPrepForTxProgram:
    322          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    323            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
   \   000004   9061A4       MOV       DPTR,#0x61a4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   A2E4         MOV       C,0xE0 /* A   */.4
   \   00000A   5003         JNC       ??cspPrepForTxProgram_0
   \   00000C                ; Setup parameters for call to function halAssertHandler
   \   00000C   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    324          
    325            /* set CSP EVENT1 to T2 CMP1 */
    326            MAC_MCU_CONFIG_CSP_EVENT1();
   \                     ??cspPrepForTxProgram_0:
   \   00000F   759C01       MOV       0x9c,#0x1
    327          
    328            /* set up parameters for CSP transmit program */
    329            CSPZ = CSPZ_CODE_CHANNEL_BUSY;
   \   000012   9061E4       MOV       DPTR,#0x61e4
   \   000015   7401         MOV       A,#0x1
   \   000017   F0           MOVX      @DPTR,A
    330          
    331            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    332            CSP_STOP_AND_CLEAR_PROGRAM();
   \   000018   75E1E2       MOV       0xe1,#-0x1e
   \   00001B   75E1FF       MOV       0xe1,#-0x1
    333            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
   \   00001E   A8A8         MOV       R0,0xa8+0x0
   \   000020   C2AF         CLR       0xa8.7
   \   000022   759B00       MOV       0x9b,#0x0
   \   000025   7591EF       MOV       0x91,#-0x11
   \   000028   E8           MOV       A,R0
   \   000029   A2E7         MOV       C,0xE0 /* A   */.7
   \   00002B   92AF         MOV       0xa8.7,C
    334            MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
   \   00002D   A8A8         MOV       R0,0xa8+0x0
   \   00002F   C2AF         CLR       0xa8.7
   \   000031   759B00       MOV       0x9b,#0x0
   \   000034   7591F7       MOV       0x91,#-0x9
   \   000037   E8           MOV       A,R0
   \   000038   A2E7         MOV       C,0xE0 /* A   */.7
   \   00003A   92AF         MOV       0xa8.7,C
    335          }
   \   00003C   02....       LJMP      ??Subroutine5_0 & 0xFFFF
   \   00003F                REQUIRE T2CSPCFG
   \   00003F                REQUIRE RFST
   \   00003F                REQUIRE _A_IEN0
   \   00003F                REQUIRE S1CON
   \   00003F                REQUIRE RFIRQF1
    336          
    337          
    338          /**************************************************************************************************
    339           * @fn          macCspTxPrepCsmaUnslotted
    340           *
    341           * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
    342           *
    343           * @param       none
    344           *
    345           * @return      none
    346           **************************************************************************************************
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          MAC_INTERNAL_API void macCspTxPrepCsmaUnslotted(void)
   \                     macCspTxPrepCsmaUnslotted:
    349          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    350            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL     ?Subroutine2 & 0xFFFF
    351          
    352            /*----------------------------------------------------------------------
    353             *  Load CSP program :  Unslotted CSMA transmit
    354             */
    355          
    356            /*
    357             *  Wait for X number of backoffs, then wait for intra-backoff count
    358             *  to reach value set for WEVENT1.
    359             */
    360            RFST = WAITX;
    361            RFST = WEVENT1;
   \                     ??CrossCallReturnLabel_0:
   \   000007   75E1B8       MOV       0xe1,#-0x48
    362          
    363            /* wait until RSSI is valid */
    364            RFST = WHILE(C_RSSI_IS_INVALID);
   \   00000A   75E10F       MOV       0xe1,#0xf
    365          
    366            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    367            RFST = SKIP(1, C_CCA_IS_VALID);
   \   00000D   80..         SJMP      ?Subroutine0
   \   00000F                REQUIRE RFST
    368            RFST = SSTOP;
    369          
    370            /* CSMA has passed so transmit (actual frame starts one backoff from when strobe is sent) */
    371            RFST = STXON;
    372          
    373            /*
    374             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    375             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    376             *  though, is not certain.  For bulletproof operation, the first step is to wait
    377             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    378             *  for it to go active.
    379             */
    380            RFST = WHILE(C_SFD_IS_ACTIVE);
    381            RFST = WHILE(C_SFD_IS_INACTIVE);
    382          
    383            /*
    384             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    385             *  The ISR for this interrupt records the timestamp (which was just captured
    386             *  when SFD went high).
    387             */
    388            RFST = INT;
    389          
    390            /*
    391             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    392             *  the transmit was successful.
    393             */
    394            RFST = WHILE(C_SFD_IS_ACTIVE);
    395            RFST = DECZ;
    396          
    397            /*
    398             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    399             */
    400            RFST = SSTOP;
    401          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     `??cspPrepForTxProgram::?relay`; Banked call to: cspPrepForTxProgram
   \   000003   75E1BC       MOV       0xe1,#-0x44
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   75E110       MOV       0xe1,#0x10
   \   000003   75E1D2       MOV       0xe1,#-0x2e
   \   000006                REQUIRE ??Subroutine4_0
   \   000006                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   75E1D9       MOV       0xe1,#-0x27
   \   000003   75E101       MOV       0xe1,#0x1
   \   000006   75E109       MOV       0xe1,#0x9
   \   000009   75E1BA       MOV       0xe1,#-0x46
   \   00000C   75E101       MOV       0xe1,#0x1
   \   00000F   75E1C5       MOV       0xe1,#-0x3b
   \   000012   75E1D2       MOV       0xe1,#-0x2e
   \   000015                REQUIRE ??Subroutine5_0
   \   000015                ; // Fall through to label ??Subroutine5_0
    402          
    403          
    404          /**************************************************************************************************
    405           * @fn          macCspTxPrepCsmaSlotted
    406           *
    407           * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
    408           *
    409           * @param       none
    410           *
    411           * @return      none
    412           **************************************************************************************************
    413           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    414          MAC_INTERNAL_API void macCspTxPrepCsmaSlotted(void)
   \                     macCspTxPrepCsmaSlotted:
    415          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    416            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL     ?Subroutine2 & 0xFFFF
    417          
    418            /*----------------------------------------------------------------------
    419             *  Load CSP program :  Slotted CSMA transmit
    420             */
    421          
    422            /* wait for X number of backoffs */
    423            RFST = WAITX;
    424            
    425            /* sample RSSI, if it is valid then skip one extra backoff. */
    426            RFST = SKIP(1, C_RSSI_IS_VALID);
   \                     ??CrossCallReturnLabel_1:
   \   000007   75E117       MOV       0xe1,#0x17
    427            
    428            /* wait for one backoff to guarantee receiver has been on at least that long */
    429            RFST = WAITW(1);
   \   00000A   75E181       MOV       0xe1,#-0x7f
    430          
    431            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    432            RFST = SKIP(1, C_CCA_IS_VALID);
   \   00000D   75E110       MOV       0xe1,#0x10
    433            RFST = SSTOP;
   \   000010   75E1D2       MOV       0xe1,#-0x2e
    434          
    435            /* per slotted CSMA-CCA in specification, wait one backoff */
    436            RFST = WAITW(1);
   \   000013   75E181       MOV       0xe1,#-0x7f
    437          
    438            /* sample CCA again, if it fails exit from here, CSPZ indicates result */
    439            RFST = SKIP(1, C_CCA_IS_VALID);
   \   000016   80..         SJMP      ?Subroutine0
   \   000018                REQUIRE RFST
    440            RFST = SSTOP;
    441          
    442            /* CSMA has passed so transmit */
    443            RFST = STXON;
    444          
    445            /*
    446             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    447             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    448             *  though, is not certain.  For bulletproof operation, the first step is to wait
    449             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    450             *  for it to go active.
    451             */
    452            RFST = WHILE(C_SFD_IS_ACTIVE);
    453            RFST = WHILE(C_SFD_IS_INACTIVE);
    454          
    455            /*
    456             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    457             *  The ISR for this interrupt records the timestamp (which was just captured
    458             *  when SFD went high).
    459             */
    460            RFST = INT;
    461          
    462            /*
    463             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    464             *  the transmit was successful.
    465             */
    466            RFST = WHILE(C_SFD_IS_ACTIVE);
    467            RFST = DECZ;
    468          
    469            /*
    470             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    471             */
    472            RFST = SSTOP;
    473          }
    474          
    475          
    476          /**************************************************************************************************
    477           * @fn          macCspTxGoCsma
    478           *
    479           * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
    480           *              slotted or unslotted CSMA transmits.  When CSP program has finished,
    481           *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
    482           *              turn call macTxDoneCallback().
    483           *
    484           * @param       none
    485           *
    486           * @return      none
    487           **************************************************************************************************
    488           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    489          MAC_INTERNAL_API void macCspTxGoCsma(void)
   \                     macCspTxGoCsma:
    490          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    491            /*
    492             *  Set CSPX with the countdown time of the CSMA delay.  
    493             */
    494            CSPX = macTxCsmaBackoffDelay;
   \   000004   90....       MOV       DPTR,#macTxCsmaBackoffDelay
   \   000007   E0           MOVX      A,@DPTR
   \   000008   9061E2       MOV       DPTR,#0x61e2
   \   00000B   F0           MOVX      @DPTR,A
    495          
    496            /*
    497             *  Set WEVENT to trigger at the current value of the timer.  This allows
    498             *  unslotted CSMA to transmit just a little bit sooner.
    499             */
    500            CSP_WEVENT_SET_TRIGGER_NOW();
   \   00000C   75A1FD       MOV       0xa1,#-0x3
   \   00000F   A2AF         MOV       C,0xa8.7
   \   000011   E4           CLR       A
   \   000012   33           RLC       A
   \   000013   FA           MOV       R2,A
   \   000014   C2AF         CLR       0xa8.7
   \   000016   75C300       MOV       0xc3,#0x0
   \   000019   A8A2         MOV       R0,0xa2+0x0
   \   00001B   A9A3         MOV       R1,0xa3+0x0
   \   00001D   90....       MOV       DPTR,#macChipVersion
   \   000020   E0           MOVX      A,@DPTR
   \   000021   9412         SUBB      A,#0x12
   \   000023   5008         JNC       ??macCspTxGoCsma_0
   \   000025   E8           MOV       A,R0
   \   000026   7005         JNZ       ??macCspTxGoCsma_0
   \   000028   E9           MOV       A,R1
   \   000029   7002         JNZ       ??macCspTxGoCsma_0
   \   00002B   7801         MOV       R0,#0x1
   \                     ??macCspTxGoCsma_0:
   \   00002D   75C303       MOV       0xc3,#0x3
   \   000030   88A2         MOV       0xa2,R0
   \   000032   89A3         MOV       0xa3,R1
   \   000034   EA           MOV       A,R2
   \   000035   A2E0         MOV       C,0xE0 /* A   */.0
   \   000037   92AF         MOV       0xa8.7,C
    501          
    502            /*
    503             *  Enable interrupt that fires when CSP program stops.
    504             *  Also enable interrupt that fires when INT instruction
    505             *  is executed.
    506             */
    507            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   000039   12....       LCALL     ?Subroutine3 & 0xFFFF
    508            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    509          
    510            /*
    511             *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
    512             *  least one backoff before performing clear channel assessment (CCA).
    513             */
    514            macRxOn();
   \                     ??CrossCallReturnLabel_3:
   \   00003C                ; Setup parameters for call to function macRxOn
   \   00003C   12....       LCALL     `??macRxOn::?relay`; Banked call to: macRxOn
    515          
    516            /* start the CSP program */
    517            CSP_START_PROGRAM();
   \   00003F   75E1E1       MOV       0xe1,#-0x1f
    518          }
   \   000042   80..         SJMP      ??Subroutine5_0
   \   000044                REQUIRE RFST
   \   000044                REQUIRE T2IRQF
   \   000044                REQUIRE _A_IEN0
   \   000044                REQUIRE T2MSEL
   \   000044                REQUIRE T2M0
   \   000044                REQUIRE T2M1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   9061A4       MOV       DPTR,#0x61a4
   \   000003   E0           MOVX      A,@DPTR
   \   000004   D2E4         SETB      0xE0 /* A   */.4
   \   000006   F0           MOVX      @DPTR,A
   \   000007   E0           MOVX      A,@DPTR
   \   000008   D2E3         SETB      0xE0 /* A   */.3
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   22           RET
    519          
    520          
    521          /**************************************************************************************************
    522           * @fn          macCspTxPrepSlotted
    523           *
    524           * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
    525           *              Load CSP program and set CSP parameters.
    526           *
    527           * @param       none
    528           *
    529           * @return      none
    530           **************************************************************************************************
    531           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    532          MAC_INTERNAL_API void macCspTxPrepSlotted(void)
   \                     macCspTxPrepSlotted:
    533          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    534            cspPrepForTxProgram();
   \   000004                ; Setup parameters for call to function cspPrepForTxProgram
   \   000004   12....       LCALL     ?Subroutine2 & 0xFFFF
    535          
    536            /*----------------------------------------------------------------------
    537             *  Load CSP program :  Slotted transmit (no CSMA)
    538             */
    539          
    540            /* wait for X number of backoffs */
    541            RFST = WAITX;
    542          
    543            /* just transmit, no CSMA required */
    544            RFST = STXON;
   \                     ??CrossCallReturnLabel_2:
   \   000007   80..         SJMP      ??Subroutine4_0
   \   000009                REQUIRE RFST
    545          
    546            /*
    547             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    548             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    549             *  though, is not certain.  For bulletproof operation, the first step is to wait
    550             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    551             *  for it to go active.
    552             */
    553            RFST = WHILE(C_SFD_IS_ACTIVE);
    554            RFST = WHILE(C_SFD_IS_INACTIVE);
    555          
    556            /*
    557             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    558             *  The ISR for this interrupt records the timestamp (which was just captured
    559             *  when SFD went high).
    560             */
    561            RFST = INT;
    562          
    563            /*
    564             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    565             *  the transmit was successful.
    566             */
    567            RFST = WHILE(C_SFD_IS_ACTIVE);
    568            RFST = DECZ;
    569          
    570            /*
    571             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    572             */
    573            RFST = SSTOP;
    574          
    575          }
    576          
    577          
    578          /**************************************************************************************************
    579           * @fn          macCspTxGoSlotted
    580           *
    581           * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
    582           *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
    583           *              This ISR will in turn call macTxDoneCallback().
    584           *
    585           * @param       none
    586           *
    587           * @return      none
    588           **************************************************************************************************
    589           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    590          MAC_INTERNAL_API void macCspTxGoSlotted(void)
   \                     macCspTxGoSlotted:
    591          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    592            halIntState_t  s;
    593            uint8 lowByteOfBackoffCount;
    594            uint8 backoffCountdown;
    595          
    596            /*
    597             *  Enable interrupt that fires when CSP program stops.
    598             *  Also enable interrupt that fires when INT instruction
    599             *  is executed.
    600             */
    601            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   000005   12....       LCALL     ?Subroutine3 & 0xFFFF
    602            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    603          
    604            /* critical section needed for timer accesses */
    605            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??CrossCallReturnLabel_4:
   \   000008   A2AF         MOV       C,0xa8.7
   \   00000A   E4           CLR       A
   \   00000B   33           RLC       A
   \   00000C   F5..         MOV       ?V0,A
   \   00000E   C2AF         CLR       0xa8.7
    606          
    607            /* store lowest byte of backoff count (same as lowest byte of overflow count) */
    608            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000010   75C300       MOV       0xc3,#0x0
    609          
    610            /* Latch T2MOVFx */
    611            T2M0;
   \   000013   E5A2         MOV       A,0xa2
    612            lowByteOfBackoffCount = T2MOVF0;
   \   000015   AFA4         MOV       R7,0xa4+0x0
    613          
    614            /*
    615             *  Compute the number of backoffs until time to strobe transmit.  The strobe should
    616             *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
    617             *  countdown value is to determine when the lower bits would rollover and become zero,
    618             *  and then subtract one.
    619             */
    620            backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
   \   000017   740F         MOV       A,#0xf
   \   000019   5F           ANL       A,R7
   \   00001A   F8           MOV       R0,A
   \   00001B   740F         MOV       A,#0xf
   \   00001D   98           SUBB      A,R0
   \   00001E   FE           MOV       R6,A
    621          
    622            /*
    623             *  Store backoff countdown value into CSPX.
    624             *
    625             *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
    626             *  CSP program will immediately continue if CSPX is zero when executed.  However,
    627             *  if the countdown is zero, it means the transmit function was not called early
    628             *  enough for a properly timed slotted transmit.  The transmit will be late.
    629             */
    630            CSPX = backoffCountdown;
   \   00001F   9061E2       MOV       DPTR,#0x61e2
   \   000022   F0           MOVX      @DPTR,A
    631          
    632            /* Disable Rx and flush RXFIFO due to chip bug #1546 */
    633            macRxHardDisable();
   \   000023                ; Setup parameters for call to function macRxHardDisable
   \   000023   12....       LCALL     `??macRxHardDisable::?relay`; Banked call to: macRxHardDisable
    634          
    635            /*
    636             *  The receiver will be turned on during CSP execution, guaranteed.
    637             *  Since it is not possible to update C variables within the CSP,
    638             *  the new "on" state of the receiver must be set a little early
    639             *  here before the CSP is started.
    640             */
    641            MAC_RX_WAS_FORCED_ON();
   \   000026   90....       MOV       DPTR,#macRxOnFlag
   \   000029   7401         MOV       A,#0x1
   \   00002B   F0           MOVX      @DPTR,A
    642          
    643            /* start the CSP program */
    644            CSP_START_PROGRAM();
   \   00002C   75E1E1       MOV       0xe1,#-0x1f
    645          
    646            /*
    647             *  If the previous stored low byte of the backoff count is no longer equal to
    648             *  the current value, a rollover has occurred.  This means the backoff countdown
    649             *  stored in CSPX may not be correct.
    650             *
    651             *  In this case, the value of CSPX is reloaded to reflect the correct backoff
    652             *  countdown value (this is one less than what was just used as a rollover has
    653             *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
    654             *  of another rollover occurring.  This means the value written to CSPX is guaranteed
    655             *  to be accurate.
    656             *
    657             *  Also, the logic below ensures that the value written to CSPX is at least one.
    658             *  This is needed for correct operation of the WAITX instruction.  As with an
    659             *  initial backoff countdown value of zero, if this case does occur, it means the
    660             *  transmit function was not called early enough for a properly timed slotted transmit.
    661             *  The transmit will be late.
    662             *
    663             *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
    664             *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
    665             *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
    666             *  collision is not possible (still within a critical section here too).
    667             */
    668            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00002F   75C300       MOV       0xc3,#0x0
    669          
    670            /* Latch T2MOVFx */
    671            T2M0;
   \   000032   E5A2         MOV       A,0xa2
    672            if ((lowByteOfBackoffCount != T2MOVF0) && (backoffCountdown > 1))
   \   000034   E5A4         MOV       A,0xa4
   \   000036   6F           XRL       A,R7
   \   000037   600D         JZ        ??macCspTxGoSlotted_0
   \   000039   EE           MOV       A,R6
   \   00003A   C3           CLR       C
   \   00003B   9402         SUBB      A,#0x2
   \   00003D   4007         JC        ??macCspTxGoSlotted_0
    673            {
    674              CSPX = backoffCountdown - 1;
   \   00003F   74FF         MOV       A,#-0x1
   \   000041   2E           ADD       A,R6
   \   000042   9061E2       MOV       DPTR,#0x61e2
   \   000045   F0           MOVX      @DPTR,A
    675            }
    676          
    677            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macCspTxGoSlotted_0:
   \   000046   E5..         MOV       A,?V0
   \   000048   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004A   92AF         MOV       0xa8.7,C
    678          }
   \   00004C   7F01         MOV       R7,#0x1
   \   00004E   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000051                REQUIRE _A_IEN0
   \   000051                REQUIRE T2MSEL
   \   000051                REQUIRE T2M0
   \   000051                REQUIRE T2MOVF0
   \   000051                REQUIRE RFST
    679          
    680          
    681          /**************************************************************************************************
    682           * @fn          macCspForceTxDoneIfPending
    683           *
    684           * @brief       The function clears out any pending TX done logic.  Used by receive logic
    685           *              to make sure its ISR does not prevent transmit from completing in a reasonable
    686           *              amount of time.
    687           *
    688           * @param       none
    689           *
    690           * @return      none
    691           **************************************************************************************************
    692           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    693          MAC_INTERNAL_API void macCspForceTxDoneIfPending(void)
   \                     macCspForceTxDoneIfPending:
    694          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    695            if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
   \   000004   9061E4       MOV       DPTR,#0x61e4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   7017         JNZ       ??macCspForceTxDoneIfPending_0
   \   00000A   9061A4       MOV       DPTR,#0x61a4
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   A2E4         MOV       C,0xE0 /* A   */.4
   \   000010   500F         JNC       ??macCspForceTxDoneIfPending_0
    696            {
    697              MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000012   E0           MOVX      A,@DPTR
   \   000013   C2E4         CLR       0xE0 /* A   */.4
   \   000015   F0           MOVX      @DPTR,A
    698              if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
   \   000016   E0           MOVX      A,@DPTR
   \   000017   A2E3         MOV       C,0xE0 /* A   */.3
   \   000019   5003         JNC       ??macCspForceTxDoneIfPending_1
    699              {
    700                macCspTxIntIsr();
   \   00001B                ; Setup parameters for call to function macCspTxIntIsr
   \   00001B   12....       LCALL     `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
    701              }
    702              macTxDoneCallback();
   \                     ??macCspForceTxDoneIfPending_1:
   \   00001E                ; Setup parameters for call to function macTxDoneCallback
   \   00001E   12....       LCALL     `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
    703            }
    704          }
   \                     ??macCspForceTxDoneIfPending_0:
   \   000021   02....       LJMP      ??Subroutine5_0 & 0xFFFF
    705          
    706          
    707          /**************************************************************************************************
    708           * @fn          macCspTxRequestAckTimeoutCallback
    709           *
    710           * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
    711           *              the function macCspTxStopIsr() is called via an interrupt.
    712           *
    713           * @param       none
    714           *
    715           * @return      none
    716           **************************************************************************************************
    717           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    718          MAC_INTERNAL_API void macCspTxRequestAckTimeoutCallback(void)
   \                     macCspTxRequestAckTimeoutCallback:
    719          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    720            uint8 startSymbol;
    721            uint8 symbols;
    722            uint8 rollovers;
    723          
    724            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
   \   000005   9061A4       MOV       DPTR,#0x61a4
   \   000008   E0           MOVX      A,@DPTR
   \   000009   A2E4         MOV       C,0xE0 /* A   */.4
   \   00000B   5003         JNC       ??macCspTxRequestAckTimeoutCallback_0
   \   00000D                ; Setup parameters for call to function halAssertHandler
   \   00000D   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    725          
    726            /* record current symbol count */
    727            startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
   \                     ??macCspTxRequestAckTimeoutCallback_0:
   \   000010                ; Setup parameters for call to function cspReadCountSymbols
   \   000010   12....       LCALL     `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
   \   000013   E9           MOV       A,R1
   \   000014   F5..         MOV       ?V0,A
    728          
    729            /* set symbol timeout from PIB */
    730            symbols = macPib.ackWaitDuration;
   \   000016   90....       MOV       DPTR,#macPib
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   FE           MOV       R6,A
    731          
    732            /* make sure delay value is not too small for logic to handle */
    733            MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
   \   00001B   C3           CLR       C
   \   00001C   9415         SUBB      A,#0x15
   \   00001E   5003         JNC       ??macCspTxRequestAckTimeoutCallback_1
   \   000020                ; Setup parameters for call to function halAssertHandler
   \   000020   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    734          
    735            /* subtract out symbols left in current backoff period */
    736            symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
   \                     ??macCspTxRequestAckTimeoutCallback_1:
   \   000023   74EC         MOV       A,#-0x14
   \   000025   25..         ADD       A,?V0
   \   000027   2E           ADD       A,R6
   \   000028   FE           MOV       R6,A
    737          
    738            /* calculate rollovers needed for remaining symbols */
    739            rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
   \   000029   75F014       MOV       B,#0x14
   \   00002C   84           DIV       AB
   \   00002D   FF           MOV       R7,A
    740          
    741            /* calculate symbols that still need counted after last rollover */
    742            symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
   \   00002E   75F014       MOV       B,#0x14
   \   000031   A4           MUL       AB
   \   000032   CE           XCH       A,R6
   \   000033   9E           SUBB      A,R6
   \   000034   FE           MOV       R6,A
    743          
    744            /* add one to rollovers to account for symbols remaining in the current backoff period */
    745            rollovers++;
   \   000035   0F           INC       R7
    746          
    747            /* set up parameters for CSP program */
    748            CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
   \   000036   9061E4       MOV       DPTR,#0x61e4
   \   000039   7402         MOV       A,#0x2
   \   00003B   F0           MOVX      @DPTR,A
    749            CSPX = rollovers;
   \   00003C   EF           MOV       A,R7
   \   00003D   9061E2       MOV       DPTR,#0x61e2
   \   000040   F0           MOVX      @DPTR,A
    750            CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
   \   000041   EE           MOV       A,R6
   \   000042   C3           CLR       C
   \   000043   9415         SUBB      A,#0x15
   \   000045   4003         JC        ??macCspTxRequestAckTimeoutCallback_2
   \   000047                ; Setup parameters for call to function halAssertHandler
   \   000047   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
   \                     ??macCspTxRequestAckTimeoutCallback_2:
   \   00004A   75A1FD       MOV       0xa1,#-0x3
   \   00004D   A2AF         MOV       C,0xa8.7
   \   00004F   E4           CLR       A
   \   000050   33           RLC       A
   \   000051   FA           MOV       R2,A
   \   000052   C2AF         CLR       0xa8.7
   \   000054   75C303       MOV       0xc3,#0x3
   \   000057   EE           MOV       A,R6
   \   000058   F5..         MOV       ?V2,A
   \   00005A   75..00       MOV       ?V3,#0x0
   \   00005D   7409         MOV       A,#0x9
   \   00005F   78..         MOV       R0,#?V2
   \   000061   12....       LCALL     ?S_SHL
   \   000064   F8           MOV       R0,A
   \   000065   A9..         MOV       R1,?V3
   \   000067   90....       MOV       DPTR,#macChipVersion
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   C3           CLR       C
   \   00006C   9412         SUBB      A,#0x12
   \   00006E   5006         JNC       ??macCspTxRequestAckTimeoutCallback_3
   \   000070   E9           MOV       A,R1
   \   000071   7003         JNZ       ??macCspTxRequestAckTimeoutCallback_3
   \   000073   08           INC       R0
   \   000074   7900         MOV       R1,#0x0
   \                     ??macCspTxRequestAckTimeoutCallback_3:
   \   000076   E8           MOV       A,R0
   \   000077   F5A2         MOV       0xa2,A
   \   000079   E9           MOV       A,R1
   \   00007A   F5A3         MOV       0xa3,A
   \   00007C   EA           MOV       A,R2
   \   00007D   A2E0         MOV       C,0xE0 /* A   */.0
   \   00007F   92AF         MOV       0xa8.7,C
    751          
    752            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    753            CSP_STOP_AND_CLEAR_PROGRAM();
   \   000081   75E1E2       MOV       0xe1,#-0x1e
   \   000084   75E1FF       MOV       0xe1,#-0x1
    754            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
   \   000087   A8A8         MOV       R0,0xa8+0x0
   \   000089   C2AF         CLR       0xa8.7
   \   00008B   759B00       MOV       0x9b,#0x0
   \   00008E   7591EF       MOV       0x91,#-0x11
   \   000091   E8           MOV       A,R0
   \   000092   A2E7         MOV       C,0xE0 /* A   */.7
   \   000094   92AF         MOV       0xa8.7,C
    755          
    756            /*--------------------------
    757             * load CSP program
    758             */
    759            RFST = WAITX;
   \   000096   75E1BC       MOV       0xe1,#-0x44
    760            RFST = WEVENT1;
   \   000099   75E1B8       MOV       0xe1,#-0x48
    761            RFST = SSTOP;
   \   00009C   75E1D2       MOV       0xe1,#-0x2e
    762          
    763            /*--------------------------
    764             */
    765          
    766            /* run CSP program */
    767            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
   \   00009F   9061A4       MOV       DPTR,#0x61a4
   \   0000A2   E0           MOVX      A,@DPTR
   \   0000A3   D2E4         SETB      0xE0 /* A   */.4
   \   0000A5   F0           MOVX      @DPTR,A
    768            CSP_START_PROGRAM();
   \   0000A6   75E1E1       MOV       0xe1,#-0x1f
    769          
    770            /*
    771             *  For bullet proof operation, must account for the boundary condition
    772             *  where a rollover occurs after count was read but before CSP program
    773             *  was started.
    774             *
    775             *  If current symbol count is less that the symbol count recorded at the
    776             *  start of this function, a rollover has occurred.
    777             */
    778            if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
   \   0000A9                ; Setup parameters for call to function cspReadCountSymbols
   \   0000A9   12....       LCALL     `??cspReadCountSymbols::?relay`; Banked call to: cspReadCountSymbols
   \   0000AC   E9           MOV       A,R1
   \   0000AD   C3           CLR       C
   \   0000AE   95..         SUBB      A,?V0
   \   0000B0   500A         JNC       ??macCspTxRequestAckTimeoutCallback_4
    779            {
    780              /* a rollover has occurred, make sure it was accounted for */
    781              if (CSPX == rollovers)
   \   0000B2   9061E2       MOV       DPTR,#0x61e2
   \   0000B5   E0           MOVX      A,@DPTR
   \   0000B6   6F           XRL       A,R7
   \   0000B7   7003         JNZ       ??macCspTxRequestAckTimeoutCallback_4
    782              {
    783                /*
    784                 *  Rollover event missed, manually decrement CSPX to adjust.
    785                 *
    786                 *  Note : there is a very small chance that CSPX does not
    787                 *  get decremented.  This would occur if CSPX were written
    788                 *  at exactly the same time a timer overflow is occurring (which
    789                 *  causes the CSP instruction WAITX to decrement CSPX).  This
    790                 *  would be extremely rare, but if it does happen, the only
    791                 *  consequence is that the ACK timeout period is extended
    792                 *  by one backoff.
    793                 */
    794                CSPX--;
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   14           DEC       A
   \   0000BB   F0           MOVX      @DPTR,A
    795              }
    796            }
    797          }
   \                     ??macCspTxRequestAckTimeoutCallback_4:
   \   0000BC   7F04         MOV       R7,#0x4
   \   0000BE   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0000C1                REQUIRE RFST
   \   0000C1                REQUIRE _A_IEN0
   \   0000C1                REQUIRE S1CON
   \   0000C1                REQUIRE RFIRQF1
   \   0000C1                REQUIRE T2IRQF
   \   0000C1                REQUIRE T2MSEL
   \   0000C1                REQUIRE T2M0
   \   0000C1                REQUIRE T2M1
    798          
    799          
    800          /**************************************************************************************************
    801           * @fn          macCspTxCancelAckTimeoutCallback
    802           *
    803           * @brief       Cancels previous request for ACK timeout callback.
    804           *
    805           * @param       none
    806           *
    807           * @return      none
    808           **************************************************************************************************
    809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    810          MAC_INTERNAL_API void macCspTxCancelAckTimeoutCallback(void)
   \                     macCspTxCancelAckTimeoutCallback:
    811          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    812            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV       DPTR,#0x61a4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   C2E4         CLR       0xE0 /* A   */.4
   \   00000A   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   00000D                REQUIRE RFST
    813            CSP_STOP_AND_CLEAR_PROGRAM();
    814          }
    815          
    816          
    817          /**************************************************************************************************
    818           * @fn          macCspTxIntIsr
    819           *
    820           * @brief       Interrupt service routine for handling INT type interrupts from CSP.
    821           *              This interrupt happens when the CSP instruction INT is executed.  It occurs
    822           *              once the SFD signal goes high indicating that transmit has successfully
    823           *              started.  The timer value has been captured at this point and timestamp
    824           *              can be stored.
    825           *
    826           * @param       none
    827           *
    828           * @return      none
    829           **************************************************************************************************
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          MAC_INTERNAL_API void macCspTxIntIsr(void)
   \                     macCspTxIntIsr:
    832          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    833            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV       DPTR,#0x61a4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   C2E3         CLR       0xE0 /* A   */.3
   \   00000A   F0           MOVX      @DPTR,A
    834          
    835            /* execute callback function that records transmit timestamp */
    836            macTxTimestampCallback();
   \   00000B                ; Setup parameters for call to function macTxTimestampCallback
   \   00000B   12....       LCALL     `??macTxTimestampCallback::?relay`; Banked call to: macTxTimestampCallback
    837          }
   \   00000E   02....       LJMP      ??Subroutine5_0 & 0xFFFF
    838          
    839          
    840          /**************************************************************************************************
    841           * @fn          macCspTxStopIsr
    842           *
    843           * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
    844           *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
    845           *              program, 2) executing SSTOP within the program, 3) executing immediate
    846           *              instruction ISSTOP.
    847           *
    848           *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
    849           *              is the end of a transmit.
    850           *
    851           * @param       none
    852           *
    853           * @return      none
    854           **************************************************************************************************
    855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          MAC_INTERNAL_API void macCspTxStopIsr(void)
   \                     macCspTxStopIsr:
    857          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    858            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
   \   000004   9061A4       MOV       DPTR,#0x61a4
   \   000007   E0           MOVX      A,@DPTR
   \   000008   C2E4         CLR       0xE0 /* A   */.4
   \   00000A   F0           MOVX      @DPTR,A
    859          
    860            /* Whether we are waiting for ACK or not, turn on the compression workaround
    861             * for incoming ACK or the next receive. 
    862             */
    863            COMPRESSION_WORKAROUND_ON();
    864            
    865            if (CSPZ == CSPZ_CODE_TX_DONE)
   \   00000B   9061E4       MOV       DPTR,#0x61e4
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   7005         JNZ       ??macCspTxStopIsr_0
    866            {
    867              macTxDoneCallback();
   \   000011                ; Setup parameters for call to function macTxDoneCallback
   \   000011   12....       LCALL     `??macTxDoneCallback::?relay`; Banked call to: macTxDoneCallback
   \   000014   8015         SJMP      ??macCspTxStopIsr_1
    868            }
    869            else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
   \                     ??macCspTxStopIsr_0:
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   7005         JNZ       ??macCspTxStopIsr_2
    870            {
    871              macTxChannelBusyCallback();
   \   00001B                ; Setup parameters for call to function macTxChannelBusyCallback
   \   00001B   12....       LCALL     `??macTxChannelBusyCallback::?relay`; Banked call to: macTxChannelBusyCallback
   \   00001E   800B         SJMP      ??macCspTxStopIsr_1
    872            }
    873            else
    874            {
    875              MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
   \                     ??macCspTxStopIsr_2:
   \   000020   E0           MOVX      A,@DPTR
   \   000021   6402         XRL       A,#0x2
   \   000023   6003         JZ        ??macCspTxStopIsr_3
   \   000025                ; Setup parameters for call to function halAssertHandler
   \   000025   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    876              macTxAckNotReceivedCallback();
   \                     ??macCspTxStopIsr_3:
   \   000028                ; Setup parameters for call to function macTxAckNotReceivedCallback
   \   000028   12....       LCALL     `??macTxAckNotReceivedCallback::?relay`; Banked call to: macTxAckNotReceivedCallback
    877            }
    878          }
   \                     ??macCspTxStopIsr_1:
   \   00002B   02....       LJMP      ??Subroutine5_0 & 0xFFFF
    879          
    880          
    881          
    882          /**************************************************************************************************
    883           *                                  Compile Time Integrity Checks
    884           **************************************************************************************************
    885           */
    886          
    887          #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
    888          #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
    889          #endif
    890          
    891          #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
    892          #error "WARNING!  This define value changed.  It was selected for optimum performance."
    893          #endif
    894          
    895          #if (T2THD_TICKS_PER_SYMBOL == 0)
    896          #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
    897          #endif
    898          
    899          #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
    900          #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
    901          #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
    902          /*
    903           *  In other words, the backoff count for the number of superframe rolls over before the
    904           *  specified number of bits rollover.  For example, if backoff count for a superframe
    905           *  rolls over at 48, the binary number immediately before a rollover is 00101111.
    906           *  In this case four bits would work as an alignment mask.  Five would not work though as
    907           *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
    908           *  would be expected) because it a new superframe is starting.
    909           */
    910          #endif
    911          #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
    912          #error "ERROR!  Not enough backoff countdown bits to be practical."
    913          #endif
    914          
    915          
    916          /**************************************************************************************************
    917          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   cspPrepForTxProgram
        2      0   -> halAssertHandler
      0     12   cspReadCountSymbols
      2      0   macCspForceTxDoneIfPending
        2      0   -> macCspTxIntIsr
        2      0   -> macTxDoneCallback
      2      0   macCspTxCancelAckTimeoutCallback
      2      0   macCspTxGoCsma
        2      0   -> macRxOn
      0      9   macCspTxGoSlotted
        0      9   -> macRxHardDisable
      2      0   macCspTxIntIsr
        2      0   -> macTxTimestampCallback
      2      0   macCspTxPrepCsmaSlotted
        2      0   -> cspPrepForTxProgram
      2      0   macCspTxPrepCsmaUnslotted
        2      0   -> cspPrepForTxProgram
      2      0   macCspTxPrepSlotted
        2      0   -> cspPrepForTxProgram
      0     12   macCspTxRequestAckTimeoutCallback
        0     12   -> cspReadCountSymbols
        0     12   -> halAssertHandler
      2      0   macCspTxReset
      2      0   macCspTxStopIsr
        2      0   -> halAssertHandler
        2      0   -> macTxAckNotReceivedCallback
        2      0   -> macTxChannelBusyCallback
        2      0   -> macTxDoneCallback


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      21  ??Subroutine4_0
       7  ??Subroutine5_0
       6  ?Subroutine0
      10  ?Subroutine1
       7  ?Subroutine2
      12  ?Subroutine3
       1  RFIRQF1
       1  RFST
       1  S1CON
       1  T2CSPCFG
       1  T2IRQF
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MSEL
       1  _A_IEN0
      63  cspPrepForTxProgram
      32  cspReadCountSymbols
      36  macCspForceTxDoneIfPending
      13  macCspTxCancelAckTimeoutCallback
      68  macCspTxGoCsma
      81  macCspTxGoSlotted
      17  macCspTxIntIsr
      24  macCspTxPrepCsmaSlotted
      15  macCspTxPrepCsmaUnslotted
       9  macCspTxPrepSlotted
     193  macCspTxRequestAckTimeoutCallback
      14  macCspTxReset
      46  macCspTxStopIsr
      78  -- Other

 
 674 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
  10 bytes in segment SFR_AN
 
  78 bytes of CODE     memory
   0 bytes of DATA     memory (+ 10 bytes shared)
 674 bytes of HUGECODE memory

Errors: none
Warnings: none
