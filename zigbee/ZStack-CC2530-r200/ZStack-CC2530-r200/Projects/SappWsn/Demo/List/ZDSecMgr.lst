###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Apr/2019  16:49:38
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWF6C6.tmp
#        (E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\stack\zdo\ZDSecMgr.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK_DEMO -lC
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        -lA
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0056
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List\ZDSecMgr.lst
#    Object file        =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj\ZDSecMgr.r51
#
###############################################################################

E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2011-07-22 16:06:08 -0700 (Fri, 22 Jul 2011) $
      4            Revision:       $Revision: 26893 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          
     62          /******************************************************************************
     63           * CONSTANTS
     64           */
     65          // maximum number of devices managed by this Security Manager
     66          #if !defined ( ZDSECMGR_DEVICE_MAX )
     67            #define ZDSECMGR_DEVICE_MAX 3
     68          #endif
     69          
     70          // total number of preconfigured devices (EXT address, MASTER key)
     71          //devtag.pro.security
     72          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     73          #define ZDSECMGR_PRECONFIG_MAX 0
     74          
     75          // maximum number of MASTER keys this device may hold
     76          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     77          
     78          // maximum number of LINK keys this device may store
     79          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // total number of devices under control - authentication, SKKE, etc.
     82          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of stored devices
     85          #if !defined ( ZDSECMGR_STORED_DEVICES )
     86            #define ZDSECMGR_STORED_DEVICES 3
     87          #endif
     88          
     89          // Total number of preconfigured trust center link key
     90          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     91            #define ZDSECMGR_TC_DEVICE_MAX 1
     92          #endif
     93          
     94          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     95            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     96          #endif
     97          
     98          #define ZDSECMGR_CTRL_NONE       0
     99          #define ZDSECMGR_CTRL_INIT       1
    100          #define ZDSECMGR_CTRL_TK_MASTER  2
    101          #define ZDSECMGR_CTRL_SKKE_INIT  3
    102          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    103          #define ZDSECMGR_CTRL_SKKE_DONE  5
    104          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    105          #define ZDSECMGR_CTRL_TK_NWK     7
    106          
    107          #define ZDSECMGR_CTRL_BASE_CNTR      1
    108          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    109          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    110          
    111          // set SKA slot maximum
    112          #define ZDSECMGR_SKA_SLOT_MAX 1
    113          
    114          // APSME Stub Implementations
    115          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    116          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    117          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    118          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    119          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    120          
    121          /******************************************************************************
    122           * TYPEDEFS
    123           */
    124          typedef struct
    125          {
    126            uint8 extAddr[Z_EXTADDR_LEN];
    127            uint8 key[SEC_KEY_LEN];
    128          } ZDSecMgrPreConfigData_t;
    129          
    130          typedef struct
    131          {
    132            uint16 ami;
    133            uint8  key[SEC_KEY_LEN];
    134          } ZDSecMgrMasterKeyData_t;
    135          
    136          typedef struct
    137          {
    138            uint16            ami;
    139            uint16            keyNvId;   // index to the Link Key table in NV
    140            ZDSecMgr_Authentication_Option authenticateOption;
    141          } ZDSecMgrEntry_t;
    142          
    143          typedef struct
    144          {
    145            ZDSecMgrEntry_t* entry;
    146            uint16           parentAddr;
    147            uint8            secure;
    148            uint8            state;
    149            uint8            cntr;
    150          } ZDSecMgrCtrl_t;
    151          
    152          typedef struct
    153          {
    154            uint16          nwkAddr;
    155            uint8*          extAddr;
    156            uint16          parentAddr;
    157            uint8           secure;
    158            uint8           devStatus;
    159            ZDSecMgrCtrl_t* ctrl;
    160          } ZDSecMgrDevice_t;
    161          
    162          /******************************************************************************
    163           * LOCAL VARIABLES
    164           */
    165          #if 0 // Taken out because the following functionality is only used for test
    166                // purpose. A more efficient (above) way is used. It can be put
    167                // back in if customers request for a white/black list feature.
    168          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    169          {
    170            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    171            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    172            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    173          };
    174          #endif
    175          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    177            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    178          
    179          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    180          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171
    181            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    182             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    183          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    184          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    185          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    186          
    187          //devtag.pro.security - remove this
    188          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    189          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    190          {
    191            //---------------------------------------------------------------------------
    192            // DEVICE A
    193            //---------------------------------------------------------------------------
    194            {
    195              // extAddr
    196              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    197          
    198              // key
    199              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    200               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    201            },
    202            //---------------------------------------------------------------------------
    203            // DEVICE B
    204            //---------------------------------------------------------------------------
    205            {
    206              // extAddr
    207              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    208          
    209              // key
    210              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    211               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    212            },
    213            //---------------------------------------------------------------------------
    214            // DEVICE C
    215            //---------------------------------------------------------------------------
    216            {
    217              // extAddr
    218              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    219          
    220              // key
    221              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    222               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    223            },
    224          };
    225          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    226          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    227          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    228          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    229          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    230          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    231          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    232          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    236          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    237          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    238          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    239          
    240          /******************************************************************************
    241           * PRIVATE FUNCTIONS
    242           *
    243           *   ZDSecMgrMasterKeyInit
    244           *   ZDSecMgrAddrStore
    245           *   ZDSecMgrExtAddrStore
    246           *   ZDSecMgrExtAddrLookup
    247           *   ZDSecMgrMasterKeyLookup
    248           *   ZDSecMgrMasterKeyStore
    249           *   ZDSecMgrEntryInit
    250           *   ZDSecMgrEntryLookup
    251           *   ZDSecMgrEntryLookupAMI
    252           *   ZDSecMgrEntryLookupExt
    253           *   ZDSecMgrEntryLookupExtGetIndex
    254           *   ZDSecMgrEntryFree
    255           *   ZDSecMgrEntryNew
    256           *   ZDSecMgrCtrlInit
    257           *   ZDSecMgrCtrlRelease
    258           *   ZDSecMgrCtrlLookup
    259           *   ZDSecMgrCtrlSet
    260           *   ZDSecMgrCtrlAdd
    261           *   ZDSecMgrCtrlTerm
    262           *   ZDSecMgrCtrlReset
    263           *   ZDSecMgrMasterKeyLoad
    264           *   ZDSecMgrAppKeyGet
    265           *   ZDSecMgrAppKeyReq
    266           *   ZDSecMgrEstablishKey
    267           *   ZDSecMgrSendMasterKey
    268           *   ZDSecMgrSendNwkKey
    269           *   ZDSecMgrDeviceEntryRemove
    270           *   ZDSecMgrDeviceEntryAdd
    271           *   ZDSecMgrDeviceCtrlHandler
    272           *   ZDSecMgrDeviceCtrlSetup
    273           *   ZDSecMgrDeviceCtrlUpdate
    274           *   ZDSecMgrDeviceRemove
    275           *   ZDSecMgrDeviceValidateSKKE
    276           *   ZDSecMgrDeviceValidateRM
    277           *   ZDSecMgrDeviceValidateCM
    278           *   ZDSecMgrDeviceValidate
    279           *   ZDSecMgrDeviceJoin
    280           *   ZDSecMgrDeviceJoinDirect
    281           *   ZDSecMgrDeviceJoinFwd
    282           *   ZDSecMgrDeviceNew
    283           *   ZDSecMgrAssocDeviceAuth
    284           *   ZDSecMgrAuthInitiate
    285           *   ZDSecMgrAuthNwkKey
    286           *   APSME_TCLinkKeyInit
    287           *   APSME_IsDefaultTCLK
    288           */
    289          //-----------------------------------------------------------------------------
    290          // master key data
    291          //-----------------------------------------------------------------------------
    292          void ZDSecMgrMasterKeyInit( void );
    293          
    294          //-----------------------------------------------------------------------------
    295          // address management
    296          //-----------------------------------------------------------------------------
    297          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    298          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    299          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    300          
    301          //-----------------------------------------------------------------------------
    302          // MASTER key data
    303          //-----------------------------------------------------------------------------
    304          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    305          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    306          
    307          //-----------------------------------------------------------------------------
    308          // entry data
    309          //-----------------------------------------------------------------------------
    310          void ZDSecMgrEntryInit(uint8 state);
    311          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    312          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    313          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    314          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    315          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    316          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    318          void ZDSecMgrApsLinkKeyInit(void);
    319          #if defined NV_RESTORE
    320          static void ZDSecMgrWriteNV(void);
    321          static void ZDSecMgrRestoreFromNV(void);
    322          #endif
    323          
    324          //-----------------------------------------------------------------------------
    325          // control data
    326          //-----------------------------------------------------------------------------
    327          void ZDSecMgrCtrlInit( void );
    328          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    329          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    330          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    331                                ZDSecMgrEntry_t*  entry,
    332                                ZDSecMgrCtrl_t*   ctrl );
    333          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    334          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    335          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    336                                       ZDSecMgrEntry_t*  entry );
    337          
    338          //-----------------------------------------------------------------------------
    339          // key support
    340          //-----------------------------------------------------------------------------
    341          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    342          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    343                                       uint8*  initExtAddr,
    344                                       uint16  partNwkAddr,
    345                                       uint8*  partExtAddr,
    346                                       uint8** key,
    347                                       uint8*  keyType );
    348          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    349          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    350          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    351          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    352          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    353          
    354          //-----------------------------------------------------------------------------
    355          // device entry
    356          //-----------------------------------------------------------------------------
    357          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    358          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    359          
    360          //-----------------------------------------------------------------------------
    361          // device control
    362          //-----------------------------------------------------------------------------
    363          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    364          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    365          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    366          
    367          //-----------------------------------------------------------------------------
    368          // device management
    369          //-----------------------------------------------------------------------------
    370          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    371          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    372          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    373          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    379          
    380          //-----------------------------------------------------------------------------
    381          // association management
    382          //-----------------------------------------------------------------------------
    383          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    384          
    385          //-----------------------------------------------------------------------------
    386          // authentication management
    387          //-----------------------------------------------------------------------------
    388          void ZDSecMgrAuthInitiate( uint8* responder );
    389          void ZDSecMgrAuthNwkKey( void );
    390          
    391          //-----------------------------------------------------------------------------
    392          // APSME function
    393          //-----------------------------------------------------------------------------
    394          void APSME_TCLinkKeyInit( uint8 setDefault );
    395          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    396          
    397          /******************************************************************************
    398           * @fn          ZDSecMgrMasterKeyInit                     ]
    399           *
    400           * @brief       Initialize master key data in NV
    401           *
    402           * @param       none
    403           *
    404           * @return      none
    405           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    406          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    407          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    408            uint16 index;
    409            ZDSecMgrMasterKeyData_t   masterKeyData;
    410          
    411            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   74FE         MOV       A,#-0x2
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    412          
    413            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000016                ; Setup parameters for call to function osal_memset
   \   000016   7C10         MOV       R4,#0x10
   \   000018   7D00         MOV       R5,#0x0
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   AA82         MOV       R2,DPL
   \   000023   AB83         MOV       R3,DPH
   \   000025   12....       LCALL     ?Subroutine40 & 0xFFFF
    414          
    415            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    416            {
    417              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index),
    418                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \                     ??CrossCallReturnLabel_48:
   \   000028                ; Setup parameters for call to function osal_nv_item_init
   \   000028   A8..         MOV       R0,?XSP + 0
   \   00002A   A9..         MOV       R1,?XSP + 1
   \   00002C   88..         MOV       ?V0,R0
   \   00002E   89..         MOV       ?V1,R1
   \   000030   78..         MOV       R0,#?V0
   \   000032   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000035   7C12         MOV       R4,#0x12
   \   000037   7D00         MOV       R5,#0x0
   \   000039   EE           MOV       A,R6
   \   00003A   2401         ADD       A,#0x1
   \   00003C   FA           MOV       R2,A
   \   00003D   EF           MOV       A,R7
   \   00003E   3403         ADDC      A,#0x3
   \   000040   FB           MOV       R3,A
   \   000041   12....       LCALL     ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   \   000047   E9           MOV       A,R1
   \   000048   7021         JNZ       ??ZDSecMgrMasterKeyInit_0
    419              {
    420                // the item already exists in NV just needs to be set to default values
    421                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    422                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   00004A                ; Setup parameters for call to function osal_nv_write
   \   00004A   78..         MOV       R0,#?V0
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   75..12       MOV       ?V0,#0x12
   \   000052   75..00       MOV       ?V1,#0x0
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   7C00         MOV       R4,#0x0
   \   00005C   7D00         MOV       R5,#0x0
   \   00005E   EE           MOV       A,R6
   \   00005F   2401         ADD       A,#0x1
   \   000061   FA           MOV       R2,A
   \   000062   EF           MOV       A,R7
   \   000063   3403         ADDC      A,#0x3
   \   000065   12....       LCALL     ??Subroutine107_0 & 0xFFFF
    423              }
    424            }
   \                     ??CrossCallReturnLabel_153:
   \   000068   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00006B   0E           INC       R6
   \   00006C   EE           MOV       A,R6
   \   00006D   7001         JNZ       ??ZDSecMgrMasterKeyInit_1
   \   00006F   0F           INC       R7
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000070   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000073   40B3         JC        ??CrossCallReturnLabel_48
    425          }
   \   000075   7412         MOV       A,#0x12
   \   000077   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine108_0
   \   000001                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine119_0
   \   000003                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   C3           CLR       C
   \   000001   9403         SUBB      A,#0x3
   \   000003   EF           MOV       A,R7
   \   000004   9400         SUBB      A,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   000003   7E00         MOV       R6,#0x0
   \   000005   7F00         MOV       R7,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET
    426          
    427          /******************************************************************************
    428           * @fn          ZDSecMgrAddrStore
    429           *
    430           * @brief       Store device addresses.
    431           *
    432           * @param       nwkAddr - [in] NWK address
    433           * @param       extAddr - [in] EXT address
    434           * @param       ami     - [out] Address Manager index
    435           *
    436           * @return      ZStatus_t
    437           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    438          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    439          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    440            ZStatus_t      status;
    441            AddrMgrEntry_t entry;
    442          
    443          
    444            // add entry
    445            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    446            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine29 & 0xFFFF
    447            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_38:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   AA82         MOV       R2,DPL
   \   00001F   AB83         MOV       R3,DPH
   \   000021   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV       A,#0x16
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine46 & 0xFFFF
    448          
    449            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_61:
   \   00002C   700A         JNZ       ??ZDSecMgrAddrStore_0
    450            {
    451              // return successful results
    452              *ami   = entry.index;
   \   00002E   740B         MOV       A,#0xb
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   12....       LCALL     ?Subroutine15 & 0xFFFF
    453              status = ZSuccess;
    454            }
   \                     ??CrossCallReturnLabel_141:
   \   000036   8008         SJMP      ??CrossCallReturnLabel_41
    455            else
    456            {
    457              // return failed results
    458              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000038   740B         MOV       A,#0xb
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine31 & 0xFFFF
    459              status = ZNwkUnknownDevice;
    460            }
    461          
    462            return status;
   \                     ??CrossCallReturnLabel_41:
   \   000040   02....       LJMP      ?Subroutine8 & 0xFFFF
    463          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004                REQUIRE ??Subroutine102_0
   \   000004                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   F9           MOV       R1,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005                REQUIRE ??Subroutine103_0
   \   000005                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   7900         MOV       R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000003   FE           MOV       R6,A
   \   000004   E9           MOV       A,R1
   \   000005   FF           MOV       R7,A
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006   12....       LCALL     ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   AA..         MOV       R2,?XSP + 0
   \   000002   AB..         MOV       R3,?XSP + 1
   \   000004                REQUIRE ??Subroutine104_0
   \   000004                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000003   E9           MOV       A,R1
   \   000004   6401         XRL       A,#0x1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000003   8E82         MOV       DPL,R6
   \   000005   8F83         MOV       DPH,R7
   \   000007   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   00000A   79C8         MOV       R1,#-0x38
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005   7403         MOV       A,#0x3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   740D         MOV       A,#0xd
   \   000002   02....       LJMP      ??Subroutine126_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   000003   E8           MOV       A,R0
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine127_0
   \   000003                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET
    464          
    465          /******************************************************************************
    466           * @fn          ZDSecMgrExtAddrStore
    467           *
    468           * @brief       Store EXT address.
    469           *
    470           * @param       extAddr - [in] EXT address
    471           * @param       ami     - [out] Address Manager index
    472           *
    473           * @return      ZStatus_t
    474           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    475          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    476          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    477            ZStatus_t      status;
    478            AddrMgrEntry_t entry;
    479          
    480          
    481            // add entry
    482            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    483            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine29 & 0xFFFF
    484            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_39:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   AA82         MOV       R2,DPL
   \   00001F   AB83         MOV       R3,DPH
   \   000021   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV       A,#0x16
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine46 & 0xFFFF
    485          
    486            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_62:
   \   00002C   700A         JNZ       ??ZDSecMgrExtAddrStore_0
    487            {
    488              // return successful results
    489              *ami   = entry.index;
   \   00002E   740B         MOV       A,#0xb
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   12....       LCALL     ?Subroutine15 & 0xFFFF
    490              status = ZSuccess;
    491            }
   \                     ??CrossCallReturnLabel_142:
   \   000036   8008         SJMP      ??CrossCallReturnLabel_42
    492            else
    493            {
    494              // return failed results
    495              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000038   740B         MOV       A,#0xb
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine31 & 0xFFFF
    496              status = ZNwkUnknownDevice;
    497            }
    498          
    499            return status;
   \                     ??CrossCallReturnLabel_42:
   \   000040   80..         SJMP      ?Subroutine8
    500          }
    501          
    502          /******************************************************************************
    503           * @fn          ZDSecMgrExtAddrLookup
    504           *
    505           * @brief       Lookup index for specified EXT address.
    506           *
    507           * @param       extAddr - [in] EXT address
    508           * @param       ami     - [out] Address Manager index
    509           *
    510           * @return      ZStatus_t
    511           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    512          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    513          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    514            ZStatus_t      status;
    515            AddrMgrEntry_t entry;
    516          
    517          
    518            // lookup entry
    519            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    520            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV       A,R2
   \   000018   FC           MOV       R4,A
   \   000019   EB           MOV       A,R3
   \   00001A   FD           MOV       R5,A
   \   00001B   7403         MOV       A,#0x3
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   AA82         MOV       R2,DPL
   \   000022   AB83         MOV       R3,DPH
   \   000024   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    521          
    522            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV       R2,?XSP + 0
   \   000029   AB..         MOV       R3,?XSP + 1
   \   00002B   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV       A,R1
   \   00002F   6401         XRL       A,#0x1
   \   000031   700A         JNZ       ??ZDSecMgrExtAddrLookup_0
    523            {
    524              // return successful results
    525              *ami   = entry.index;
   \   000033   740B         MOV       A,#0xb
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   12....       LCALL     ?Subroutine15 & 0xFFFF
    526              status = ZSuccess;
    527            }
   \                     ??CrossCallReturnLabel_143:
   \   00003B   8008         SJMP      ??CrossCallReturnLabel_43
    528            else
    529            {
    530              // return failed results
    531              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine31 & 0xFFFF
    532              status = ZNwkUnknownDevice;
    533            }
    534          
    535            return status;
   \                     ??CrossCallReturnLabel_43:
   \   000045                REQUIRE ?Subroutine8
   \   000045                ; // Fall through to label ?Subroutine8
    536          }
    537          
    538          /******************************************************************************
    539           * @fn          ZDSecMgrMasterKeyLookup
    540           *
    541           * @brief       Lookup MASTER key for specified address index.
    542           *
    543           * @param       ami - [in] Address Manager index
    544           * @param       pKeyNvId - [out] MASTER key NV ID
    545           *
    546           * @return      ZStatus_t
    547           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    548          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    549          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
    550            uint16 index;
    551            ZDSecMgrMasterKeyData_t masterKeyData;
    552          
    553          
    554            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   75..00       MOV       ?V1,#0x0
    555            {
    556              // Read entry index of the Master key table from NV
    557              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    558                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000018                ; Setup parameters for call to function osal_nv_read
   \   000018   A8..         MOV       R0,?XSP + 0
   \   00001A   A9..         MOV       R1,?XSP + 1
   \   00001C   88..         MOV       ?V4,R0
   \   00001E   89..         MOV       ?V5,R1
   \   000020   78..         MOV       R0,#?V4
   \   000022   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000025   75..12       MOV       ?V4,#0x12
   \   000028   75..00       MOV       ?V5,#0x0
   \   00002B   78..         MOV       R0,#?V4
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000033   12....       LCALL     ?DEALLOC_XSTACK8
    559          
    560              if ( masterKeyData.ami == ami )
   \   000036   85..82       MOV       DPL,?XSP + 0
   \   000039   85..83       MOV       DPH,?XSP + 1
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   65..         XRL       A,?V2
   \   00003F   7004         JNZ       ??ZDSecMgrMasterKeyLookup_1
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   65..         XRL       A,?V3
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000045   7022         JNZ       ??ZDSecMgrMasterKeyLookup_2
    561              {
    562                // return successful results
    563                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   000047   E5..         MOV       A,?V0
   \   000049   2401         ADD       A,#0x1
   \   00004B   F8           MOV       R0,A
   \   00004C   E5..         MOV       A,?V1
   \   00004E   3403         ADDC      A,#0x3
   \   000050   F9           MOV       R1,A
   \   000051   8E82         MOV       DPL,R6
   \   000053   8F83         MOV       DPH,R7
   \   000055   12....       LCALL     ??Subroutine114_0 & 0xFFFF
    564          
    565                // clear copy of key in RAM
    566                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \                     ??CrossCallReturnLabel_187:
   \   000058                ; Setup parameters for call to function osal_memset
   \   000058   7C12         MOV       R4,#0x12
   \   00005A   7D00         MOV       R5,#0x0
   \   00005C   7900         MOV       R1,#0x0
   \   00005E   AA..         MOV       R2,?XSP + 0
   \   000060   AB..         MOV       R3,?XSP + 1
   \   000062   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    567          
    568                return ZSuccess;
   \   000065   7900         MOV       R1,#0x0
   \   000067   8026         SJMP      ??ZDSecMgrMasterKeyLookup_3
    569              }
    570            }
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000069   05..         INC       ?V0
   \   00006B   E5..         MOV       A,?V0
   \   00006D   7002         JNZ       ??ZDSecMgrMasterKeyLookup_4
   \   00006F   05..         INC       ?V1
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   000071   C3           CLR       C
   \   000072   9403         SUBB      A,#0x3
   \   000074   E5..         MOV       A,?V1
   \   000076   9400         SUBB      A,#0x0
   \   000078   409E         JC        ??ZDSecMgrMasterKeyLookup_0
    571          
    572            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \   00007A   8E82         MOV       DPL,R6
   \   00007C   8F83         MOV       DPH,R7
   \   00007E   E4           CLR       A
   \   00007F   F0           MOVX      @DPTR,A
   \   000080   A3           INC       DPTR
   \   000081   F0           MOVX      @DPTR,A
    573          
    574            // clear copy of key in RAM
    575            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000082                ; Setup parameters for call to function osal_memset
   \   000082   7C12         MOV       R4,#0x12
   \   000084   FD           MOV       R5,A
   \   000085   F9           MOV       R1,A
   \   000086   AA..         MOV       R2,?XSP + 0
   \   000088   AB..         MOV       R3,?XSP + 1
   \   00008A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    576          
    577            return ZNwkUnknownDevice;
   \   00008D   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00008F   7412         MOV       A,#0x12
   \   000091   12....       LCALL     ?DEALLOC_XSTACK8
   \   000094                REQUIRE ?Subroutine2
   \   000094                ; // Fall through to label ?Subroutine2
    578          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   E5..         MOV       A,?V0
   \   000006   2401         ADD       A,#0x1
   \   000008   FA           MOV       R2,A
   \   000009   E5..         MOV       A,?V1
   \   00000B   3403         ADDC      A,#0x3
   \   00000D   FB           MOV       R3,A
   \   00000E   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000011   7404         MOV       A,#0x4
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   22           RET
    579          
    580          /******************************************************************************
    581           * @fn          ZDSecMgrMasterKeyStore
    582           *
    583           * @brief       Store MASTER key for specified address index.
    584           *
    585           * @param       ami - [in] Address Manager index
    586           * @param       key - [in] valid key to store
    587           *
    588           * @return      ZStatus_t
    589           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    590          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    591          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
    592            uint16    index;
    593            ZDSecMgrMasterKeyData_t   masterKeyData;
    594          
    595          
    596            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   75..00       MOV       ?V1,#0x0
    597            {
    598              // Read entry index of the Master key table from NV
    599              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    600                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000018                ; Setup parameters for call to function osal_nv_read
   \   000018   A8..         MOV       R0,?XSP + 0
   \   00001A   A9..         MOV       R1,?XSP + 1
   \   00001C   88..         MOV       ?V4,R0
   \   00001E   89..         MOV       ?V5,R1
   \   000020   78..         MOV       R0,#?V4
   \   000022   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000025   75..12       MOV       ?V4,#0x12
   \   000028   75..00       MOV       ?V5,#0x0
   \   00002B   78..         MOV       R0,#?V4
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000033   12....       LCALL     ?DEALLOC_XSTACK8
    601          
    602              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   000036   85..82       MOV       DPL,?XSP + 0
   \   000039   85..83       MOV       DPH,?XSP + 1
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   64FE         XRL       A,#0xfe
   \   00003F   7003         JNZ       ??ZDSecMgrMasterKeyStore_1
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   F4           CPL       A
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000044   707C         JNZ       ??ZDSecMgrMasterKeyStore_2
    603              {
    604                // store EXT address index
    605                masterKeyData.ami = ami;
   \   000046   85..82       MOV       DPL,?XSP + 0
   \   000049   85..83       MOV       DPH,?XSP + 1
   \   00004C   E5..         MOV       A,?V2
   \   00004E   F0           MOVX      @DPTR,A
   \   00004F   A3           INC       DPTR
   \   000050   E5..         MOV       A,?V3
   \   000052   F0           MOVX      @DPTR,A
    606          
    607                if ( key != NULL )
   \   000053   EE           MOV       A,R6
   \   000054   4F           ORL       A,R7
   \   000055   601D         JZ        ??ZDSecMgrMasterKeyStore_3
    608                {
    609                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   000057                ; Setup parameters for call to function osal_memcpy
   \   000057   8E..         MOV       ?V4,R6
   \   000059   8F..         MOV       ?V5,R7
   \   00005B   75..00       MOV       ?V6,#0x0
   \   00005E   78..         MOV       R0,#?V4
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000063   7C10         MOV       R4,#0x10
   \   000065   7D00         MOV       R5,#0x0
   \   000067   7405         MOV       A,#0x5
   \   000069   12....       LCALL     ?XSTACK_DISP0_8
   \   00006C   12....       LCALL     ?Subroutine75 & 0xFFFF
    610                }
   \                     ??CrossCallReturnLabel_287:
   \   00006F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000072   8012         SJMP      ??ZDSecMgrMasterKeyStore_4
    611                else
    612                {
    613                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   000074                ; Setup parameters for call to function osal_memset
   \   000074   7C10         MOV       R4,#0x10
   \   000076   7D00         MOV       R5,#0x0
   \   000078   7900         MOV       R1,#0x0
   \   00007A   7402         MOV       A,#0x2
   \   00007C   12....       LCALL     ?XSTACK_DISP0_8
   \   00007F   AA82         MOV       R2,DPL
   \   000081   AB83         MOV       R3,DPH
   \   000083   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    614                }
    615          
    616                // set new values in NV
    617                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    618                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000086                ; Setup parameters for call to function osal_nv_write
   \   000086   A8..         MOV       R0,?XSP + 0
   \   000088   A9..         MOV       R1,?XSP + 1
   \   00008A   88..         MOV       ?V2,R0
   \   00008C   89..         MOV       ?V3,R1
   \   00008E   78..         MOV       R0,#?V2
   \   000090   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000093   75..12       MOV       ?V2,#0x12
   \   000096   75..00       MOV       ?V3,#0x0
   \   000099   78..         MOV       R0,#?V2
   \   00009B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009E   7C00         MOV       R4,#0x0
   \   0000A0   7D00         MOV       R5,#0x0
   \   0000A2   E5..         MOV       A,?V0
   \   0000A4   2401         ADD       A,#0x1
   \   0000A6   FA           MOV       R2,A
   \   0000A7   E5..         MOV       A,?V1
   \   0000A9   3403         ADDC      A,#0x3
   \   0000AB   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   0000AE   12....       LCALL     ?DEALLOC_XSTACK8
    619          
    620                // clear copy of key in RAM
    621                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000B1                ; Setup parameters for call to function osal_memset
   \   0000B1   7C12         MOV       R4,#0x12
   \   0000B3   7D00         MOV       R5,#0x0
   \   0000B5   7900         MOV       R1,#0x0
   \   0000B7   AA..         MOV       R2,?XSP + 0
   \   0000B9   AB..         MOV       R3,?XSP + 1
   \   0000BB   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    622          
    623                // return successful results
    624                return ZSuccess;
   \   0000BE   7900         MOV       R1,#0x0
   \   0000C0   8023         SJMP      ??ZDSecMgrMasterKeyStore_5
    625              }
    626            }
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   0000C2   05..         INC       ?V0
   \   0000C4   E5..         MOV       A,?V0
   \   0000C6   7002         JNZ       ??ZDSecMgrMasterKeyStore_6
   \   0000C8   05..         INC       ?V1
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   0000CA   C3           CLR       C
   \   0000CB   9403         SUBB      A,#0x3
   \   0000CD   E5..         MOV       A,?V1
   \   0000CF   9400         SUBB      A,#0x0
   \   0000D1   5003         JNC       $+5
   \   0000D3   02....       LJMP      ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    627          
    628            // clear copy of key in RAM
    629            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000D6                ; Setup parameters for call to function osal_memset
   \   0000D6   7C12         MOV       R4,#0x12
   \   0000D8   7D00         MOV       R5,#0x0
   \   0000DA   7900         MOV       R1,#0x0
   \   0000DC   AA..         MOV       R2,?XSP + 0
   \   0000DE   AB..         MOV       R3,?XSP + 1
   \   0000E0   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    630          
    631            return ZNwkUnknownDevice;
   \   0000E3   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000E5                REQUIRE ?Subroutine3
   \   0000E5                ; // Fall through to label ?Subroutine3
    632          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7412         MOV       A,#0x12
   \   000002                REQUIRE ??Subroutine105_0
   \   000002                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F07         MOV       R7,#0x7
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   AA82         MOV       R2,DPL
   \   000002   AB83         MOV       R3,DPH
   \   000004                REQUIRE ??Subroutine137_0
   \   000004                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET
    633          
    634          /******************************************************************************
    635           * @fn          ZDSecMgrEntryInit
    636           *
    637           * @brief       Initialize entry sub module
    638           *
    639           * @param       state - device initialization state
    640           *
    641           * @return      none
    642           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    643          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    644          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    645            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   00000A   7033         JNZ       ??ZDSecMgrEntryInit_0
    646            {
    647              uint16 index;
    648          
    649              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000C                ; Setup parameters for call to function osal_mem_alloc
   \   00000C   7A0F         MOV       R2,#0xf
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   12....       LCALL     ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000019   F9           MOV       R1,A
   \   00001A   EA           MOV       A,R2
   \   00001B   49           ORL       A,R1
   \   00001C   6021         JZ        ??ZDSecMgrEntryInit_0
    650              {
    651                return;
    652              }
    653          
    654              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00001E   7800         MOV       R0,#0x0
   \   000020   7900         MOV       R1,#0x0
    655              {
    656                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000022   12....       LCALL     ?Subroutine74 & 0xFFFF
    657          
    658                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    659              }
   \                     ??CrossCallReturnLabel_107:
   \   000025   8A82         MOV       DPL,R2
   \   000027   F583         MOV       DPH,A
   \   000029   74FE         MOV       A,#-0x2
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   04           INC       A
   \   00002E   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000031   E4           CLR       A
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \   000034   F0           MOVX      @DPTR,A
   \   000035   08           INC       R0
   \   000036   E8           MOV       A,R0
   \   000037   7001         JNZ       ??ZDSecMgrEntryInit_2
   \   000039   09           INC       R1
   \                     ??ZDSecMgrEntryInit_2:
   \   00003A   12....       LCALL     ?Subroutine37 & 0xFFFF
    660            }
   \                     ??CrossCallReturnLabel_167:
   \   00003D   40E3         JC        ??ZDSecMgrEntryInit_1
    661          
    662          #if defined NV_RESTORE
    663            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    664            {
    665              ZDSecMgrRestoreFromNV();
    666            }
    667          #else
    668            (void)state;
    669          #endif
    670          }
   \                     ??ZDSecMgrEntryInit_0:
   \   00003F   02....       LJMP      ??Subroutine124_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   E8           MOV       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   E9           MOV       A,R1
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   75F005       MOV       B,#0x5
   \   000008   A4           MUL       AB
   \   000009   FA           MOV       R2,A
   \   00000A   ACF0         MOV       R4,B
   \   00000C   75F005       MOV       B,#0x5
   \   00000F   EB           MOV       A,R3
   \   000010   A4           MUL       AB
   \   000011   2C           ADD       A,R4
   \   000012   FB           MOV       R3,A
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX      A,@DPTR
   \   000017   2A           ADD       A,R2
   \   000018   FA           MOV       R2,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   3B           ADDC      A,R3
   \   00001C   FB           MOV       R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   C3           CLR       C
   \   000001                REQUIRE ??Subroutine109_0
   \   000001                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   9403         SUBB      A,#0x3
   \   000002   E9           MOV       A,R1
   \   000003   9400         SUBB      A,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003   49           ORL       A,R1
   \   000004   22           RET
    671          
    672          /******************************************************************************
    673           * @fn          ZDSecMgrEntryLookup
    674           *
    675           * @brief       Lookup entry index using specified NWK address.
    676           *
    677           * @param       nwkAddr - [in] NWK address
    678           * @param       entry   - [out] valid entry
    679           *
    680           * @return      ZStatus_t
    681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    682          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    683          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    684            uint16         index;
    685            AddrMgrEntry_t addrMgrEntry;
    686          
    687            // initialize results
    688            *entry = NULL;
   \   00000E   8C82         MOV       DPL,R4
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine13 & 0xFFFF
    689          
    690            // verify data is available
    691            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_0:
   \   000015   606D         JZ        ??ZDSecMgrEntryLookup_0
    692            {
    693              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV       DPL,?XSP + 0
   \   00001A   85..83       MOV       DPH,?XSP + 1
   \   00001D   7402         MOV       A,#0x2
   \   00001F   F0           MOVX      @DPTR,A
    694              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC       A
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine20 & 0xFFFF
    695          
    696              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_12:
   \   000027   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00002A   E9           MOV       A,R1
   \   00002B   6401         XRL       A,#0x1
   \   00002D   7055         JNZ       ??ZDSecMgrEntryLookup_0
    697              {
    698                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV       R0,#0x0
   \   000031   7900         MOV       R1,#0x0
    699                {
    700                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000033   740B         MOV       A,#0xb
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   E0           MOVX      A,@DPTR
   \   000039   FC           MOV       R4,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   FD           MOV       R5,A
   \   00003D   E8           MOV       A,R0
   \   00003E   FA           MOV       R2,A
   \   00003F   E9           MOV       A,R1
   \   000040   FB           MOV       R3,A
   \   000041   EA           MOV       A,R2
   \   000042   75F005       MOV       B,#0x5
   \   000045   A4           MUL       AB
   \   000046   FA           MOV       R2,A
   \   000047   85F0..       MOV       ?V0,B
   \   00004A   75F005       MOV       B,#0x5
   \   00004D   EB           MOV       A,R3
   \   00004E   A4           MUL       AB
   \   00004F   25..         ADD       A,?V0
   \   000051   FB           MOV       R3,A
   \   000052   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000055   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000058   6C           XRL       A,R4
   \   000059   7003         JNZ       ??ZDSecMgrEntryLookup_2
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6D           XRL       A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   00005E   701A         JNZ       ??ZDSecMgrEntryLookup_3
    701                  {
    702                    // return successful results
    703                    *entry = &ZDSecMgrEntries[index];
   \   000060   E8           MOV       A,R0
   \   000061   75F005       MOV       B,#0x5
   \   000064   A4           MUL       AB
   \   000065   F8           MOV       R0,A
   \   000066   AAF0         MOV       R2,B
   \   000068   75F005       MOV       B,#0x5
   \   00006B   E9           MOV       A,R1
   \   00006C   A4           MUL       AB
   \   00006D   2A           ADD       A,R2
   \   00006E   F9           MOV       R1,A
   \   00006F   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000072   12....       LCALL     ??Subroutine110_0 & 0xFFFF
    704          
    705                    // break from loop
    706                    return ZSuccess;
    707                  }
    708                }
   \                     ??CrossCallReturnLabel_175:
   \   000075   12....       LCALL     ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000078   800C         SJMP      ??ZDSecMgrEntryLookup_4
   \                     ??ZDSecMgrEntryLookup_3:
   \   00007A   08           INC       R0
   \   00007B   E8           MOV       A,R0
   \   00007C   7001         JNZ       ??ZDSecMgrEntryLookup_5
   \   00007E   09           INC       R1
   \                     ??ZDSecMgrEntryLookup_5:
   \   00007F   12....       LCALL     ?Subroutine37 & 0xFFFF
    709              }
    710            }
   \                     ??CrossCallReturnLabel_168:
   \   000082   40AF         JC        ??ZDSecMgrEntryLookup_1
    711          
    712            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   000084   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   000086   02....       LJMP      ?Subroutine8 & 0xFFFF
    713          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL     ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   00000A   49           ORL       A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   F8           MOV       R0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL     ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   F5..         MOV       ?V0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3B           ADDC      A,R3
   \   000007   85..82       MOV       DPL,?V0
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   12....       LCALL     ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   22           RET
    714          
    715          /******************************************************************************
    716           * @fn          ZDSecMgrEntryLookupAMI
    717           *
    718           * @brief       Lookup entry using specified address index
    719           *
    720           * @param       ami   - [in] Address Manager index
    721           * @param       entry - [out] valid entry
    722           *
    723           * @return      ZStatus_t
    724           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    725          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    726          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    727            uint16 index;
    728          
    729            // initialize results
    730            *entry = NULL;
   \   000005   8C82         MOV       DPL,R4
   \   000007   8D83         MOV       DPH,R5
   \   000009   12....       LCALL     ?Subroutine13 & 0xFFFF
    731          
    732            // verify data is available
    733            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_1:
   \   00000C   6053         JZ        ??ZDSecMgrEntryLookupAMI_0
    734            {
    735              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV       R0,#0x0
   \   000010   7900         MOV       R1,#0x0
    736              {
    737                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000012   E8           MOV       A,R0
   \   000013   FE           MOV       R6,A
   \   000014   E9           MOV       A,R1
   \   000015   FF           MOV       R7,A
   \   000016   EE           MOV       A,R6
   \   000017   75F005       MOV       B,#0x5
   \   00001A   A4           MUL       AB
   \   00001B   FE           MOV       R6,A
   \   00001C   85F0..       MOV       ?V0,B
   \   00001F   75F005       MOV       B,#0x5
   \   000022   EF           MOV       A,R7
   \   000023   A4           MUL       AB
   \   000024   25..         ADD       A,?V0
   \   000026   FF           MOV       R7,A
   \   000027   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00002A   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   6A           XRL       A,R2
   \   00002F   7003         JNZ       ??ZDSecMgrEntryLookupAMI_2
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   6B           XRL       A,R3
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000034   7021         JNZ       ??ZDSecMgrEntryLookupAMI_3
    738                {
    739                  // return successful results
    740                  *entry = &ZDSecMgrEntries[index];
   \   000036   E8           MOV       A,R0
   \   000037   75F005       MOV       B,#0x5
   \   00003A   A4           MUL       AB
   \   00003B   AAF0         MOV       R2,B
   \   00003D   75F005       MOV       B,#0x5
   \   000040   E9           MOV       A,R1
   \   000041   A4           MUL       AB
   \   000042   2A           ADD       A,R2
   \   000043   F9           MOV       R1,A
   \   000044   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000047   E0           MOVX      A,@DPTR
   \   000048   2E           ADD       A,R6
   \   000049   F8           MOV       R0,A
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   39           ADDC      A,R1
   \   00004D   F9           MOV       R1,A
   \   00004E   8C82         MOV       DPL,R4
   \   000050   8D83         MOV       DPH,R5
   \   000052   12....       LCALL     ??Subroutine103_0 & 0xFFFF
    741          
    742                  // break from loop
    743                  return ZSuccess;
    744                }
    745              }
   \                     ??CrossCallReturnLabel_145:
   \   000055   800C         SJMP      ??ZDSecMgrEntryLookupAMI_4
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000057   08           INC       R0
   \   000058   E8           MOV       A,R0
   \   000059   7001         JNZ       ??ZDSecMgrEntryLookupAMI_5
   \   00005B   09           INC       R1
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   00005C   12....       LCALL     ?Subroutine37 & 0xFFFF
    746            }
   \                     ??CrossCallReturnLabel_169:
   \   00005F   40B1         JC        ??ZDSecMgrEntryLookupAMI_1
    747          
    748            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000061   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000063   02....       LJMP      ??Subroutine127_0 & 0xFFFF
    749          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2E           ADD       A,R6
   \   000002   F5..         MOV       ?V0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3F           ADDC      A,R7
   \   000007   85..82       MOV       DPL,?V0
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET
    750          
    751          /******************************************************************************
    752           * @fn          ZDSecMgrEntryLookupExt
    753           *
    754           * @brief       Lookup entry index using specified EXT address.
    755           *
    756           * @param       extAddr - [in] EXT address
    757           * @param       entry   - [out] valid entry
    758           *
    759           * @return      ZStatus_t
    760           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    761          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    762          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    763            ZStatus_t status;
    764            uint16    ami;
    765          
    766            // initialize results
    767            *entry = NULL;
   \   00000E   8C82         MOV       DPL,R4
   \   000010   F583         MOV       DPH,A
   \   000012   E4           CLR       A
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   F0           MOVX      @DPTR,A
    768            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV       ?V0,#-0x38
    769          
    770            // lookup address index
    771            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   AC..         MOV       R4,?XSP + 0
   \   00001B   AD..         MOV       R5,?XSP + 1
   \   00001D   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV       A,R1
   \   000021   7010         JNZ       ??ZDSecMgrEntryLookupExt_0
    772            {
    773              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000023                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000023   EE           MOV       A,R6
   \   000024   FC           MOV       R4,A
   \   000025   EF           MOV       A,R7
   \   000026   FD           MOV       R5,A
   \   000027   85..82       MOV       DPL,?XSP + 0
   \   00002A   85..83       MOV       DPH,?XSP + 1
   \   00002D   12....       LCALL     ?Subroutine65 & 0xFFFF
    774            }
   \                     ??CrossCallReturnLabel_91:
   \   000030   E9           MOV       A,R1
   \   000031   F5..         MOV       ?V0,A
    775          
    776            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000033   02....       LJMP      ?Subroutine1 & 0xFFFF
    777          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV       R1,?V0
   \   000002                REQUIRE ??Subroutine125_0
   \   000002                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine126_0
   \   000002                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000003   FB           MOV       R3,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000003   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000006   22           RET
    778          
    779          /******************************************************************************
    780           * @fn          ZDSecMgrEntryLookupExtGetIndex
    781           *
    782           * @brief       Lookup entry index using specified EXT address.
    783           *
    784           * @param       extAddr - [in] EXT address
    785           * @param       entryIndex - [out] valid index to the entry table
    786           *
    787           * @return      ZStatus_t
    788           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    789          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    790          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    791            uint16 ami;
    792            uint16 index;
    793          
    794            // lookup address index
    795            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   7058         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_0
    796            {
    797              // verify data is available
    798              if ( ZDSecMgrEntries != NULL )
   \   000018   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00001B   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00001E   6050         JZ        ??ZDSecMgrEntryLookupExtGetIndex_0
    799              {
    800                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV       R0,#0x0
   \   000022   7900         MOV       R1,#0x0
    801                {
    802                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000024   E8           MOV       A,R0
   \   000025   FA           MOV       R2,A
   \   000026   E9           MOV       A,R1
   \   000027   FB           MOV       R3,A
   \   000028   EA           MOV       A,R2
   \   000029   75F005       MOV       B,#0x5
   \   00002C   A4           MUL       AB
   \   00002D   FA           MOV       R2,A
   \   00002E   ACF0         MOV       R4,B
   \   000030   75F005       MOV       B,#0x5
   \   000033   EB           MOV       A,R3
   \   000034   A4           MUL       AB
   \   000035   2C           ADD       A,R4
   \   000036   FB           MOV       R3,A
   \   000037   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00003A   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00003D   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000040   85..82       MOV       DPL,?XSP + 0
   \   000043   85..83       MOV       DPH,?XSP + 1
   \   000046   E0           MOVX      A,@DPTR
   \   000047   6A           XRL       A,R2
   \   000048   7003         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_2
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   6B           XRL       A,R3
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00004D   7017         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_3
    803                  {
    804                    // return successful results
    805                    *entry = &ZDSecMgrEntries[index];
   \   00004F   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000052   8E82         MOV       DPL,R6
   \   000054   8F83         MOV       DPH,R7
   \   000056   12....       LCALL     ??Subroutine129_0 & 0xFFFF
    806                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_245:
   \   000059   740B         MOV       A,#0xb
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   12....       LCALL     ?Subroutine70 & 0xFFFF
    807          
    808                    // break from loop
    809                    return ZSuccess;
    810                  }
    811                }
   \                     ??CrossCallReturnLabel_99:
   \   000061   12....       LCALL     ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000064   800C         SJMP      ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   000066   08           INC       R0
   \   000067   E8           MOV       A,R0
   \   000068   7001         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_5
   \   00006A   09           INC       R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   00006B   12....       LCALL     ?Subroutine37 & 0xFFFF
    812              }
    813            }
   \                     ??CrossCallReturnLabel_170:
   \   00006E   40B4         JC        ??ZDSecMgrEntryLookupExtGetIndex_1
    814          
    815            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   000070   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000072   02....       LJMP      ??Subroutine125_0 & 0xFFFF
    816          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   FC           MOV       R4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3B           ADDC      A,R3
   \   000006   8C82         MOV       DPL,R4
   \   000008   F583         MOV       DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000003   F583         MOV       DPH,A
   \   000005   8A82         MOV       DPL,R2
   \   000007   22           RET
    817          
    818          /******************************************************************************
    819           * @fn          ZDSecMgrEntryFree
    820           *
    821           * @brief       Free entry.
    822           *
    823           * @param       entry - [in] valid entry
    824           *
    825           * @return      ZStatus_t
    826           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    827          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    828          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    829            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    830          
    831            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   12....       LCALL     ?Subroutine72 & 0xFFFF
    832          
    833            if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_103:
   \   00000C   6040         JZ        ??ZDSecMgrEntryFree_0
    834            {
    835              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000E                ; Setup parameters for call to function osal_memset
   \   00000E   7C18         MOV       R4,#0x18
   \   000010   7D00         MOV       R5,#0x0
   \   000012   7900         MOV       R1,#0x0
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    836          
    837              // Clear the APS Link key in NV
    838              osal_nv_write( entry->keyNvId, 0,
    839                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000017   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00001A                ; Setup parameters for call to function osal_nv_write
   \   00001A   78..         MOV       R0,#?V2
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   75..18       MOV       ?V4,#0x18
   \   000022   75..00       MOV       ?V5,#0x0
   \   000025   78..         MOV       R0,#?V4
   \   000027   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002A   7C00         MOV       R4,#0x0
   \   00002C   7D00         MOV       R5,#0x0
   \   00002E   85..82       MOV       DPL,?V0
   \   000031   85..83       MOV       DPH,?V1
   \   000034   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   000037   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   00003A   12....       LCALL     ?DEALLOC_XSTACK8
    840          
    841              // set entry to invalid Key
    842              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00003D   85..82       MOV       DPL,?V0
   \   000040   85..83       MOV       DPH,?V1
   \   000043   E4           CLR       A
   \   000044   F0           MOVX      @DPTR,A
   \   000045   A3           INC       DPTR
   \   000046   F0           MOVX      @DPTR,A
    843          
    844              osal_mem_free(pApsLinkKey);
   \   000047                ; Setup parameters for call to function osal_mem_free
   \   000047   AA..         MOV       R2,?V2
   \   000049   AB..         MOV       R3,?V3
   \   00004B   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    845            }
    846          
    847            // marking the entry as INVALID_NODE_ADDR
    848            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   74FE         MOV       A,#-0x2
   \   000054   F0           MOVX      @DPTR,A
   \   000055   A3           INC       DPTR
   \   000056   04           INC       A
   \   000057   F0           MOVX      @DPTR,A
    849          }
   \   000058   02....       LJMP      ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   EE           MOV       A,R6
   \   000001   2402         ADD       A,#0x2
   \   000003   F8           MOV       R0,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   88..         MOV       ?V0,R0
   \   000008   F5..         MOV       ?V1,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   7A18         MOV       R2,#0x18
   \   000002   7B00         MOV       R3,#0x0
   \   000004   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000007   8A..         MOV       ?V2,R2
   \   000009   8B..         MOV       ?V3,R3
   \   00000B   EA           MOV       A,R2
   \   00000C   4B           ORL       A,R3
   \   00000D   22           RET
    850          
    851          /******************************************************************************
    852           * @fn          ZDSecMgrEntryNew
    853           *
    854           * @brief       Get a new entry.
    855           *
    856           * @param       entry - [out] valid entry
    857           *
    858           * @return      ZStatus_t
    859           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    860          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    861          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    862            uint16 index;
    863          
    864            // initialize results
    865            *entry = NULL;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   12....       LCALL     ?Subroutine13 & 0xFFFF
    866          
    867            // verify data is available
    868            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_2:
   \   00000C   6064         JZ        ??ZDSecMgrEntryNew_0
    869            {
    870              // find available entry
    871              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV       R0,#0x0
   \   000010   7900         MOV       R1,#0x0
    872              {
    873                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000012   E8           MOV       A,R0
   \   000013   FC           MOV       R4,A
   \   000014   E9           MOV       A,R1
   \   000015   FD           MOV       R5,A
   \   000016   EC           MOV       A,R4
   \   000017   75F005       MOV       B,#0x5
   \   00001A   A4           MUL       AB
   \   00001B   FC           MOV       R4,A
   \   00001C   AEF0         MOV       R6,B
   \   00001E   75F005       MOV       B,#0x5
   \   000021   ED           MOV       A,R5
   \   000022   A4           MUL       AB
   \   000023   2E           ADD       A,R6
   \   000024   FD           MOV       R5,A
   \   000025   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000028   E0           MOVX      A,@DPTR
   \   000029   2C           ADD       A,R4
   \   00002A   FE           MOV       R6,A
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   3D           ADDC      A,R5
   \   00002E   8E82         MOV       DPL,R6
   \   000030   F583         MOV       DPH,A
   \   000032   E0           MOVX      A,@DPTR
   \   000033   64FE         XRL       A,#0xfe
   \   000035   7003         JNZ       ??ZDSecMgrEntryNew_2
   \   000037   A3           INC       DPTR
   \   000038   E0           MOVX      A,@DPTR
   \   000039   F4           CPL       A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003A   702C         JNZ       ??ZDSecMgrEntryNew_3
    874                {
    875                  // return successful result
    876                  *entry = &ZDSecMgrEntries[index];
   \   00003C   E8           MOV       A,R0
   \   00003D   75F005       MOV       B,#0x5
   \   000040   A4           MUL       AB
   \   000041   F8           MOV       R0,A
   \   000042   ACF0         MOV       R4,B
   \   000044   75F005       MOV       B,#0x5
   \   000047   E9           MOV       A,R1
   \   000048   A4           MUL       AB
   \   000049   2C           ADD       A,R4
   \   00004A   F9           MOV       R1,A
   \   00004B   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00004E   E0           MOVX      A,@DPTR
   \   00004F   28           ADD       A,R0
   \   000050   A3           INC       DPTR
   \   000051   E0           MOVX      A,@DPTR
   \   000052   39           ADDC      A,R1
   \   000053   FD           MOV       R5,A
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   EE           MOV       A,R6
   \   000059   F0           MOVX      @DPTR,A
   \   00005A   A3           INC       DPTR
   \   00005B   ED           MOV       A,R5
   \   00005C   F0           MOVX      @DPTR,A
    877          
    878                  // Set the authentication option to default
    879                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00005D   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000060   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000063   E4           CLR       A
   \   000064   F0           MOVX      @DPTR,A
    880          
    881                  // break from loop
    882                  return ZSuccess;
   \   000065   F9           MOV       R1,A
   \   000066   800C         SJMP      ??ZDSecMgrEntryNew_4
    883                }
    884              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000068   08           INC       R0
   \   000069   E8           MOV       A,R0
   \   00006A   7001         JNZ       ??ZDSecMgrEntryNew_5
   \   00006C   09           INC       R1
   \                     ??ZDSecMgrEntryNew_5:
   \   00006D   12....       LCALL     ?Subroutine37 & 0xFFFF
    885            }
   \                     ??CrossCallReturnLabel_171:
   \   000070   40A0         JC        ??ZDSecMgrEntryNew_1
    886          
    887            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   000072   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   000074   02....       LJMP      ??Subroutine127_0 & 0xFFFF
    888          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   8A82         MOV       DPL,R2
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   22           RET
    889          
    890          /******************************************************************************
    891           * @fn          ZDSecMgrCtrlInit
    892           *
    893           * @brief       Initialize control sub module
    894           *
    895           * @param       none
    896           *
    897           * @return      none
    898           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    899          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    900          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    901            uint16 size;
    902            uint16 index;
    903          
    904            // allocate entry data
    905            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    906          
    907            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV       R2,#0x15
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL     ??Subroutine129_0 & 0xFFFF
    908          
    909            // initialize data
    910            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_246:
   \   000011   F9           MOV       R1,A
   \   000012   EA           MOV       A,R2
   \   000013   49           ORL       A,R1
   \   000014   602E         JZ        ??ZDSecMgrCtrlInit_0
    911            {
    912              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000016   7800         MOV       R0,#0x0
   \   000018   7900         MOV       R1,#0x0
    913              {
    914                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   00001A   E8           MOV       A,R0
   \   00001B   FA           MOV       R2,A
   \   00001C   E9           MOV       A,R1
   \   00001D   FB           MOV       R3,A
   \   00001E   EA           MOV       A,R2
   \   00001F   75F007       MOV       B,#0x7
   \   000022   A4           MUL       AB
   \   000023   FA           MOV       R2,A
   \   000024   ACF0         MOV       R4,B
   \   000026   75F007       MOV       B,#0x7
   \   000029   EB           MOV       A,R3
   \   00002A   A4           MUL       AB
   \   00002B   2C           ADD       A,R4
   \   00002C   FB           MOV       R3,A
   \   00002D   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000030   12....       LCALL     ?Subroutine62 & 0xFFFF
    915              }
   \                     ??CrossCallReturnLabel_88:
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   E4           CLR       A
   \   000039   F0           MOVX      @DPTR,A
   \   00003A   08           INC       R0
   \   00003B   E8           MOV       A,R0
   \   00003C   7001         JNZ       ??ZDSecMgrCtrlInit_2
   \   00003E   09           INC       R1
   \                     ??ZDSecMgrCtrlInit_2:
   \   00003F   12....       LCALL     ?Subroutine37 & 0xFFFF
    916            }
   \                     ??CrossCallReturnLabel_172:
   \   000042   40D6         JC        ??ZDSecMgrCtrlInit_1
    917          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   000044   02....       LJMP      ??Subroutine124_0 & 0xFFFF
    918          
    919          /******************************************************************************
    920           * @fn          ZDSecMgrCtrlRelease
    921           *
    922           * @brief       Release control data.
    923           *
    924           * @param       ctrl - [in] valid control data
    925           *
    926           * @return      none
    927           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    928          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    929          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    930            // should always be enough entry control data
    931            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
    932          }
   \   00000F   02....       LJMP      ??Subroutine124_0 & 0xFFFF
    933          
    934          /******************************************************************************
    935           * @fn          ZDSecMgrCtrlLookup
    936           *
    937           * @brief       Lookup control data.
    938           *
    939           * @param       entry - [in] valid entry data
    940           * @param       ctrl  - [out] control data - NULL if not found
    941           *
    942           * @return      none
    943           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    944          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    945          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    946            uint16 index;
    947          
    948            // initialize search results
    949            *ctrl = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    950          
    951            // verify data is available
    952            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000017   6065         JZ        ??ZDSecMgrCtrlLookup_0
    953            {
    954              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV       R0,#0x0
   \   00001B   7900         MOV       R1,#0x0
    955              {
    956                // make sure control data is in use
    957                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00001D   E8           MOV       A,R0
   \   00001E   FA           MOV       R2,A
   \   00001F   E9           MOV       A,R1
   \   000020   FB           MOV       R3,A
   \   000021   EA           MOV       A,R2
   \   000022   75F007       MOV       B,#0x7
   \   000025   A4           MUL       AB
   \   000026   FA           MOV       R2,A
   \   000027   85F0..       MOV       ?V0,B
   \   00002A   75F007       MOV       B,#0x7
   \   00002D   EB           MOV       A,R3
   \   00002E   A4           MUL       AB
   \   00002F   25..         ADD       A,?V0
   \   000031   FB           MOV       R3,A
   \   000032   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000035   12....       LCALL     ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   6034         JZ        ??ZDSecMgrCtrlLookup_2
    958                {
    959                  // check for entry match
    960                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000040   E8           MOV       A,R0
   \   000041   FA           MOV       R2,A
   \   000042   E9           MOV       A,R1
   \   000043   FB           MOV       R3,A
   \   000044   EA           MOV       A,R2
   \   000045   75F007       MOV       B,#0x7
   \   000048   A4           MUL       AB
   \   000049   FA           MOV       R2,A
   \   00004A   85F0..       MOV       ?V0,B
   \   00004D   75F007       MOV       B,#0x7
   \   000050   EB           MOV       A,R3
   \   000051   A4           MUL       AB
   \   000052   25..         ADD       A,?V0
   \   000054   FB           MOV       R3,A
   \   000055   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000058   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   EE           MOV       A,R6
   \   000060   6A           XRL       A,R2
   \   000061   7002         JNZ       ??ZDSecMgrCtrlLookup_3
   \   000063   EF           MOV       A,R7
   \   000064   6B           XRL       A,R3
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000065   700D         JNZ       ??ZDSecMgrCtrlLookup_2
    961                  {
    962                    // return this control data
    963                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000067   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   00006A   F9           MOV       R1,A
   \   00006B   8C82         MOV       DPL,R4
   \   00006D   8D83         MOV       DPH,R5
   \   00006F   12....       LCALL     ??Subroutine114_0 & 0xFFFF
    964          
    965                    // break from loop
    966                    return;
   \                     ??CrossCallReturnLabel_188:
   \   000072   800A         SJMP      ??ZDSecMgrCtrlLookup_0
    967                  }
    968                }
    969              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000074   08           INC       R0
   \   000075   E8           MOV       A,R0
   \   000076   7001         JNZ       ??ZDSecMgrCtrlLookup_4
   \   000078   09           INC       R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000079   12....       LCALL     ?Subroutine37 & 0xFFFF
    970            }
   \                     ??CrossCallReturnLabel_173:
   \   00007C   409F         JC        ??ZDSecMgrCtrlLookup_1
    971          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   00007E   02....       LJMP      ??Subroutine127_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E8           MOV       A,R0
   \   000001   75F007       MOV       B,#0x7
   \   000004   A4           MUL       AB
   \   000005   F8           MOV       R0,A
   \   000006   AAF0         MOV       R2,B
   \   000008   75F007       MOV       B,#0x7
   \   00000B   E9           MOV       A,R1
   \   00000C   A4           MUL       AB
   \   00000D   2A           ADD       A,R2
   \   00000E   F9           MOV       R1,A
   \   00000F   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000012                REQUIRE ??Subroutine110_0
   \   000012                ; // Fall through to label ??Subroutine110_0
    972          
    973          /******************************************************************************
    974           * @fn          ZDSecMgrCtrlSet
    975           *
    976           * @brief       Set control data.
    977           *
    978           * @param       device - [in] valid device data
    979           * @param       entry  - [in] valid entry data
    980           * @param       ctrl   - [in] valid control data
    981           *
    982           * @return      none
    983           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    984          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
    985                                ZDSecMgrEntry_t*  entry,
    986                                ZDSecMgrCtrl_t*   ctrl )
    987          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV       A,#0x9
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   12....       LCALL     ??Subroutine144_0 & 0xFFFF
    988            // set control date
    989            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_318:
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   8B83         MOV       DPH,R3
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   FF           MOV       R7,A
   \   00001A   8882         MOV       DPL,R0
   \   00001C   8983         MOV       DPH,R1
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   EE           MOV       A,R6
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   EF           MOV       A,R7
   \   000024   12....       LCALL     ?Subroutine27 & 0xFFFF
    990            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_34:
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   8882         MOV       DPL,R0
   \   00002E   8983         MOV       DPH,R1
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   12....       LCALL     ?Subroutine83 & 0xFFFF
    991            ctrl->entry      = entry;
   \                     ??CrossCallReturnLabel_121:
   \   000037   EC           MOV       A,R4
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   ED           MOV       A,R5
   \   00003B   12....       LCALL     ?Subroutine28 & 0xFFFF
    992            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_36:
   \   00003E   7401         MOV       A,#0x1
   \   000040   12....       LCALL     ?Subroutine28 & 0xFFFF
    993            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_37:
   \   000043   A3           INC       DPTR
   \   000044   E4           CLR       A
   \   000045   12....       LCALL     ?Subroutine24 & 0xFFFF
    994          
    995            // set device pointer
    996            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_27:
   \   000048   A3           INC       DPTR
   \   000049   12....       LCALL     ??Subroutine114_0 & 0xFFFF
    997          }
   \                     ??CrossCallReturnLabel_189:
   \   00004C   02....       LJMP      ??Subroutine127_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000003   22           RET
    998          
    999          /******************************************************************************
   1000           * @fn          ZDSecMgrCtrlAdd
   1001           *
   1002           * @brief       Add control data.
   1003           *
   1004           * @param       device - [in] valid device data
   1005           * @param       entry  - [in] valid entry data
   1006           *
   1007           * @return      ZStatus_t
   1008           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1009          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1010          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1011            uint16 index;
   1012          
   1013            // verify data is available
   1014            if ( ZDSecMgrCtrlData != NULL )
   \   000005   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000008   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00000B   605B         JZ        ??ZDSecMgrCtrlAdd_0
   1015            {
   1016              // look for an empty slot
   1017              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00000D   7800         MOV       R0,#0x0
   \   00000F   7900         MOV       R1,#0x0
   1018              {
   1019                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000011   E8           MOV       A,R0
   \   000012   FE           MOV       R6,A
   \   000013   E9           MOV       A,R1
   \   000014   FF           MOV       R7,A
   \   000015   EE           MOV       A,R6
   \   000016   75F007       MOV       B,#0x7
   \   000019   A4           MUL       AB
   \   00001A   FE           MOV       R6,A
   \   00001B   85F0..       MOV       ?V0,B
   \   00001E   75F007       MOV       B,#0x7
   \   000021   EF           MOV       A,R7
   \   000022   A4           MUL       AB
   \   000023   25..         ADD       A,?V0
   \   000025   FF           MOV       R7,A
   \   000026   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000029   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   702A         JNZ       ??ZDSecMgrCtrlAdd_2
   1020                {
   1021                  // return successful results
   1022                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000034                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000034   E8           MOV       A,R0
   \   000035   75F007       MOV       B,#0x7
   \   000038   A4           MUL       AB
   \   000039   F8           MOV       R0,A
   \   00003A   AEF0         MOV       R6,B
   \   00003C   75F007       MOV       B,#0x7
   \   00003F   E9           MOV       A,R1
   \   000040   A4           MUL       AB
   \   000041   2E           ADD       A,R6
   \   000042   F9           MOV       R1,A
   \   000043   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000046   E0           MOVX      A,@DPTR
   \   000047   28           ADD       A,R0
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   39           ADDC      A,R1
   \   00004B   F5..         MOV       ?V1,A
   \   00004D   78..         MOV       R0,#?V0
   \   00004F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000052   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?DEALLOC_XSTACK8
   1023          
   1024                  // break from loop
   1025                  return ZSuccess;
   \   00005A   7900         MOV       R1,#0x0
   \   00005C   800C         SJMP      ??ZDSecMgrCtrlAdd_3
   1026                }
   1027              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00005E   08           INC       R0
   \   00005F   E8           MOV       A,R0
   \   000060   7001         JNZ       ??ZDSecMgrCtrlAdd_4
   \   000062   09           INC       R1
   \                     ??ZDSecMgrCtrlAdd_4:
   \   000063   12....       LCALL     ?Subroutine37 & 0xFFFF
   1028            }
   \                     ??CrossCallReturnLabel_174:
   \   000066   40A9         JC        ??ZDSecMgrCtrlAdd_1
   1029          
   1030            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000068   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrCtrlAdd_3:
   \   00006A   02....       LJMP      ??Subroutine119_0 & 0xFFFF
   1031          }
   1032          
   1033          /******************************************************************************
   1034           * @fn          ZDSecMgrCtrlTerm
   1035           *
   1036           * @brief       Terminate device control.
   1037           *
   1038           * @param       entry - [in] valid entry data
   1039           *
   1040           * @return      none
   1041           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1042          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1043          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   1044            ZDSecMgrCtrl_t* ctrl;
   1045          
   1046            // remove device from control data
   1047            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   AC..         MOV       R4,?XSP + 0
   \   00000B   AD..         MOV       R5,?XSP + 1
   \   00000D   12....       LCALL     ??Subroutine134_0 & 0xFFFF
   1048          
   1049            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_271:
   \   000010   6005         JZ        ??ZDSecMgrCtrlTerm_0
   1050            {
   1051              ZDSecMgrCtrlRelease ( ctrl );
   \   000012   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   000015   E4           CLR       A
   \   000016   F0           MOVX      @DPTR,A
   1052            }
   1053          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000017   7402         MOV       A,#0x2
   \   000019   80..         SJMP      ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine124_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   \   000003                REQUIRE ??Subroutine135_0
   \   000003                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine136_0
   \   000006                ; // Fall through to label ??Subroutine136_0
   1054          
   1055          /******************************************************************************
   1056           * @fn          ZDSecMgrCtrlReset
   1057           *
   1058           * @brief       Reset control data.
   1059           *
   1060           * @param       device - [in] valid device data
   1061           * @param       entry  - [in] valid entry data
   1062           *
   1063           * @return      ZStatus_t
   1064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1065          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1066          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1067            ZStatus_t       status;
   1068            ZDSecMgrCtrl_t* ctrl;
   1069          
   1070            // initialize results
   1071            status = ZNwkUnknownDevice;
   1072          
   1073            // look for a match for the entry
   1074            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   12....       LCALL     ?Subroutine43 & 0xFFFF
   1075          
   1076            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_269:
   \   00001C   601D         JZ        ??ZDSecMgrCtrlReset_0
   1077            {
   1078              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000027   EE           MOV       A,R6
   \   000028   FC           MOV       R4,A
   \   000029   EF           MOV       A,R7
   \   00002A   FD           MOV       R5,A
   \   00002B   AA..         MOV       R2,?V0
   \   00002D   AB..         MOV       R3,?V1
   \   00002F   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?DEALLOC_XSTACK8
   1079          
   1080              status = ZSuccess;
   \   000037   7900         MOV       R1,#0x0
   \   000039   800D         SJMP      ??ZDSecMgrCtrlReset_1
   1081            }
   1082            else
   1083            {
   1084              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00003B                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00003B   EE           MOV       A,R6
   \   00003C   FC           MOV       R4,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FD           MOV       R5,A
   \   00003F   AA..         MOV       R2,?V0
   \   000041   AB..         MOV       R3,?V1
   \   000043   12....       LCALL     `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   000046   E9           MOV       A,R1
   \   000047   F9           MOV       R1,A
   1085            }
   1086          
   1087            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   000048   02....       LJMP      ?Subroutine0 & 0xFFFF
   1088          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine118_0
   \   000002                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine134_0
   \   000001                ; // Fall through to label ??Subroutine134_0
   1089          
   1090          /******************************************************************************
   1091           * @fn          ZDSecMgrMasterKeyLoad
   1092           *
   1093           * @brief       Load the MASTER key for device with specified EXT
   1094           *              address.
   1095           *
   1096           * @param       extAddr - [in] EXT address of device
   1097           * @param       key     - [in] MASTER key shared with device
   1098           *
   1099           * @return      ZStatus_t
   1100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1101          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1102          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V0,R4
   \   00000C   8D..         MOV       ?V1,R5
   1103            ZStatus_t status;
   1104            uint16 ami;
   1105            uint16 keyNvId;
   1106          
   1107            // set status based on policy
   1108            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   FE           MOV       R6,A
   1109          
   1110            if ( status == ZSuccess )
   \   000017   7037         JNZ       ??ZDSecMgrMasterKeyLoad_0
   1111            {
   1112              // get the address NV ID
   1113              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000019   7402         MOV       A,#0x2
   \   00001B   12....       LCALL     ?XSTACK_DISP102_8
   \   00001E   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000021   7024         JNZ       ??ZDSecMgrMasterKeyLoad_1
   1114              {
   1115                // overwrite old key in NV
   1116                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1117                               SEC_KEY_LEN, key );
   \   000023                ; Setup parameters for call to function osal_nv_write
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000028   75..10       MOV       ?V0,#0x10
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   7C02         MOV       R4,#0x2
   \   000035   7D00         MOV       R5,#0x0
   \   000037   7406         MOV       A,#0x6
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   12....       LCALL     ?Subroutine101 & 0xFFFF
   1118              }
   \                     ??CrossCallReturnLabel_313:
   \   00003F   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000042   12....       LCALL     ?DEALLOC_XSTACK8
   \   000045   8009         SJMP      ??ZDSecMgrMasterKeyLoad_0
   1119              else
   1120              {
   1121                // store new key -- NULL will zero key
   1122                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000047                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000047   AC..         MOV       R4,?V0
   \   000049   AD..         MOV       R5,?V1
   \   00004B   12....       LCALL     ?Subroutine66 & 0xFFFF
   1123              }
   1124            }
   \                     ??CrossCallReturnLabel_93:
   \   00004E   E9           MOV       A,R1
   \   00004F   FE           MOV       R6,A
   1125          
   1126            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000050   EE           MOV       A,R6
   \   000051   F9           MOV       R1,A
   \   000052                REQUIRE ?Subroutine7
   \   000052                ; // Fall through to label ?Subroutine7
   1127          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine120_0
   \   000006                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000006   E9           MOV       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL     ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine141_0
   \   000006                ; // Fall through to label ??Subroutine141_0
   1128          
   1129          /******************************************************************************
   1130           * @fn          ZDSecMgrAppKeyGet
   1131           *
   1132           * @brief       get an APP key - option APP(MASTER or LINK) key
   1133           *
   1134           * @param       initNwkAddr - [in] NWK address of initiator device
   1135           * @param       initExtAddr - [in] EXT address of initiator device
   1136           * @param       partNwkAddr - [in] NWK address of partner device
   1137           * @param       partExtAddr - [in] EXT address of partner device
   1138           * @param       key         - [out] APP(MASTER or LINK) key
   1139           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1140           *
   1141           * @return      ZStatus_t
   1142           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1143          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1144                                                           // to KEY_TYPE_APP_LINK since
   1145                                                           // only specific requirement
   1146                                                           // right now comes from SE profile
   1147          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1148          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1149                                       uint8*  initExtAddr,
   1150                                       uint16  partNwkAddr,
   1151                                       uint8*  partExtAddr,
   1152                                       uint8** key,
   1153                                       uint8*  keyType )
   1154          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1155            // Intentionally unreferenced parameters
   1156            (void)initNwkAddr;
   1157            (void)initExtAddr;
   1158            (void)partNwkAddr;
   1159            (void)partExtAddr;
   1160          
   1161            //---------------------------------------------------------------------------
   1162            // note:
   1163            // should use a robust mechanism to generate keys, for example
   1164            // combine EXT addresses and call a hash function
   1165            //---------------------------------------------------------------------------
   1166            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV       A,#0x4
   \   000006   12....       LCALL     ?XSTACK_DISP0_8
   \   000009   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00000C   FA           MOV       R2,A
   \   00000D   A3           INC       DPTR
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FB           MOV       R3,A
   \   000010   7910         MOV       R1,#0x10
   \   000012   12....       LCALL     `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
   1167          
   1168            *keyType = ZDSecMgrAppKeyType;
   \   000015   90....       MOV       DPTR,#ZDSecMgrAppKeyType
   \   000018   E0           MOVX      A,@DPTR
   \   000019   C0E0         PUSH      A
   \   00001B   7406         MOV       A,#0x6
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000023   D0E0         POP       A
   \   000025   F0           MOVX      @DPTR,A
   1169          
   1170            return ZSuccess;
   \   000026   7900         MOV       R1,#0x0
   \   000028   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   1171          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   12....       LCALL     ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   E0           MOVX      A,@DPTR
   \   000001                REQUIRE ??Subroutine116_0
   \   000001                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   F8           MOV       R0,A
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine117_0
   \   000002                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F583         MOV       DPH,A
   \   000003   8882         MOV       DPL,R0
   \   000005   22           RET
   1172          
   1173          /******************************************************************************
   1174           * @fn          ZDSecMgrAppKeyReq
   1175           *
   1176           * @brief       Process request for APP key between two devices.
   1177           *
   1178           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1179           *
   1180           * @return      none
   1181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1182          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1183          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV       A,#-0x27
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1184            APSME_TransportKeyReq_t req;
   1185            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1186            uint16                  partNwkAddr;
   1187            uint8                   key[SEC_KEY_LEN];
   1188          
   1189          
   1190            // validate initiator and partner
   1191            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1192                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   EA           MOV       A,R2
   \   000013   2405         ADD       A,#0x5
   \   000015   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000018   6003         JZ        $+5
   \   00001A   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   00001D                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00001D   740F         MOV       A,#0xf
   \   00001F   12....       LCALL     ?XSTACK_DISP102_8
   \   000022   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000025   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000028   E9           MOV       A,R1
   \   000029   6401         XRL       A,#0x1
   \   00002B   6003         JZ        $+5
   \   00002D   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1193            {
   1194              // point the key to some memory
   1195              req.key = key;
   \   000030   7417         MOV       A,#0x17
   \   000032   12....       LCALL     ?XSTACK_DISP100_8
   \   000035   7406         MOV       A,#0x6
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1196          
   1197              // get an APP key - option APP (MASTER or LINK) key
   1198              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1199                                      initExtAddr,
   1200                                      partNwkAddr,
   1201                                      ind->partExtAddr,
   1202                                      &req.key,
   1203                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_190:
   \   00003D                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00003D   7404         MOV       A,#0x4
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   8582..       MOV       ?V0,DPL
   \   000045   8583..       MOV       ?V1,DPH
   \   000048   78..         MOV       R0,#?V0
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004D   7408         MOV       A,#0x8
   \   00004F   12....       LCALL     ?XSTACK_DISP0_8
   \   000052   8582..       MOV       ?V0,DPL
   \   000055   8583..       MOV       ?V1,DPH
   \   000058   78..         MOV       R0,#?V0
   \   00005A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005D   EE           MOV       A,R6
   \   00005E   2405         ADD       A,#0x5
   \   000060   F5..         MOV       ?V0,A
   \   000062   E4           CLR       A
   \   000063   3F           ADDC      A,R7
   \   000064   F5..         MOV       ?V1,A
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   7406         MOV       A,#0x6
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000073   7417         MOV       A,#0x17
   \   000075   12....       LCALL     ?XSTACK_DISP102_8
   \   000078   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   00007B   12....       LCALL     `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   00007E   7408         MOV       A,#0x8
   \   000080   12....       LCALL     ?DEALLOC_XSTACK8
   \   000083   E9           MOV       A,R1
   \   000084   7073         JNZ       ??ZDSecMgrAppKeyReq_0
   1204              {
   1205                // always secure
   1206                req.nwkSecure = TRUE;
   \   000086   740C         MOV       A,#0xc
   \   000088   12....       LCALL     ?XSTACK_DISP0_8
   \   00008B   7401         MOV       A,#0x1
   \   00008D   F0           MOVX      @DPTR,A
   1207                req.apsSecure = TRUE;
   \   00008E   740B         MOV       A,#0xb
   \   000090   12....       LCALL     ?XSTACK_DISP0_8
   \   000093   7401         MOV       A,#0x1
   \   000095   F0           MOVX      @DPTR,A
   1208                req.tunnel    = NULL;
   \   000096   740D         MOV       A,#0xd
   \   000098   12....       LCALL     ?XSTACK_DISP0_8
   \   00009B   12....       LCALL     ?Subroutine12 & 0xFFFF
   1209          
   1210                // send key to initiator device
   1211                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_257:
   \   00009E   7402         MOV       A,#0x2
   \   0000A0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1212                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_191:
   \   0000A6   EE           MOV       A,R6
   \   0000A7   2405         ADD       A,#0x5
   \   0000A9   F8           MOV       R0,A
   \   0000AA   E4           CLR       A
   \   0000AB   3F           ADDC      A,R7
   \   0000AC   F9           MOV       R1,A
   \   0000AD   7408         MOV       A,#0x8
   \   0000AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B2   12....       LCALL     ?Subroutine18 & 0xFFFF
   1213                req.initiator = TRUE;
   \                     ??CrossCallReturnLabel_5:
   \   0000B5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B8   7401         MOV       A,#0x1
   \   0000BA   F0           MOVX      @DPTR,A
   1214                APSME_TransportKeyReq( &req );
   \   0000BB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000BB   04           INC       A
   \   0000BC   12....       LCALL     ?XSTACK_DISP101_8
   \   0000BF   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1215          
   1216                // send key to partner device
   1217                req.dstAddr   = partNwkAddr;
   \   0000C2   85..82       MOV       DPL,?XSP + 0
   \   0000C5   85..83       MOV       DPH,?XSP + 1
   \   0000C8   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   0000CB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CE   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1218                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_192:
   \   0000D1   740F         MOV       A,#0xf
   \   0000D3   12....       LCALL     ?XSTACK_DISP100_8
   \   0000D6   7408         MOV       A,#0x8
   \   0000D8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DB   12....       LCALL     ?Subroutine18 & 0xFFFF
   1219                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_6:
   \   0000DE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E1   E4           CLR       A
   \   0000E2   F0           MOVX      @DPTR,A
   1220          
   1221                APSME_TransportKeyReq( &req );
   \   0000E3                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000E3   7402         MOV       A,#0x2
   \   0000E5   12....       LCALL     ?XSTACK_DISP101_8
   \   0000E8   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1222          
   1223                // clear copy of key in RAM
   1224                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000EB                ; Setup parameters for call to function osal_memset
   \   0000EB   7C10         MOV       R4,#0x10
   \   0000ED   7D00         MOV       R5,#0x0
   \   0000EF   7900         MOV       R1,#0x0
   \   0000F1   7417         MOV       A,#0x17
   \   0000F3   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F6   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1225          
   1226              }
   1227            }
   1228          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000F9   7427         MOV       A,#0x27
   \   0000FB   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine121_0
   \   000004                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine122_0
   \   000002                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV       A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   FA           MOV       R2,A
   \   000001   E4           CLR       A
   \   000002   3F           ADDC      A,R7
   \   000003   FB           MOV       R3,A
   \   000004   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000007   E9           MOV       A,R1
   \   000008   6401         XRL       A,#0x1
   \   00000A   22           RET
   1229          
   1230          /******************************************************************************
   1231           * @fn          ZDSecMgrEstablishKey
   1232           *
   1233           * @brief       Start SKKE with device joining network.
   1234           *
   1235           * @param       device - [in] ZDSecMgrDevice_t, device info
   1236           *
   1237           * @return      ZStatus_t
   1238           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1239          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1240          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1241            ZStatus_t               status;
   1242            APSME_EstablishKeyReq_t req;
   1243          
   1244          
   1245            req.respExtAddr = device->extAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000015   12....       LCALL     ?XSTACK_DISP0_8
   \   000018   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1246            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_193:
   \   00001B   7404         MOV       A,#0x4
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E4           CLR       A
   \   000021   12....       LCALL     ??Subroutine115_0 & 0xFFFF
   1247          
   1248            if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_208:
   \   000024   7003         JNZ       ??ZDSecMgrEstablishKey_0
   \   000026   A3           INC       DPTR
   \   000027   E0           MOVX      A,@DPTR
   \   000028   69           XRL       A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   7010         JNZ       ??ZDSecMgrEstablishKey_1
   1249            {
   1250              req.dstAddr   = device->nwkAddr;
   \   00002F   12....       LCALL     ?Subroutine32 & 0xFFFF
   1251              //devtag.0604.todo - remove obsolete
   1252              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_184:
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E4           CLR       A
   \   000036   F0           MOVX      @DPTR,A
   1253              req.nwkSecure = FALSE;
   \   000037   7406         MOV       A,#0x6
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E4           CLR       A
   \   00003D   8014         SJMP      ??ZDSecMgrEstablishKey_2
   1254            }
   1255            else
   1256            {
   1257              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   12....       LCALL     ?Subroutine32 & 0xFFFF
   1258              //devtag.0604.todo - remove obsolete
   1259              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_185:
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   7401         MOV       A,#0x1
   \   00004B   F0           MOVX      @DPTR,A
   1260              req.nwkSecure = TRUE;
   \   00004C   7406         MOV       A,#0x6
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   7401         MOV       A,#0x1
   1261            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000053   12....       LCALL     ?Subroutine23 & 0xFFFF
   1262          
   1263            status = APSME_EstablishKeyReq( &req );
   1264          
   1265            return status;
   \                     ??CrossCallReturnLabel_20:
   \   000056   12....       LCALL     `??APSME_EstablishKeyReq::?relay`; Banked call to: APSME_EstablishKeyReq
   \   000059   7407         MOV       A,#0x7
   \   00005B   02....       LJMP      ??Subroutine118_0 & 0xFFFF
   1266          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003                REQUIRE ??Subroutine113_0
   \   000003                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV       A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001   12....       LCALL     ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   A8..         MOV       R0,?V0
   \   000009   A9..         MOV       R1,?V1
   \   00000B   8E82         MOV       DPL,R6
   \   00000D   8F83         MOV       DPH,R7
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   E0           MOVX      A,@DPTR
   \   000014   68           XRL       A,R0
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine123_0
   \   000002                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL     ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   000003   85..82       MOV       DPL,?XSP + 0
   \   000006   85..83       MOV       DPH,?XSP + 1
   \   000009   22           RET
   1267          
   1268          /******************************************************************************
   1269           * @fn          ZDSecMgrSendMasterKey
   1270           *
   1271           * @brief       Send MASTER key to device joining network.
   1272           *
   1273           * @param       device - [in] ZDSecMgrDevice_t, device info
   1274           *
   1275           * @return      ZStatus_t
   1276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1277          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1278          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV       A,#-0x1f
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1279            ZStatus_t status;
   1280            APSME_TransportKeyReq_t req;
   1281            uint16 keyNvId;
   1282            uint8 masterKey[SEC_KEY_LEN];
   1283          
   1284          
   1285            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV       A,#0x4
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   E4           CLR       A
   \   000014   12....       LCALL     ?Subroutine19 & 0xFFFF
   1286            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_10:
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   1287            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_237:
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine25 & 0xFFFF
   1288          
   1289            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \                     ??CrossCallReturnLabel_29:
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00002E   12....       LCALL     ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000031   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000034   702A         JNZ       ??ZDSecMgrSendMasterKey_0
   1290            {
   1291              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1292                            SEC_KEY_LEN, masterKey );
   \   000036                ; Setup parameters for call to function osal_nv_read
   \   000036   740F         MOV       A,#0xf
   \   000038   12....       LCALL     ?XSTACK_DISP100_8
   \   00003B   88..         MOV       ?V0,R0
   \   00003D   89..         MOV       ?V1,R1
   \   00003F   78..         MOV       R0,#?V0
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   75..10       MOV       ?V0,#0x10
   \   000047   75..00       MOV       ?V1,#0x0
   \   00004A   78..         MOV       R0,#?V0
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004F   7C02         MOV       R4,#0x2
   \   000051   7D00         MOV       R5,#0x0
   \   000053   7404         MOV       A,#0x4
   \   000055   12....       LCALL     ?XSTACK_DISP0_8
   \   000058   12....       LCALL     ?Subroutine49 & 0xFFFF
   1293            }
   \                     ??CrossCallReturnLabel_65:
   \   00005B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005E   800E         SJMP      ??ZDSecMgrSendMasterKey_1
   1294            else
   1295            {
   1296              // in case read from NV fails
   1297              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000060                ; Setup parameters for call to function osal_memset
   \   000060   7C10         MOV       R4,#0x10
   \   000062   7D00         MOV       R5,#0x0
   \   000064   7900         MOV       R1,#0x0
   \   000066   740F         MOV       A,#0xf
   \   000068   12....       LCALL     ?XSTACK_DISP101_8
   \   00006B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1298            }
   1299          
   1300            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   00006E   740F         MOV       A,#0xf
   \   000070   12....       LCALL     ?XSTACK_DISP100_8
   \   000073   7406         MOV       A,#0x6
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   12....       LCALL     ?Subroutine11 & 0xFFFF
   1301          
   1302            //check if using secure hop to to parent
   1303            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_206:
   \   00007B   7003         JNZ       ??ZDSecMgrSendMasterKey_2
   \   00007D   A3           INC       DPTR
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   69           XRL       A,R1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000080   8E82         MOV       DPL,R6
   \   000082   8F83         MOV       DPH,R7
   \   000084   601C         JZ        ??ZDSecMgrSendMasterKey_3
   1304            {
   1305              //send to parent with security
   1306              req.dstAddr   = device->parentAddr;
   \   000086   A3           INC       DPTR
   \   000087   A3           INC       DPTR
   \   000088   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00008B   12....       LCALL     ?XSTACK_DISP0_8
   \   00008E   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1307              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_194:
   \   000091   740C         MOV       A,#0xc
   \   000093   12....       LCALL     ?XSTACK_DISP0_8
   \   000096   7401         MOV       A,#0x1
   \   000098   F0           MOVX      @DPTR,A
   1308              req.apsSecure = TRUE;
   \   000099   740B         MOV       A,#0xb
   \   00009B   12....       LCALL     ?XSTACK_DISP0_8
   \   00009E   7401         MOV       A,#0x1
   \   0000A0   8016         SJMP      ??ZDSecMgrSendMasterKey_4
   1309            }
   1310            else
   1311            {
   1312              //direct with no security
   1313              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   0000A2   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   0000A5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A8   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1314              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_195:
   \   0000AB   740C         MOV       A,#0xc
   \   0000AD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B0   E4           CLR       A
   \   0000B1   F0           MOVX      @DPTR,A
   1315              req.apsSecure = FALSE;
   \   0000B2   740B         MOV       A,#0xb
   \   0000B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B7   E4           CLR       A
   \                     ??ZDSecMgrSendMasterKey_4:
   \   0000B8   F0           MOVX      @DPTR,A
   1316            }
   1317          
   1318            status = APSME_TransportKeyReq( &req );
   \   0000B9                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000B9   7402         MOV       A,#0x2
   \   0000BB   12....       LCALL     ?XSTACK_DISP101_8
   \   0000BE   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000C1   E9           MOV       A,R1
   \   0000C2   FE           MOV       R6,A
   1319          
   1320            // clear copy of key in RAM
   1321            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   0000C3                ; Setup parameters for call to function osal_memset
   \   0000C3   7C10         MOV       R4,#0x10
   \   0000C5   7D00         MOV       R5,#0x0
   \   0000C7   7900         MOV       R1,#0x0
   \   0000C9   740F         MOV       A,#0xf
   \   0000CB   12....       LCALL     ?XSTACK_DISP101_8
   \   0000CE   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1322          
   1323            return status;
   \   0000D1   EE           MOV       A,R6
   \   0000D2   F9           MOV       R1,A
   \   0000D3   741F         MOV       A,#0x1f
   \   0000D5   02....       LJMP      ??Subroutine118_0 & 0xFFFF
   1324          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004                REQUIRE ??Subroutine115_0
   \   000004                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000004   AC..         MOV       R4,?XSP + 0
   \   000006   AD..         MOV       R5,?XSP + 1
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003   740D         MOV       A,#0xd
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000003   7408         MOV       A,#0x8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL     ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003   12....       LCALL     ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000006   7404         MOV       A,#0x4
   \   000008   22           RET
   1325          
   1326          /******************************************************************************
   1327           * @fn          ZDSecMgrSendNwkKey
   1328           *
   1329           * @brief       Send NWK key to device joining network.
   1330           *
   1331           * @param       device - [in] ZDSecMgrDevice_t, device info
   1332           *
   1333           * @return      ZStatus_t
   1334           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1335          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1336          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV       A,#-0x1e
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1337            ZStatus_t status;
   1338            APSME_TransportKeyReq_t req;
   1339            APSDE_FrameTunnel_t tunnel;
   1340            nwkKeyDesc tmpKey;
   1341          
   1342            req.dstAddr   = device->nwkAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000015   E8           MOV       A,R0
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   E9           MOV       A,R1
   \   000019   12....       LCALL     ?Subroutine27 & 0xFFFF
   1343            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_35:
   \   00001C   12....       LCALL     ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   00001F   7406         MOV       A,#0x6
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   1344          
   1345            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1346            {
   1347              req.keyType   = KEY_TYPE_NWK_HIGH;
   1348            }
   1349            else
   1350            {
   1351              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_196:
   \   000027   7402         MOV       A,#0x2
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   7401         MOV       A,#0x1
   \   00002E   F0           MOVX      @DPTR,A
   1352            }
   1353          
   1354            // get the Active Key into a local variable
   1355            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1356                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   00002F                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   00002F   75..3A       MOV       ?V0,#0x3a
   \   000032   75..00       MOV       ?V1,#0x0
   \   000035   78..         MOV       R0,#?V0
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   740F         MOV       A,#0xf
   \   00003C   12....       LCALL     ?XSTACK_DISP100_8
   \   00003F   88..         MOV       ?V0,R0
   \   000041   89..         MOV       ?V1,R1
   \   000043   78..         MOV       R0,#?V0
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000048   7C11         MOV       R4,#0x11
   \   00004A   7D00         MOV       R5,#0x0
   \   00004C   7A00         MOV       R2,#0x0
   \   00004E   7B00         MOV       R3,#0x0
   \   000050   12....       LCALL     `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   000053   7404         MOV       A,#0x4
   \   000055   12....       LCALL     ?DEALLOC_XSTACK8
   \   000058   E9           MOV       A,R1
   \   000059   600E         JZ        ??ZDSecMgrSendNwkKey_0
   1357            {
   1358              // set key data to all 0s if NV read fails
   1359              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   00005B                ; Setup parameters for call to function osal_memset
   \   00005B   7C11         MOV       R4,#0x11
   \   00005D   7D00         MOV       R5,#0x0
   \   00005F   7900         MOV       R1,#0x0
   \   000061   740D         MOV       A,#0xd
   \   000063   12....       LCALL     ?XSTACK_DISP101_8
   \   000066   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1360            }
   1361          
   1362            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1363                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1364            {
   1365              // set values
   1366              req.keySeqNum = tmpKey.keySeqNum;
   1367              req.key       = tmpKey.key;
   1368          
   1369              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1370              //key isn't used to secure the frame at the APS layer -- since the receiving
   1371              //device may not have a NWK key yet
   1372              req.apsSecure = TRUE;
   1373          
   1374              // check if using secure hop to to parent
   1375              if ( device->parentAddr == NLME_GetShortAddr() )
   1376              {
   1377                req.nwkSecure = FALSE;
   1378                req.tunnel    = NULL;
   1379              }
   1380              else
   1381              {
   1382                req.nwkSecure   = TRUE;
   1383                req.tunnel      = &tunnel;
   1384                req.tunnel->tna = device->parentAddr;
   1385                req.tunnel->dea = device->extAddr;
   1386              }
   1387            }
   1388            else
   1389            {
   1390              // default values
   1391              //devtag.0604.verify
   1392              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000069   740A         MOV       A,#0xa
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   7401         MOV       A,#0x1
   \   000070   F0           MOVX      @DPTR,A
   1393              req.apsSecure = FALSE;
   \   000071   7409         MOV       A,#0x9
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   E4           CLR       A
   \   000077   F0           MOVX      @DPTR,A
   1394              req.tunnel    = NULL;
   \   000078   740B         MOV       A,#0xb
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   E4           CLR       A
   \   00007E   F0           MOVX      @DPTR,A
   \   00007F   A3           INC       DPTR
   \   000080   12....       LCALL     ??Subroutine115_0 & 0xFFFF
   1395          
   1396              if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_209:
   \   000083   7003         JNZ       ??ZDSecMgrSendNwkKey_1
   \   000085   A3           INC       DPTR
   \   000086   E0           MOVX      A,@DPTR
   \   000087   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000088   600B         JZ        ??CrossCallReturnLabel_204
   1397              {
   1398                req.dstAddr = device->parentAddr;
   \   00008A   8E82         MOV       DPL,R6
   \   00008C   8F83         MOV       DPH,R7
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   12....       LCALL     ?Subroutine34 & 0xFFFF
   1399              }
   1400          
   1401              // special cases
   1402              //devtag.0604.todo - modify to preconfig flag
   1403              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_204:
   \   000095   8E82         MOV       DPL,R6
   \   000097   8F83         MOV       DPH,R7
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   E0           MOVX      A,@DPTR
   \   0000A0   702C         JNZ       ??ZDSecMgrSendNwkKey_2
   1404              {
   1405                req.keySeqNum = tmpKey.keySeqNum;
   \   0000A2   740D         MOV       A,#0xd
   \   0000A4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   C0E0         PUSH      A
   \   0000AA   7403         MOV       A,#0x3
   \   0000AC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AF   D0E0         POP       A
   \   0000B1   F0           MOVX      @DPTR,A
   1406                req.key       = tmpKey.key;
   \   0000B2   740E         MOV       A,#0xe
   \   0000B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B7   A882         MOV       R0,DPL
   \   0000B9   A983         MOV       R1,DPH
   \   0000BB   7404         MOV       A,#0x4
   \   0000BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL     ?Subroutine11 & 0xFFFF
   1407          
   1408                // check if using secure hop to to parent
   1409                if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_207:
   \   0000C3   7003         JNZ       ??ZDSecMgrSendNwkKey_3
   \   0000C5   A3           INC       DPTR
   \   0000C6   E0           MOVX      A,@DPTR
   \   0000C7   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000C8   7014         JNZ       ??ZDSecMgrSendNwkKey_4
   1410                {
   1411                  req.nwkSecure = FALSE;
   \   0000CA   740A         MOV       A,#0xa
   \   0000CC   800B         SJMP      ??ZDSecMgrSendNwkKey_5
   1412                }
   1413              }
   1414              else
   1415              {
   1416                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000CE   7404         MOV       A,#0x4
   \   0000D0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D3   E4           CLR       A
   \   0000D4   F0           MOVX      @DPTR,A
   \   0000D5   A3           INC       DPTR
   \   0000D6   F0           MOVX      @DPTR,A
   1417                req.keySeqNum = 0;
   \   0000D7   7403         MOV       A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000D9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DC   E4           CLR       A
   \   0000DD   F0           MOVX      @DPTR,A
   1418              }
   1419            }
   1420          
   1421            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000DE                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000DE   AA..         MOV       R2,?XSP + 0
   \   0000E0   AB..         MOV       R3,?XSP + 1
   \   0000E2   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000E5   E9           MOV       A,R1
   \   0000E6   FE           MOV       R6,A
   1422          
   1423            // clear copy of key in RAM before return
   1424            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   0000E7                ; Setup parameters for call to function osal_memset
   \   0000E7   7C11         MOV       R4,#0x11
   \   0000E9   7D00         MOV       R5,#0x0
   \   0000EB   7900         MOV       R1,#0x0
   \   0000ED   740D         MOV       A,#0xd
   \   0000EF   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F2   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1425          
   1426            return status;
   \   0000F5   EE           MOV       A,R6
   \   0000F6   F9           MOV       R1,A
   \   0000F7   741E         MOV       A,#0x1e
   \   0000F9   02....       LJMP      ??Subroutine118_0 & 0xFFFF
   1427          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003                REQUIRE ??Subroutine114_0
   \   000003                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   22           RET
   1428          
   1429          /******************************************************************************
   1430           * @fn          ZDSecMgrDeviceEntryRemove
   1431           *
   1432           * @brief       Remove device entry.
   1433           *
   1434           * @param       entry - [in] valid entry
   1435           *
   1436           * @return      none
   1437           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1438          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1439          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1440            // terminate device control
   1441            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1442            {
   1443              ZDSecMgrCtrlTerm( entry );
   1444            }
   1445          
   1446            // remove device from entry data
   1447            ZDSecMgrEntryFree( entry );
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000004   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1448          
   1449          }
   \   000007   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   1450          
   1451          /******************************************************************************
   1452           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1453           *
   1454           * @brief       Remove device entry by its ext address.
   1455           *
   1456           * @param       pAddr - pointer to the extended address
   1457           *
   1458           * @return      ZStatus_t
   1459           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1460          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1461          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1462            ZDSecMgrEntry_t *pEntry;
   1463            uint8           retValue;
   1464          
   1465            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   AC..         MOV       R4,?XSP + 0
   \   00000C   AD..         MOV       R5,?XSP + 1
   \   00000E   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000011   E9           MOV       A,R1
   \   000012   FE           MOV       R6,A
   1466          
   1467            if( retValue == ZSuccess )
   \   000013   7003         JNZ       ??CrossCallReturnLabel_95
   1468            {
   1469              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000015                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000015   12....       LCALL     ?Subroutine67 & 0xFFFF
   1470            }
   1471          
   1472            return retValue;
   \                     ??CrossCallReturnLabel_95:
   \   000018   EE           MOV       A,R6
   \   000019   F9           MOV       R1,A
   \   00001A   02....       LJMP      ??Subroutine125_0 & 0xFFFF
   1473          }
   1474          
   1475          /******************************************************************************
   1476           * @fn          ZDSecMgrDeviceEntryAdd
   1477           *
   1478           * @brief       Add entry.
   1479           *
   1480           * @param       device - [in] ZDSecMgrDevice_t, device info
   1481           * @param       ami    - [in] Address Manager index
   1482           *
   1483           * @return      ZStatus_t
   1484           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1485          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1486          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   1487            AddrMgrEntry_t entry;
   1488          
   1489            // get the ami data
   1490            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
   1491            entry.index = ami;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ?Subroutine20 & 0xFFFF
   1492          
   1493            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_13:
   \   00001F   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1494          
   1495            // check if NWK address is same
   1496            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV       A,#0x1
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6E           XRL       A,R6
   \   000029   7003         JNZ       ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   6F           XRL       A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ        ??ZDSecMgrAddrMgrUpdate_1
   1497            {
   1498              // update NWK address
   1499              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV       A,#0x1
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   EE           MOV       A,R6
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   EF           MOV       A,R7
   \   000039   12....       LCALL     ?Subroutine23 & 0xFFFF
   1500          
   1501              AddrMgrEntryUpdate( &entry );
   1502            }
   \                     ??CrossCallReturnLabel_21:
   \   00003C   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   1503          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP      ?Subroutine8 & 0xFFFF
   1504          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1505          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1506          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1507            ZStatus_t        status;
   1508            ZDSecMgrEntry_t* entry;
   1509          
   1510            // initialize as unknown until completion
   1511            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV       ?V2,#-0x38
   1512          
   1513            device->ctrl = NULL;
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   12....       LCALL     ?Subroutine25 & 0xFFFF
   1514          
   1515            // make sure not already registered
   1516            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_30:
   \   000024   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000027   12....       LCALL     `??ZDSecMgrEntryLookup::?relay`; Banked call to: ZDSecMgrEntryLookup
   \   00002A   E9           MOV       A,R1
   \   00002B   7024         JNZ       ??ZDSecMgrDeviceEntryAdd_0
   1517            {
   1518              // verify that address index is same
   1519              if ( entry->ami != ami )
   \   00002D   85..82       MOV       DPL,?XSP + 0
   \   000030   85..83       MOV       DPH,?XSP + 1
   \   000033   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000036   6E           XRL       A,R6
   \   000037   7003         JNZ       ??ZDSecMgrDeviceEntryAdd_1
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   6F           XRL       A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   00003C   6024         JZ        ??CrossCallReturnLabel_77
   1520              {
   1521                // remove conflicting entry
   1522                ZDSecMgrDeviceEntryRemove( entry );
   \   00003E                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   00003E   12....       LCALL     ?Subroutine67 & 0xFFFF
   1523          
   1524                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   1525                {
   1526                  // update NWK address
   1527                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1528                }
   1529              }
   1530            }
   \                     ??CrossCallReturnLabel_96:
   \   000041                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000041   AC..         MOV       R4,?XSP + 0
   \   000043   AD..         MOV       R5,?XSP + 1
   \   000045   EE           MOV       A,R6
   \   000046   FA           MOV       R2,A
   \   000047   EF           MOV       A,R7
   \   000048   FB           MOV       R3,A
   \   000049   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   00004C   E9           MOV       A,R1
   \   00004D   7013         JNZ       ??CrossCallReturnLabel_77
   \   00004F   800E         SJMP      ??ZDSecMgrDeviceEntryAdd_2
   1531            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000051                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000051   AC..         MOV       R4,?XSP + 0
   \   000053   AD..         MOV       R5,?XSP + 1
   \   000055   EE           MOV       A,R6
   \   000056   FA           MOV       R2,A
   \   000057   EF           MOV       A,R7
   \   000058   FB           MOV       R3,A
   \   000059   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   00005C   E9           MOV       A,R1
   \   00005D   7003         JNZ       ??CrossCallReturnLabel_77
   1532            {
   1533              // update NWK address
   1534              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00005F                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00005F   12....       LCALL     ?Subroutine54 & 0xFFFF
   1535            }
   1536          
   1537            // check if a new entry needs to be created
   1538            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_77:
   \   000062   12....       LCALL     ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000065   701B         JNZ       ??CrossCallReturnLabel_78
   1539            {
   1540              // get new entry
   1541              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000067                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000067   AA..         MOV       R2,?XSP + 0
   \   000069   AB..         MOV       R3,?XSP + 1
   \   00006B   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00006E   E9           MOV       A,R1
   \   00006F   7014         JNZ       ??ZDSecMgrDeviceEntryAdd_3
   1542              {
   1543                // reset entry lkd
   1544          
   1545                // finish setting up entry
   1546                entry->ami = ami;
   \   000071   85..82       MOV       DPL,?XSP + 0
   \   000074   85..83       MOV       DPH,?XSP + 1
   \   000077   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00007A   EE           MOV       A,R6
   \   00007B   F0           MOVX      @DPTR,A
   \   00007C   A3           INC       DPTR
   \   00007D   EF           MOV       A,R7
   \   00007E   F0           MOVX      @DPTR,A
   1547          
   1548                // update NWK address
   1549                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   00007F                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00007F   12....       LCALL     ?Subroutine54 & 0xFFFF
   1550          
   1551                // enter new device into device control
   1552                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1553                {
   1554                  status = ZDSecMgrCtrlAdd( device, entry );
   1555                }
   1556                else
   1557                {
   1558                  status = ZSuccess;
   1559                }
   1560              }
   1561            }
   1562            else
   1563            {
   1564              // reset entry lkd
   1565          
   1566              // reset entry in entry control
   1567              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1568              {
   1569                status = ZDSecMgrCtrlReset( device, entry );
   1570              }
   1571              else
   1572              {
   1573                status = ZSuccess;
   \                     ??CrossCallReturnLabel_78:
   \   000082   75..00       MOV       ?V2,#0x0
   1574              }
   1575            }
   1576          
   1577            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000085   A9..         MOV       R1,?V2
   \   000087   7402         MOV       A,#0x2
   \   000089                REQUIRE ?Subroutine5
   \   000089                ; // Fall through to label ?Subroutine5
   1578          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F03         MOV       R7,#0x3
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV       DPL,?V0
   \   000003   85..83       MOV       DPH,?V1
   \   000006   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000009   12....       LCALL     `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EE           MOV       A,R6
   \   000006   FA           MOV       R2,A
   \   000007   EF           MOV       A,R7
   \   000008   FB           MOV       R3,A
   \   000009   22           RET
   1579          
   1580          /******************************************************************************
   1581           * @fn          ZDSecMgrDeviceCtrlHandler
   1582           *
   1583           * @brief       Device control handler.
   1584           *
   1585           * @param       device - [in] ZDSecMgrDevice_t, device info
   1586           *
   1587           * @return      none
   1588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1589          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1590          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   1591            uint8 state;
   1592            uint8 cntr;
   1593          
   1594            state = device->ctrl->state;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000010   E0           MOVX      A,@DPTR
   \   000011   F5..         MOV       ?V0,A
   1595            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1596          
   1597            switch ( state )
   \   000013   24FE         ADD       A,#-0x2
   \   000015   600C         JZ        ??ZDSecMgrDeviceCtrlHandler_0
   \   000017   14           DEC       A
   \   000018   6014         JZ        ??ZDSecMgrDeviceCtrlHandler_1
   \   00001A   14           DEC       A
   \   00001B   6022         JZ        ??ZDSecMgrDeviceCtrlHandler_2
   \   00001D   24FD         ADD       A,#-0x3
   \   00001F   6018         JZ        ??ZDSecMgrDeviceCtrlHandler_3
   \   000021   8046         SJMP      ??ZDSecMgrDeviceCtrlHandler_4
   1598            {
   1599              case ZDSECMGR_CTRL_TK_MASTER:
   1600                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000023                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000023   12....       LCALL     `??ZDSecMgrSendMasterKey::?relay`; Banked call to: ZDSecMgrSendMasterKey
   \   000026   E9           MOV       A,R1
   \   000027   7016         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1601                {
   1602                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000029   75..03       MOV       ?V0,#0x3
   1603                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002C   8011         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1604                }
   1605                break;
   1606          
   1607              case ZDSECMGR_CTRL_SKKE_INIT:
   1608                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002E                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00002E   12....       LCALL     `??ZDSecMgrEstablishKey::?relay`; Banked call to: ZDSecMgrEstablishKey
   \   000031   E9           MOV       A,R1
   \   000032   700B         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1609                {
   1610                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000034   75..04       MOV       ?V0,#0x4
   \   000037   8006         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1611                }
   1612                break;
   1613          
   1614              case ZDSECMGR_CTRL_SKKE_WAIT:
   1615                // continue to wait for SKA control timeout
   1616                break;
   1617          
   1618              case ZDSECMGR_CTRL_TK_NWK:
   1619                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000039                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000039   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003C   E9           MOV       A,R1
   \   00003D   602A         JZ        ??ZDSecMgrDeviceCtrlHandler_4
   1620                {
   1621                  state = ZDSECMGR_CTRL_NONE;
   1622                }
   1623                break;
   1624          
   1625              default:
   1626                state = ZDSECMGR_CTRL_NONE;
   1627                break;
   1628            }
   1629          
   1630            if ( state != ZDSECMGR_CTRL_NONE )
   1631            {
   1632              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00003F   EE           MOV       A,R6
   \   000040   2408         ADD       A,#0x8
   \   000042   F8           MOV       R0,A
   \   000043   E4           CLR       A
   \   000044   3F           ADDC      A,R7
   \   000045   F9           MOV       R1,A
   \   000046   8882         MOV       DPL,R0
   \   000048   F583         MOV       DPH,A
   \   00004A   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00004D   A3           INC       DPTR
   \   00004E   A3           INC       DPTR
   \   00004F   A3           INC       DPTR
   \   000050   E5..         MOV       A,?V0
   \   000052   12....       LCALL     ?Subroutine35 & 0xFFFF
   1633              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_44:
   \   000055   12....       LCALL     ?Subroutine79 & 0xFFFF
   1634          
   1635              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_115:
   \   000058                ; Setup parameters for call to function osal_start_timerEx
   \   000058   7C64         MOV       R4,#0x64
   \   00005A   7D00         MOV       R5,#0x0
   \   00005C   7A00         MOV       R2,#0x0
   \   00005E   FB           MOV       R3,A
   \   00005F   90....       MOV       DPTR,#ZDAppTaskID
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F9           MOV       R1,A
   \   000064   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000067   8009         SJMP      ??ZDSecMgrDeviceCtrlHandler_5
   1636            }
   1637            else
   1638            {
   1639              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000069   8E82         MOV       DPL,R6
   \   00006B   8F83         MOV       DPH,R7
   \   00006D   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000070   E4           CLR       A
   \   000071   F0           MOVX      @DPTR,A
   1640            }
   1641          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000072   02....       LJMP      ??Subroutine127_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002   A3           INC       DPTR
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   C8           XCH       A,R0
   \   000001   2406         ADD       A,#0x6
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   38           ADDC      A,R0
   \   000007   F583         MOV       DPH,A
   \   000009   7401         MOV       A,#0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL     ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   22           RET
   1642          
   1643          /******************************************************************************
   1644           * @fn          ZDSecMgrDeviceCtrlSetup
   1645           *
   1646           * @brief       Setup device control.
   1647           *
   1648           * @param       device - [in] ZDSecMgrDevice_t, device info
   1649           *
   1650           * @return      ZStatus_t
   1651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   12....       LCALL     ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1652          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1653          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1654            if ( device->ctrl != NULL )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000013   602A         JZ        ??ZDSecMgrDeviceCtrlSetup_0
   1655            {
   1656              if ( device->secure == FALSE )
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   8A82         MOV       DPL,R2
   \   000022   8B83         MOV       DPH,R3
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   7007         JNZ       ??ZDSecMgrDeviceCtrlSetup_1
   1657              {
   1658                // send the master key data to the joining device
   1659                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002F   12....       LCALL     ??Subroutine111_0 & 0xFFFF
   1660              }
   \                     ??CrossCallReturnLabel_178:
   \   000032   7402         MOV       A,#0x2
   \   000034   8005         SJMP      ??ZDSecMgrDeviceCtrlSetup_2
   1661              else
   1662              {
   1663                // start SKKE
   1664                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000036   12....       LCALL     ??Subroutine111_0 & 0xFFFF
   1665              }
   \                     ??CrossCallReturnLabel_179:
   \   000039   7403         MOV       A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   00003B   F0           MOVX      @DPTR,A
   1666          
   1667              ZDSecMgrDeviceCtrlHandler( device );
   \   00003C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00003C   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   1668            }
   1669          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00003F   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   1670          
   1671          /******************************************************************************
   1672           * @fn          ZDSecMgrDeviceCtrlUpdate
   1673           *
   1674           * @brief       Update control data.
   1675           *
   1676           * @param       extAddr - [in] EXT address
   1677           * @param       state   - [in] new control state
   1678           *
   1679           * @return      none
   1680           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   A3           INC       DPTR
   \   000007                REQUIRE ??Subroutine111_0
   \   000007                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1681          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1682          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   1683            ZDSecMgrEntry_t* entry;
   1684            ZDSecMgrCtrl_t*  ctrl;
   1685          
   1686            // lookup device entry data
   1687            (void)ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV       A,#0x2
   \   00000E   12....       LCALL     ?XSTACK_DISP102_8
   \   000011   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   1688          
   1689            if ( entry != NULL )
   \   000014   7402         MOV       A,#0x2
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00001C   603D         JZ        ??CrossCallReturnLabel_116
   1690            {
   1691              // lookup device control data
   1692              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   00002A   12....       LCALL     ?Subroutine43 & 0xFFFF
   1693          
   1694              // make sure control data is valid
   1695              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_270:
   \   00002D   602C         JZ        ??CrossCallReturnLabel_116
   1696              {
   1697                // possible state transitions
   1698                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00002F   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   000032   E0           MOVX      A,@DPTR
   \   000033   6404         XRL       A,#0x4
   \   000035   7024         JNZ       ??CrossCallReturnLabel_116
   1699                {
   1700                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000037   7405         MOV       A,#0x5
   \   000039   6E           XRL       A,R6
   \   00003A   7007         JNZ       ??ZDSecMgrDeviceCtrlUpdate_0
   1701                  {
   1702                    // send the network key
   1703                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00003C   12....       LCALL     ?Subroutine57 & 0xFFFF
   1704                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1705                  }
   \                     ??CrossCallReturnLabel_182:
   \   00003F   7407         MOV       A,#0x7
   \   000041   800A         SJMP      ??ZDSecMgrDeviceCtrlUpdate_1
   1706                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000043   7406         MOV       A,#0x6
   \   000045   6E           XRL       A,R6
   \   000046   7013         JNZ       ??CrossCallReturnLabel_116
   1707                  {
   1708                    // force default timeout in order to cleanup control logic
   1709                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000048   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   00004B   7406         MOV       A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00004D   F0           MOVX      @DPTR,A
   1710                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   00004E   85..82       MOV       DPL,?XSP + 0
   \   000051   85..83       MOV       DPH,?XSP + 1
   \   000054   E0           MOVX      A,@DPTR
   \   000055   F8           MOV       R0,A
   \   000056   A3           INC       DPTR
   \   000057   E0           MOVX      A,@DPTR
   \   000058   12....       LCALL     ?Subroutine79 & 0xFFFF
   1711                  }
   1712                }
   1713                // timer should be active
   1714              }
   1715            }
   1716          }
   \                     ??CrossCallReturnLabel_116:
   \   00005B                REQUIRE ?Subroutine9
   \   00005B                ; // Fall through to label ?Subroutine9

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine126_0 & 0xFFFF
   1717          
   1718          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1719          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1720          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1721            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1722            {
   1723              if ( initiator == TRUE )
   1724              {
   1725                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1726              }
   1727            }
   1728          }
   \   000000   02....       LJMP      ?BRET
   1729          
   1730          /******************************************************************************
   1731           * @fn          ZDSecMgrDeviceRemove
   1732           *
   1733           * @brief       Remove device from network.
   1734           *
   1735           * @param       device - [in] ZDSecMgrDevice_t, device info
   1736           *
   1737           * @return      none
   1738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1739          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1740          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1741            APSME_RemoveDeviceReq_t remDevReq;
   1742            NLME_LeaveReq_t         leaveReq;
   1743            associated_devices_t*   assoc;
   1744          
   1745            // check if parent, remove the device
   1746            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL     ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000011   7003         JNZ       ??ZDSecMgrDeviceRemove_0
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   69           XRL       A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000016   705F         JNZ       ??ZDSecMgrDeviceRemove_1
   1747            {
   1748              // this is the parent of the device
   1749              leaveReq.extAddr        = device->extAddr;
   \   000018   EE           MOV       A,R6
   \   000019   2402         ADD       A,#0x2
   \   00001B   F8           MOV       R0,A
   \   00001C   E4           CLR       A
   \   00001D   3F           ADDC      A,R7
   \   00001E   F9           MOV       R1,A
   \   00001F   8882         MOV       DPL,R0
   \   000021   F583         MOV       DPH,A
   \   000023   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000026   12....       LCALL     ?Subroutine30 & 0xFFFF
   1750              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_250:
   \   000029   7402         MOV       A,#0x2
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   1751              leaveReq.rejoin         = FALSE;
   \   000030   7403         MOV       A,#0x3
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E4           CLR       A
   \   000036   12....       LCALL     ?Subroutine83 & 0xFFFF
   1752          
   1753              // find child association
   1754              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_123:
   \   000039   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00003C   8B..         MOV       ?V1,R3
   \   00003E   A9..         MOV       R1,?V1
   1755          
   1756              if ( ( assoc != NULL                            ) &&
   1757                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1758                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000040   EA           MOV       A,R2
   \   000041   49           ORL       A,R1
   \   000042   6056         JZ        ??ZDSecMgrDeviceRemove_2
   \   000044   8A82         MOV       DPL,R2
   \   000046   8B83         MOV       DPH,R3
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   E0           MOVX      A,@DPTR
   \   00004D   604B         JZ        ??ZDSecMgrDeviceRemove_2
   \   00004F   C3           CLR       C
   \   000050   9405         SUBB      A,#0x5
   \   000052   5046         JNC       ??ZDSecMgrDeviceRemove_2
   1759              {
   1760                // check if associated device is authenticated
   1761                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   A2E3         MOV       C,0xE0 /* A   */.3
   \   000060   7404         MOV       A,#0x4
   \   000062   5006         JNC       ??ZDSecMgrDeviceRemove_3
   1762                {
   1763                  leaveReq.silent = FALSE;
   \   000064   12....       LCALL     ?XSTACK_DISP0_8
   \   000067   E4           CLR       A
   \   000068   8005         SJMP      ??ZDSecMgrDeviceRemove_4
   1764                }
   1765                else
   1766                {
   1767                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   00006A   12....       LCALL     ?XSTACK_DISP0_8
   \   00006D   7401         MOV       A,#0x1
   1768                }
   1769          
   1770                NLME_LeaveReq( &leaveReq );
   1771              }
   1772            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   00006F   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000072   12....       LCALL     `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   000075   8023         SJMP      ??ZDSecMgrDeviceRemove_2
   1773            else
   1774            {
   1775              // this is not the parent of the device
   1776              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000077   8E82         MOV       DPL,R6
   \   000079   8F83         MOV       DPH,R7
   \   00007B   A3           INC       DPTR
   \   00007C   A3           INC       DPTR
   \   00007D   12....       LCALL     ??Subroutine143_0 & 0xFFFF
   1777              remDevReq.childExtAddr = device->extAddr;
   1778          
   1779              APSME_RemoveDeviceReq( &remDevReq );
   1780            }
   \                     ??CrossCallReturnLabel_323:
   \   000080   7405         MOV       A,#0x5
   \   000082   12....       LCALL     ?XSTACK_DISP0_8
   \   000085   E8           MOV       A,R0
   \   000086   F0           MOVX      @DPTR,A
   \   000087   A3           INC       DPTR
   \   000088   E9           MOV       A,R1
   \   000089   12....       LCALL     ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   00008C   7407         MOV       A,#0x7
   \   00008E   12....       LCALL     ?XSTACK_DISP0_8
   \   000091   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000094   12....       LCALL     ?XSTACK_DISP101_8
   \   000097   12....       LCALL     `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1781          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   00009A   7409         MOV       A,#0x9
   \   00009C   80..         SJMP      ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine129_0
   \   000006                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000003   12....       LCALL     `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine144_0
   \   000002                ; // Fall through to label ??Subroutine144_0
   1782          
   1783          /******************************************************************************
   1784           * @fn          ZDSecMgrDeviceValidateSKKE
   1785           *
   1786           * @brief       Decide whether device is allowed for SKKE.
   1787           *
   1788           * @param       device - [in] ZDSecMgrDevice_t, device info
   1789           *
   1790           * @return      ZStatus_t
   1791           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1792          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1793          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1794            ZStatus_t status;
   1795            uint16 ami;
   1796            uint16 keyNvId;
   1797          
   1798            // get EXT address
   1799            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   8A82         MOV       DPL,R2
   \   000014   F583         MOV       DPH,A
   \   000016   12....       LCALL     ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000019   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00001C   E9           MOV       A,R1
   \   00001D   F9           MOV       R1,A
   1800          
   1801            if ( status == ZSuccess )
   \   00001E   700F         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1802            {
   1803              // get MASTER key
   1804              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV       A,#0x2
   \   000022   12....       LCALL     ?XSTACK_DISP102_8
   \   000025   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000028   F9           MOV       R1,A
   1805          
   1806              if ( status == ZSuccess )
   \   000029   7004         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1807              {
   1808                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00002B                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00002B   12....       LCALL     ?Subroutine55 & 0xFFFF
   1809              }
   1810            }
   \                     ??CrossCallReturnLabel_79:
   \   00002E   F9           MOV       R1,A
   1811          
   1812            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   00002F   02....       LJMP      ?Subroutine9 & 0xFFFF
   1813          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000009   12....       LCALL     `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00000C   E9           MOV       A,R1
   \   00000D   22           RET
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1817           *
   1818           * @brief       Decide whether device is allowed.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1824          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1825          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1826            ZStatus_t status;
   1827          
   1828            status = ZSuccess;
   \   000004   7900         MOV       R1,#0x0
   1829          
   1830            (void)device;  // Intentionally unreferenced parameter
   1831          
   1832            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1833            // the trust center to reject any newly joining devices by sending
   1834            // Remove-device to the parents.
   1835            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV       DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   7002         JNZ       ??ZDSecMgrDeviceValidateRM_0
   1836            {
   1837              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV       R1,#-0x38
   1838            }
   1839          
   1840          
   1841          
   1842          #if 0  // Taken out because the following functionality is only used for test
   1843                 // purpose. A more efficient (above) way is used. It can be put
   1844                 // back in if customers request for a white/black list feature.
   1845                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1846          
   1847            // The following code processes the device black list (stored device list)
   1848            // If the joining device is not part of the forbidden device list
   1849            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1850            // will send Remove-device and ban the device from joining.
   1851          
   1852            uint8     index;
   1853            uint8*    restricted;
   1854          
   1855            // Look through the stored device list - used for restricted devices
   1856            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1857            {
   1858              restricted = ZDSecMgrStoredDeviceList[index];
   1859          
   1860              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1861              {
   1862                // return as unknown device in regards to validation
   1863                status = ZNwkUnknownDevice;
   1864          
   1865                // break from loop
   1866                index = ZDSECMGR_STORED_DEVICES;
   1867              }
   1868            }
   1869          
   1870          #endif
   1871          
   1872            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   1873          }
   1874          
   1875          /******************************************************************************
   1876           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1877           *
   1878           * @brief       Decide whether device is allowed.
   1879           *
   1880           * @param       device - [in] ZDSecMgrDevice_t, device info
   1881           *
   1882           * @return      ZStatus_t
   1883           */
   1884          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1885          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1886          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1887            ZStatus_t status;
   1888            uint16    ami;
   1889            uint8     key[SEC_KEY_LEN];
   1890          
   1891            // implement EXT address and MASTER key policy here -- the total number of
   1892            // Security Manager entries should never exceed the number of EXT addresses
   1893            // and MASTER keys available
   1894          
   1895            // set status based on policy
   1896            //status = ZNwkUnknownDevice;
   1897          
   1898            // set status based on policy
   1899            status = ZSuccess; // ZNwkUnknownDevice;
   1900          
   1901            // get key based on policy
   1902            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   00000E                ; Setup parameters for call to function osal_memcpy
   \   00000E   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000011   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000014   75..80       MOV       ?V2,#-0x80
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00001C   7C10         MOV       R4,#0x10
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7405         MOV       A,#0x5
   \   000022   12....       LCALL     ?XSTACK_DISP101_8
   \   000025   12....       LCALL     ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000028   12....       LCALL     ?DEALLOC_XSTACK8
   1903          
   1904            // if policy, store new EXT address
   1905            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002B   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00002E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00002E   A8..         MOV       R0,?XSP + 0
   \   000030   A9..         MOV       R1,?XSP + 1
   \   000032   88..         MOV       ?V2,R0
   \   000034   89..         MOV       ?V3,R1
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   85..82       MOV       DPL,?V0
   \   00003E   85..83       MOV       DPH,?V1
   \   000041   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   \   000047   E9           MOV       A,R1
   \   000048   F5..         MOV       ?V2,A
   1906          
   1907            // set the key
   1908            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00004A                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00004A   7402         MOV       A,#0x2
   \   00004C   12....       LCALL     ?XSTACK_DISP102_8
   \   00004F   85..82       MOV       DPL,?V0
   \   000052   85..83       MOV       DPH,?V1
   \   000055   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000058   12....       LCALL     `??ZDSecMgrMasterKeyLoad::?relay`; Banked call to: ZDSecMgrMasterKeyLoad
   1909          
   1910            // if EXT address and MASTER key available -- add device
   1911            if ( status == ZSuccess )
   \   00005B   E5..         MOV       A,?V2
   \   00005D   7005         JNZ       ??ZDSecMgrDeviceValidateCM_0
   1912            {
   1913              // add device to internal data - with control
   1914              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00005F                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00005F   12....       LCALL     ?Subroutine55 & 0xFFFF
   1915            }
   \                     ??CrossCallReturnLabel_80:
   \   000062   F5..         MOV       ?V2,A
   1916          
   1917            // remove copy of key in RAM
   1918            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000064                ; Setup parameters for call to function osal_memset
   \   000064   7C10         MOV       R4,#0x10
   \   000066   7D00         MOV       R5,#0x0
   \   000068   7900         MOV       R1,#0x0
   \   00006A   7402         MOV       A,#0x2
   \   00006C   12....       LCALL     ?XSTACK_DISP101_8
   \   00006F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1919          
   1920            return status;
   \   000072   A9..         MOV       R1,?V2
   \   000074   7412         MOV       A,#0x12
   \   000076   02....       LJMP      ?Subroutine6 & 0xFFFF
   1921          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   12....       LCALL     ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   00000C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00000F   7402         MOV       A,#0x2
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine142_0
   \   000003                ; // Fall through to label ??Subroutine142_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1922          
   1923          /******************************************************************************
   1924           * @fn          ZDSecMgrDeviceValidate
   1925           *
   1926           * @brief       Decide whether device is allowed.
   1927           *
   1928           * @param       device - [in] ZDSecMgrDevice_t, device info
   1929           *
   1930           * @return      ZStatus_t
   1931           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1932          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1933          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1934            ZStatus_t status;
   1935          
   1936          
   1937            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   701F         JNZ       ??ZDSecMgrDeviceValidate_0
   1938            {
   1939              // device may be joining with a secure flag but it is ultimately the Trust
   1940              // Center that decides -- check if expected pre configured device --
   1941              // override settings
   1942              if ( zgPreConfigKeys == TRUE )
   \   00000C   90....       MOV       DPTR,#zgPreConfigKeys
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   6401         XRL       A,#0x1
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   7004         JNZ       ??ZDSecMgrDeviceValidate_1
   1943              {
   1944                device->secure = TRUE;
   \   00001E   7401         MOV       A,#0x1
   \   000020   8001         SJMP      ??ZDSecMgrDeviceValidate_2
   1945              }
   1946              else
   1947              {
   1948                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000022   E4           CLR       A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000023   F0           MOVX      @DPTR,A
   1949              }
   1950          
   1951              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1952              {
   1953                status = ZDSecMgrDeviceValidateCM( device );
   1954              }
   1955              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1956              {
   1957                status = ZDSecMgrDeviceValidateRM( device );
   \   000024                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000024   12....       LCALL     `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000027   E9           MOV       A,R1
   \   000028   F9           MOV       R1,A
   \   000029   8002         SJMP      ??ZDSecMgrDeviceValidate_3
   1958              }
   1959            }
   1960            else
   1961            {
   1962              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV       R1,#-0x38
   1963            }
   1964          
   1965            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   1966          }
   1967          
   1968          /******************************************************************************
   1969           * @fn          ZDSecMgrDeviceJoin
   1970           *
   1971           * @brief       Try to join this device.
   1972           *
   1973           * @param       device - [in] ZDSecMgrDevice_t, device info
   1974           *
   1975           * @return      ZStatus_t
   1976           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1977          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   1978          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1979            ZStatus_t status;
   1980            uint16    ami;
   1981          
   1982            // attempt to validate device
   1983            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL     `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000011   E9           MOV       A,R1
   \   000012   F5..         MOV       ?V0,A
   1984          
   1985            if ( status == ZSuccess )
   \   000014   7025         JNZ       ??ZDSecMgrDeviceJoin_0
   1986            {
   1987              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1988              {
   1989                ZDSecMgrDeviceCtrlSetup( device );
   1990              }
   1991              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1992              {
   1993                // Add the device to the address manager
   1994                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   A8..         MOV       R0,?XSP + 0
   \   000018   A9..         MOV       R1,?XSP + 1
   \   00001A   88..         MOV       ?V0,R0
   \   00001C   89..         MOV       ?V1,R1
   \   00001E   78..         MOV       R0,#?V0
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
   1995                //send the nwk key data to the joining device
   1996                status = ZDSecMgrSendNwkKey( device );
   \   00002F                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00002F   EE           MOV       A,R6
   \   000030   FA           MOV       R2,A
   \   000031   EF           MOV       A,R7
   \   000032   FB           MOV       R3,A
   \   000033   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000036   E9           MOV       A,R1
   \   000037   F5..         MOV       ?V0,A
   \   000039   8007         SJMP      ??ZDSecMgrDeviceJoin_1
   1997              }
   1998            }
   1999            else
   2000            {
   2001              // not allowed, remove the device
   2002              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00003B                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00003B   EE           MOV       A,R6
   \   00003C   FA           MOV       R2,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FB           MOV       R3,A
   \   00003F   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2003            }
   2004          
   2005            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000042   A9..         MOV       R1,?V0
   \   000044   02....       LJMP      ?Subroutine0 & 0xFFFF
   2006          }
   2007          
   2008          /******************************************************************************
   2009           * @fn          ZDSecMgrDeviceJoinDirect
   2010           *
   2011           * @brief       Try to join this device as a direct child.
   2012           *
   2013           * @param       device - [in] ZDSecMgrDevice_t, device info
   2014           *
   2015           * @return      ZStatus_t
   2016           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2017          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2018          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2019            ZStatus_t status;
   2020          
   2021            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV       A,R1
   \   00000D   F5..         MOV       ?V0,A
   2022          
   2023            if ( status == ZSuccess )
   \   00000F   700D         JNZ       ??ZDSecMgrDeviceJoinDirect_0
   2024            {
   2025              // set association status to authenticated
   2026              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV       DPL,R6
   \   000013   8F83         MOV       DPH,R7
   \   000015   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   2027            }
   \                     ??CrossCallReturnLabel_224:
   \   000018   12....       LCALL     `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   00001B   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2028          
   2029            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV       R1,?V0
   \   000020   02....       LJMP      ??Subroutine127_0 & 0xFFFF
   2030          }
   2031          
   2032          /******************************************************************************
   2033           * @fn          ZDSecMgrDeviceJoinFwd
   2034           *
   2035           * @brief       Forward join to Trust Center.
   2036           *
   2037           * @param       device - [in] ZDSecMgrDevice_t, device info
   2038           *
   2039           * @return      ZStatus_t
   2040           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2041          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2042          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV       A,#-0x8
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2043            ZStatus_t               status;
   2044            APSME_UpdateDeviceReq_t req;
   2045          
   2046            // forward any joining device to the Trust Center -- the Trust Center will
   2047            // decide if the device is allowed to join
   2048            status = ZSuccess;
   2049          
   2050            // forward authorization to the Trust Center
   2051            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   F0           MOVX      @DPTR,A
   2052            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV       DPL,R2
   \   000015   8B83         MOV       DPH,R3
   \   000017   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   12....       LCALL     ?Subroutine16 & 0xFFFF
   2053            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_3:
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E8           MOV       A,R0
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   E9           MOV       A,R1
   \   000027   12....       LCALL     ?Subroutine24 & 0xFFFF
   2054          
   2055            // set security status, option for router to reject if policy set
   2056            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_28:
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   A2E7         MOV       C,0xE0 /* A   */.7
   \   00002D   502E         JNC       ??ZDSecMgrDeviceJoinFwd_0
   2057            {
   2058              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00002F   A2E6         MOV       C,0xE0 /* A   */.6
   \   000031   5021         JNC       ??ZDSecMgrDeviceJoinFwd_1
   2059              {
   2060                if ( device->secure == TRUE )
   \   000033   8A82         MOV       DPL,R2
   \   000035   8B83         MOV       DPH,R3
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   6401         XRL       A,#0x1
   \   000040   7009         JNZ       ??ZDSecMgrDeviceJoinFwd_2
   2061                {
   2062                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000042   7406         MOV       A,#0x6
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   7404         MOV       A,#0x4
   \   000049   803D         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2063                }
   2064                else
   2065                {
   2066                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004B   7406         MOV       A,#0x6
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   7407         MOV       A,#0x7
   \   000052   8034         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2067                }
   2068              }
   2069              else
   2070              {
   2071                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000054   7406         MOV       A,#0x6
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   7405         MOV       A,#0x5
   \   00005B   802B         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2072              }
   2073            }
   2074            else
   2075            {
   2076              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005D   A2E6         MOV       C,0xE0 /* A   */.6
   \   00005F   5020         JNC       ??ZDSecMgrDeviceJoinFwd_4
   2077              {
   2078                if ( device->secure == TRUE )
   \   000061   8A82         MOV       DPL,R2
   \   000063   8B83         MOV       DPH,R3
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   6401         XRL       A,#0x1
   \   00006E   7008         JNZ       ??ZDSecMgrDeviceJoinFwd_5
   2079                {
   2080                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000070   7406         MOV       A,#0x6
   \   000072   12....       LCALL     ?XSTACK_DISP0_8
   \   000075   E4           CLR       A
   \   000076   8010         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2081                }
   2082                else
   2083                {
   2084                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000078   7406         MOV       A,#0x6
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   7403         MOV       A,#0x3
   \   00007F   8007         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2085                }
   2086              }
   2087              else
   2088              {
   2089                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000081   7406         MOV       A,#0x6
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   7401         MOV       A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000088   F0           MOVX      @DPTR,A
   2090              }
   2091            }
   2092          
   2093            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2094            {
   2095              req.apsSecure = TRUE;
   2096            }
   2097            else
   2098            {
   2099              req.apsSecure = FALSE;
   \   000089   7407         MOV       A,#0x7
   \   00008B   12....       LCALL     ?XSTACK_DISP0_8
   \   00008E   E4           CLR       A
   \   00008F   12....       LCALL     ?Subroutine23 & 0xFFFF
   2100            }
   2101          
   2102            // send and APSME_UPDATE_DEVICE request to the trust center
   2103            status = APSME_UpdateDeviceReq( &req );
   2104          
   2105            return status;
   \                     ??CrossCallReturnLabel_23:
   \   000092   12....       LCALL     `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   000095   7408         MOV       A,#0x8
   \   000097   02....       LJMP      ??Subroutine112_0 & 0xFFFF
   2106          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000007   7404         MOV       A,#0x4
   \   000009   22           RET
   2107          
   2108          /******************************************************************************
   2109           * @fn          ZDSecMgrDeviceNew
   2110           *
   2111           * @brief       Process a new device.
   2112           *
   2113           * @param       device - [in] ZDSecMgrDevice_t, device info
   2114           *
   2115           * @return      ZStatus_t
   2116           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2117          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2118          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2119            ZStatus_t status;
   2120          
   2121            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2122            {
   2123              // try to join this device
   2124              status = ZDSecMgrDeviceJoinDirect( joiner );
   2125            }
   2126            else
   2127            {
   2128              status = ZDSecMgrDeviceJoinFwd( joiner );
   2129            }
   2130          
   2131            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL     `??ZDSecMgrDeviceJoinFwd::?relay`; Banked call to: ZDSecMgrDeviceJoinFwd
   \   000007   80..         SJMP      ??Subroutine124_0
   2132          }
   2133          
   2134          /******************************************************************************
   2135           * @fn          ZDSecMgrAssocDeviceAuth
   2136           *
   2137           * @brief       Set associated device status to authenticated
   2138           *
   2139           * @param       assoc - [in, out] associated_devices_t
   2140           *
   2141           * @return      none
   2142           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2143          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2144          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2145            if ( assoc != NULL )
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   600D         JZ        ??ZDSecMgrAssocDeviceAuth_0
   2146            {
   2147              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   D2E3         SETB      0xE0 /* A   */.3
   \   000014   F0           MOVX      @DPTR,A
   2148            }
   2149          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP      ??Subroutine124_0
   2150          
   2151          /******************************************************************************
   2152           * @fn          ZDSecMgrAuthInitiate
   2153           *
   2154           * @brief       Initiate entity authentication
   2155           *
   2156           * @param       responder - [in] responder EXT address
   2157           *
   2158           * @return      none
   2159           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2160          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2161          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2162            APSME_AuthenticateReq_t req;
   2163          
   2164          
   2165            // make sure NWK address is available
   2166            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000015   E9           MOV       A,R1
   \   000016   601F         JZ        ??ZDSecMgrAuthInitiate_0
   2167            {
   2168              // set request fields
   2169              req.extAddr   = responder;
   \   000018   7402         MOV       A,#0x2
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   EE           MOV       A,R6
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   A3           INC       DPTR
   \   000020   EF           MOV       A,R7
   \   000021   F0           MOVX      @DPTR,A
   2170              req.action    = APSME_EA_INITIATE;
   \   000022   7406         MOV       A,#0x6
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E4           CLR       A
   \   000028   F0           MOVX      @DPTR,A
   2171              req.challenge = NULL;
   \   000029   7404         MOV       A,#0x4
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ?Subroutine23 & 0xFFFF
   2172          
   2173              // start EA processing
   2174              APSME_AuthenticateReq( &req );
   2175            }
   \                     ??CrossCallReturnLabel_24:
   \   000034   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   2176          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000037   7407         MOV       A,#0x7
   \   000039   80..         SJMP      ??Subroutine126_0
   2177          
   2178          /******************************************************************************
   2179           * @fn          ZDSecMgrAuthNwkKey
   2180           *
   2181           * @brief       Handle next step in authentication process
   2182           *
   2183           * @param       none
   2184           *
   2185           * @return      none
   2186           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2187          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2188          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2189            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV       DPTR,#devState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   700C         JNZ       ??ZDSecMgrAuthNwkKey_0
   2190            {
   2191              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2192              {
   2193                uint8 parent[Z_EXTADDR_LEN];
   2194          
   2195                // get parent's EXT address
   2196                NLME_GetCoordExtAddr( parent );
   2197          
   2198                // begin entity authentication with parent
   2199                ZDSecMgrAuthInitiate( parent );
   2200              }
   2201              else
   2202              {
   2203                // inform ZDO that device has been authenticated
   2204                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV       R2,#-0x80
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   90....       MOV       DPTR,#ZDAppTaskID
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   2205              }
   2206            }
   2207          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   2208          
   2209          /******************************************************************************
   2210           * PUBLIC FUNCTIONS
   2211           */
   2212          /******************************************************************************
   2213           * @fn          ZDSecMgrInit
   2214           *
   2215           * @brief       Initialize ZigBee Device Security Manager.
   2216           *
   2217           * @param       state - device initialization state
   2218           *
   2219           * @return      none
   2220           */
   2221          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2222          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2223          void ZDSecMgrAddrMgrCB( uint8           update,
   2224                                  AddrMgrEntry_t* newEntry,
   2225                                  AddrMgrEntry_t* oldEntry )
   2226          {
   2227            (void)update;
   2228            (void)newEntry;
   2229            (void)oldEntry;
   2230          }
   2231          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2232          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL     `??APSME_SecurityNM::?relay`; Banked call to: APSME_SecurityNM
   \   000007                REQUIRE ??Subroutine124_0
   \   000007                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2233          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000   02....       LJMP      ?Subroutine4 & 0xFFFF
   2234          {
   2235            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2236                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2237            {
   2238              // initialize sub modules
   2239              ZDSecMgrEntryInit(state);
   2240          
   2241              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2242              {
   2243                ZDSecMgrCtrlInit();
   2244              }
   2245          
   2246              // register with Address Manager
   2247          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2248              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2249          #endif
   2250            }
   2251          
   2252            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2253            {
   2254              // configure SKA slot data
   2255              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2256            }
   2257          
   2258            if ( ZG_SECURE_ENABLED )
   2259            {
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                // setup joining permissions
   2263                ZDSecMgrPermitJoiningEnabled = TRUE;
   2264                ZDSecMgrPermitJoiningTimed   = FALSE;
   2265              }
   2266            }
   2267          
   2268            // configure security based on security mode and type of device
   2269            ZDSecMgrConfig();
   2270          }
   2271          
   2272          /******************************************************************************
   2273           * @fn          ZDSecMgrConfig
   2274           *
   2275           * @brief       Configure ZigBee Device Security Manager.
   2276           *
   2277           * @param       none
   2278           *
   2279           * @return      none
   2280           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2281          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   02....       LJMP      ?Subroutine4 & 0xFFFF
   2282          {
   2283            if ( ZG_SECURE_ENABLED )
   2284            {
   2285              SSP_Init();
   2286          
   2287              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2288                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2289              {
   2290                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2291                {
   2292                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2293                  APSME_SecurityCM_CD();
   2294                }
   2295                else if ( ZSTACK_ROUTER_BUILD )
   2296                {
   2297                  // COMMERCIAL MODE - ROUTER DEVICE
   2298                  APSME_SecurityCM_RD();
   2299                }
   2300                else
   2301                {
   2302                  // COMMERCIAL MODE - END DEVICE
   2303                  APSME_SecurityCM_ED();
   2304                }
   2305              }
   2306              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2307              {
   2308                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2309                {
   2310                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2311                  APSME_SecurityRM_CD();
   2312                }
   2313                else if ( ZSTACK_ROUTER_BUILD )
   2314                {
   2315                  // RESIDENTIAL MODE - ROUTER DEVICE
   2316                  APSME_SecurityRM_RD();
   2317                }
   2318                else
   2319                {
   2320                  // RESIDENTIAL MODE - END DEVICE
   2321                  APSME_SecurityRM_ED();
   2322                }
   2323              }
   2324            }
   2325            else
   2326            {
   2327              // NO SECURITY
   2328              APSME_SecurityNM();
   2329            }
   2330          }
   2331          
   2332          /******************************************************************************
   2333           * @fn          ZDSecMgrPermitJoining
   2334           *
   2335           * @brief       Process request to change joining permissions.
   2336           *
   2337           * @param       duration - [in] timed duration for join in seconds
   2338           *                         - 0x00 not allowed
   2339           *                         - 0xFF allowed without timeout
   2340           *
   2341           * @return      uint8 - success(TRUE:FALSE)
   2342           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2343          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2344          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
   2345            uint8 accept;
   2346          
   2347            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   2348          
   2349            if ( duration > 0 )
   \   00000B   E9           MOV       A,R1
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ        ??ZDSecMgrPermitJoining_0
   2350            {
   2351              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV       A,#0x1
   \   000013   F0           MOVX      @DPTR,A
   2352          
   2353              if ( duration != 0xFF )
   \   000014   74FF         MOV       A,#-0x1
   \   000016   68           XRL       A,R0
   \   000017   6009         JZ        ??ZDSecMgrPermitJoining_1
   2354              {
   2355                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV       A,#0x1
   \   00001E   8001         SJMP      ??ZDSecMgrPermitJoining_2
   2356              }
   2357            }
   2358            else
   2359            {
   2360              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR       A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX      @DPTR,A
   2361            }
   2362          
   2363            accept = TRUE;
   2364          
   2365            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV       R1,#0x1
   \   000024   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   2366          }
   2367          
   2368          /******************************************************************************
   2369           * @fn          ZDSecMgrPermitJoiningTimeout
   2370           *
   2371           * @brief       Process permit joining timeout
   2372           *
   2373           * @param       none
   2374           *
   2375           * @return      none
   2376           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2377          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2378          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2379            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7009         JNZ       ??ZDSecMgrPermitJoiningTimeout_0
   2380            {
   2381              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   2382              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX      @DPTR,A
   2383            }
   2384          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   2385          
   2386          /******************************************************************************
   2387           * @fn          ZDSecMgrNewDeviceEvent
   2388           *
   2389           * @brief       Process a the new device event, if found reset new device
   2390           *              event/timer.
   2391           *
   2392           * @param       none
   2393           *
   2394           * @return      uint8 - found(TRUE:FALSE)
   2395           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2396          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2397          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2398            uint8                 found;
   2399            ZDSecMgrDevice_t      device;
   2400            AddrMgrEntry_t        addrEntry;
   2401            associated_devices_t* assoc;
   2402            ZStatus_t             status;
   2403          
   2404            // initialize return results
   2405            found = FALSE;
   \   00000A   75..00       MOV       ?V0,#0x0
   2406          
   2407            // look for device in the security init state
   2408            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV       R1,#0x4
   \   00000F   12....       LCALL     `??AssocMatchDeviceStatus::?relay`; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV       ?V2,R2
   \   000014   8B..         MOV       ?V3,R3
   \   000016   AE..         MOV       R6,?V2
   \   000018   AF..         MOV       R7,?V3
   2409          
   2410            if ( assoc != NULL )
   \   00001A   EA           MOV       A,R2
   \   00001B   4F           ORL       A,R7
   \   00001C   7003         JNZ       $+5
   \   00001E   02....       LJMP      ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2411            {
   2412              // device found
   2413              found = TRUE;
   \   000021   75..01       MOV       ?V0,#0x1
   2414          
   2415              // check for preconfigured security
   2416              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV       DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6401         XRL       A,#0x1
   \   00002A   7003         JNZ       ??ZDSecMgrNewDeviceEvent_1
   2417              {
   2418                // set association status to authenticated
   2419                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2420              }
   2421          
   2422              // set up device info
   2423              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV       A,#0xa
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E4           CLR       A
   \   000035   12....       LCALL     ??Subroutine131_0 & 0xFFFF
   2424              addrEntry.index = assoc->addrIdx;
   \                     ??CrossCallReturnLabel_260:
   \   000038   7415         MOV       A,#0x15
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine18 & 0xFFFF
   2425              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_7:
   \   000040   12....       LCALL     ?XSTACK_DISP101_8
   \   000043   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2426          
   2427              device.nwkAddr    = assoc->shortAddr;
   \   000046   8E82         MOV       DPL,R6
   \   000048   8F83         MOV       DPH,R7
   \   00004A   12....       LCALL     ?Subroutine33 & 0xFFFF
   2428              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_235:
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   A882         MOV       R0,DPL
   \   000052   A983         MOV       R1,DPH
   \   000054   7402         MOV       A,#0x2
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   2429              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_197:
   \   00005C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00005C   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00005F   7404         MOV       A,#0x4
   \   000061   12....       LCALL     ?XSTACK_DISP0_8
   \   000064   12....       LCALL     ??Subroutine129_0 & 0xFFFF
   2430              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_247:
   \   000067   7406         MOV       A,#0x6
   \   000069   12....       LCALL     ?XSTACK_DISP0_8
   \   00006C   E4           CLR       A
   \   00006D   F0           MOVX      @DPTR,A
   2431              device.devStatus  = assoc->devStatus;
   \   00006E   8E82         MOV       DPL,R6
   \   000070   8F83         MOV       DPH,R7
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   E0           MOVX      A,@DPTR
   \   000078   C0E0         PUSH      A
   \   00007A   7407         MOV       A,#0x7
   \   00007C   12....       LCALL     ?XSTACK_DISP0_8
   \   00007F   D0E0         POP       A
   \   000081   12....       LCALL     ?Subroutine23 & 0xFFFF
   2432          
   2433              // process new device
   2434              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_25:
   \   000084   12....       LCALL     `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   000087   E9           MOV       A,R1
   \   000088   F8           MOV       R0,A
   2435          
   2436              if ( status == ZSuccess )
   \   000089   700F         JNZ       ??ZDSecMgrNewDeviceEvent_2
   2437              {
   2438                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   00008B   8E82         MOV       DPL,R6
   \   00008D   8F83         MOV       DPH,R7
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   E0           MOVX      A,@DPTR
   \   000095   C2E2         CLR       0xE0 /* A   */.2
   \   000097   F0           MOVX      @DPTR,A
   \   000098   8011         SJMP      ??ZDSecMgrNewDeviceEvent_0
   2439              }
   2440              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00009A   74C8         MOV       A,#-0x38
   \   00009C   68           XRL       A,R0
   \   00009D   700C         JNZ       ??ZDSecMgrNewDeviceEvent_0
   2441              {
   2442                AssocRemove( addrEntry.extAddr );
   \   00009F                ; Setup parameters for call to function AssocRemove
   \   00009F   740D         MOV       A,#0xd
   \   0000A1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A4   AA82         MOV       R2,DPL
   \   0000A6   AB83         MOV       R3,DPH
   \   0000A8   12....       LCALL     `??AssocRemove::?relay`; Banked call to: AssocRemove
   2443              }
   2444            }
   2445          
   2446            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000AB   A9..         MOV       R1,?V0
   \   0000AD   7417         MOV       A,#0x17
   \   0000AF   02....       LJMP      ?Subroutine6 & 0xFFFF
   2447          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000003                REQUIRE ??Subroutine128_0
   \   000003                ; // Fall through to label ??Subroutine128_0
   2448          
   2449          /******************************************************************************
   2450           * @fn          ZDSecMgrEvent
   2451           *
   2452           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2453           *
   2454           * @param       none
   2455           *
   2456           * @return      none
   2457           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2458          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2459          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2460            uint8            action;
   2461            uint8            restart;
   2462            uint16           index;
   2463            AddrMgrEntry_t   entry;
   2464            ZDSecMgrDevice_t device;
   2465          
   2466            // verify data is available
   2467            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??ZDSecMgrEvent_0 & 0xFFFF
   2468            {
   2469              action  = FALSE;
   \   000015   75..00       MOV       ?V0,#0x0
   2470              restart = FALSE;
   \   000018   75..00       MOV       ?V1,#0x0
   2471          
   2472              // update all the counters
   2473              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV       R6,#0x0
   \   00001D   7F00         MOV       R7,#0x0
   2474              {
   2475                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   EE           MOV       A,R6
   \   000020   F8           MOV       R0,A
   \   000021   EF           MOV       A,R7
   \   000022   F9           MOV       R1,A
   \   000023   E8           MOV       A,R0
   \   000024   75F007       MOV       B,#0x7
   \   000027   A4           MUL       AB
   \   000028   F8           MOV       R0,A
   \   000029   AAF0         MOV       R2,B
   \   00002B   75F007       MOV       B,#0x7
   \   00002E   E9           MOV       A,R1
   \   00002F   A4           MUL       AB
   \   000030   2A           ADD       A,R2
   \   000031   F9           MOV       R1,A
   \   000032   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000035   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000038   A3           INC       DPTR
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   7003         JNZ       $+5
   \   00003C   02....       LJMP      ??ZDSecMgrEvent_2 & 0xFFFF
   2476                {
   2477                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00003F   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000042   6005         JZ        ??ZDSecMgrEvent_3
   2478                  {
   2479                    ZDSecMgrCtrlData[index].cntr--;
   \   000044   12....       LCALL     ?Subroutine44 & 0xFFFF
   2480                  }
   \                     ??CrossCallReturnLabel_59:
   \   000047   14           DEC       A
   \   000048   F0           MOVX      @DPTR,A
   2481          
   2482                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000049   E5..         MOV       A,?V0
   \   00004B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004D   4073         JC        ??ZDSecMgrEvent_4
   \   00004F   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000052   706E         JNZ       ??ZDSecMgrEvent_4
   2483                  {
   2484                    action = TRUE;
   \   000054   75..01       MOV       ?V0,#0x1
   \   000057   EE           MOV       A,R6
   \   000058   F8           MOV       R0,A
   \   000059   EF           MOV       A,R7
   \   00005A   F9           MOV       R1,A
   \   00005B   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00005E   F9           MOV       R1,A
   \   00005F   8882         MOV       DPL,R0
   \   000061   F583         MOV       DPH,A
   \   000063   12....       LCALL     ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000066   7404         MOV       A,#0x4
   \   000068   12....       LCALL     ?XSTACK_DISP0_8
   \   00006B   12....       LCALL     ??Subroutine129_0 & 0xFFFF
   2485          
   2486                    // update from control data
   2487                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2488                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_248:
   \   00006E   8882         MOV       DPL,R0
   \   000070   8983         MOV       DPH,R1
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   C0E0         PUSH      A
   \   000079   7406         MOV       A,#0x6
   \   00007B   12....       LCALL     ?XSTACK_DISP0_8
   \   00007E   D0E0         POP       A
   \   000080   F0           MOVX      @DPTR,A
   2489                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000081   7408         MOV       A,#0x8
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   12....       LCALL     ?Subroutine18 & 0xFFFF
   2490          
   2491                    // set the user and address index
   2492                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_8:
   \   000089   12....       LCALL     ?XSTACK_DISP0_8
   \   00008C   7402         MOV       A,#0x2
   \   00008E   12....       LCALL     ?Subroutine35 & 0xFFFF
   2493                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_45:
   \   000091   F583         MOV       DPH,A
   \   000093   8882         MOV       DPL,R0
   \   000095   12....       LCALL     ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000098   7415         MOV       A,#0x15
   \   00009A   12....       LCALL     ?XSTACK_DISP0_8
   \   00009D   12....       LCALL     ?Subroutine18 & 0xFFFF
   2494          
   2495                    // get the address data
   2496                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_9:
   \   0000A0   12....       LCALL     ?XSTACK_DISP101_8
   \   0000A3   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2497          
   2498                    // set device address data
   2499                    device.nwkAddr = entry.nwkAddr;
   \   0000A6   740B         MOV       A,#0xb
   \   0000A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AB   12....       LCALL     ?Subroutine33 & 0xFFFF
   2500                    device.extAddr = entry.extAddr;
   2501          
   2502                    // update from entry data
   2503                    ZDSecMgrDeviceCtrlHandler( &device );
   2504                  }
   \                     ??CrossCallReturnLabel_236:
   \   0000AE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B1   A882         MOV       R0,DPL
   \   0000B3   A983         MOV       R1,DPH
   \   0000B5   7402         MOV       A,#0x2
   \   0000B7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BA   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000BD   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   0000C0   8003         SJMP      ??ZDSecMgrEvent_2
   2505                  else
   2506                  {
   2507                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000C2   75..01       MOV       ?V1,#0x1
   2508                  }
   2509                }
   2510              }
   \                     ??ZDSecMgrEvent_2:
   \   0000C5   0E           INC       R6
   \   0000C6   EE           MOV       A,R6
   \   0000C7   7001         JNZ       ??ZDSecMgrEvent_5
   \   0000C9   0F           INC       R7
   \                     ??ZDSecMgrEvent_5:
   \   0000CA   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000CD   5003         JNC       $+5
   \   0000CF   02....       LJMP      ??ZDSecMgrEvent_1 & 0xFFFF
   2511          
   2512              // check for timer restart
   2513              if ( restart == TRUE )
   \   0000D2   E5..         MOV       A,?V1
   \   0000D4   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000D6   5010         JNC       ??ZDSecMgrEvent_0
   2514              {
   2515                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000D8                ; Setup parameters for call to function osal_start_timerEx
   \   0000D8   7C64         MOV       R4,#0x64
   \   0000DA   7D00         MOV       R5,#0x0
   \   0000DC   7A00         MOV       R2,#0x0
   \   0000DE   7B01         MOV       R3,#0x1
   \   0000E0   90....       MOV       DPTR,#ZDAppTaskID
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   F9           MOV       R1,A
   \   0000E5   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   2516              }
   2517            }
   2518          }
   \                     ??ZDSecMgrEvent_0:
   \   0000E8   7417         MOV       A,#0x17
   \   0000EA   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   EE           MOV       A,R6
   \   000001   F8           MOV       R0,A
   \   000002   EF           MOV       A,R7
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   75F007       MOV       B,#0x7
   \   000008   A4           MUL       AB
   \   000009   F8           MOV       R0,A
   \   00000A   AAF0         MOV       R2,B
   \   00000C   75F007       MOV       B,#0x7
   \   00000F   E9           MOV       A,R1
   \   000010   A4           MUL       AB
   \   000011   2A           ADD       A,R2
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000016   12....       LCALL     ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004                REQUIRE ??Subroutine133_0
   \   000004                ; // Fall through to label ??Subroutine133_0
   2519          
   2520          /******************************************************************************
   2521           * @fn          ZDSecMgrEstablishKeyCfm
   2522           *
   2523           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2524           *
   2525           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2526           *
   2527           * @return      none
   2528           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2529          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2530          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2531            // send the NWK key
   2532            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2533            {
   2534              // update control for specified EXT address
   2535              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2536            }
   2537            else
   2538            {
   2539              // this should be done when receiving the NWK key
   2540              // if devState ==
   2541              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2542                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2543          
   2544              // if not in joining state -- this should trigger an event for an
   2545              // end point that requested SKKE
   2546              // if ( devState == DEV_END_DEVICE )
   2547             //       devState == DEV_ROUTER;
   2548          
   2549            }
   2550          }
   \   000000   02....       LJMP      ?BRET
   2551          
   2552          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2553          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2554          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2555            uint8  match;
   2556            uint8  lookup[Z_EXTADDR_LEN];
   2557          
   2558            match = FALSE;
   \   00000E   75..00       MOV       ?V0,#0x0
   2559          
   2560            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV       R4,?XSP + 0
   \   000013   AD..         MOV       R5,?XSP + 1
   \   000015   7A00         MOV       R2,#0x0
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV       A,R1
   \   00001D   600E         JZ        ??ZDSecMgrTCExtAddrCheck_0
   2561            {
   2562              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV       A,R6
   \   000020   FC           MOV       R4,A
   \   000021   EF           MOV       A,R7
   \   000022   FD           MOV       R5,A
   \   000023   AA..         MOV       R2,?XSP + 0
   \   000025   AB..         MOV       R3,?XSP + 1
   \   000027   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV       A,R1
   \   00002B   F5..         MOV       ?V0,A
   2563            }
   2564          
   2565            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV       R1,?V0
   \   00002F   7408         MOV       A,#0x8
   \   000031   02....       LJMP      ??Subroutine126_0 & 0xFFFF
   2566          }
   2567          
   2568          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2569          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2570          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2571            uint16 ami;
   2572            uint16 keyNvId;
   2573            uint8 masterKey[SEC_KEY_LEN];
   2574          
   2575            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   706B         JNZ       ??ZDSecMgrTCDataLoad_0
   2576            {
   2577              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V0,R0
   \   000016   89..         MOV       ?V1,R1
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   EA           MOV       A,R2
   \   00001E   FC           MOV       R4,A
   \   00001F   EB           MOV       A,R3
   \   000020   FD           MOV       R5,A
   \   000021   7A00         MOV       R2,#0x0
   \   000023   7B00         MOV       R3,#0x0
   \   000025   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002D   E9           MOV       A,R1
   \   00002E   7045         JNZ       ??ZDSecMgrTCDataLoad_1
   2578              {
   2579                // if preconfigured load key
   2580                if ( zgPreConfigKeys == TRUE )
   \   000030   90....       MOV       DPTR,#zgPreConfigKeys
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6401         XRL       A,#0x1
   \   000036   703D         JNZ       ??ZDSecMgrTCDataLoad_1
   2581                {
   2582                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000038   7402         MOV       A,#0x2
   \   00003A   12....       LCALL     ?XSTACK_DISP102_8
   \   00003D   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000040   6033         JZ        ??ZDSecMgrTCDataLoad_1
   2583                  {
   2584                    // temporary copy
   2585                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000042                ; Setup parameters for call to function osal_memcpy
   \   000042   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000045   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000048   75..80       MOV       ?V2,#-0x80
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000050   7C10         MOV       R4,#0x10
   \   000052   7D00         MOV       R5,#0x0
   \   000054   7407         MOV       A,#0x7
   \   000056   12....       LCALL     ?XSTACK_DISP101_8
   \   000059   12....       LCALL     ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   00005C   12....       LCALL     ?DEALLOC_XSTACK8
   2586          
   2587                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   00005F                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00005F   7404         MOV       A,#0x4
   \   000061   12....       LCALL     ?XSTACK_DISP102_8
   \   000064   12....       LCALL     ?Subroutine66 & 0xFFFF
   2588          
   2589                    // remove copy of key in RAM
   2590                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \                     ??CrossCallReturnLabel_94:
   \   000067                ; Setup parameters for call to function osal_memset
   \   000067   7C10         MOV       R4,#0x10
   \   000069   7D00         MOV       R5,#0x0
   \   00006B   7900         MOV       R1,#0x0
   \   00006D   7404         MOV       A,#0x4
   \   00006F   12....       LCALL     ?XSTACK_DISP101_8
   \   000072   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2591                  }
   2592                }
   2593              }
   2594          
   2595              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000075   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   000078   7401         MOV       A,#0x1
   \   00007A   F0           MOVX      @DPTR,A
   2596            }
   2597          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00007B   7414         MOV       A,#0x14
   \   00007D   02....       LJMP      ?Subroutine5 & 0xFFFF
   2598          
   2599          /******************************************************************************
   2600           * @fn          ZDSecMgrEstablishKeyInd
   2601           *
   2602           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2603           *
   2604           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2605           *
   2606           * @return      none
   2607           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2608          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2609          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV       A,#-0x11
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2610            ZDSecMgrDevice_t        device;
   2611            APSME_EstablishKeyRsp_t rsp;
   2612          
   2613          
   2614            // load Trust Center data if needed
   2615            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EA           MOV       A,R2
   \   00000F   2404         ADD       A,#0x4
   \   000011   F5..         MOV       ?V0,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F5..         MOV       ?V1,A
   \   000017                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000017   AA..         MOV       R2,?V0
   \   000019   FB           MOV       R3,A
   \   00001A   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2616          
   2617            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001D                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00001D   AA..         MOV       R2,?V0
   \   00001F   AB..         MOV       R3,?V1
   \   000021   12....       LCALL     `??ZDSecMgrTCExtAddrCheck::?relay`; Banked call to: ZDSecMgrTCExtAddrCheck
   \   000024   E9           MOV       A,R1
   \   000025   6013         JZ        ??ZDSecMgrEstablishKeyInd_0
   2618            {
   2619              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2620              //OR
   2621              //!ZDSecMgrTCAuthenticated
   2622              //devtag.0604.critical
   2623                  //how is the parentAddr used here
   2624          
   2625              // initial SKKE from Trust Center via parent
   2626              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000027   7407         MOV       A,#0x7
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   12....       LCALL     ?Subroutine12 & 0xFFFF
   2627              device.parentAddr = ind->srcAddr;
   2628            }
   \                     ??CrossCallReturnLabel_258:
   \   00002F   740B         MOV       A,#0xb
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E8           MOV       A,R0
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E9           MOV       A,R1
   \   000038   8015         SJMP      ??ZDSecMgrEstablishKeyInd_1
   2629            else
   2630            {
   2631              // Trust Center direct or E2E SKKE
   2632              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00003A   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   00003D   7407         MOV       A,#0x7
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   2633              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_198:
   \   000045   740B         MOV       A,#0xb
   \   000047   12....       LCALL     ?XSTACK_DISP0_8
   \   00004A   74FE         MOV       A,#-0x2
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   04           INC       A
   2634            }
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   00004F   12....       LCALL     ?Subroutine86 & 0xFFFF
   2635          
   2636            device.extAddr = ind->initExtAddr;
   \                     ??CrossCallReturnLabel_255:
   \   000052   7409         MOV       A,#0x9
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   E8           MOV       A,R0
   \   000058   F0           MOVX      @DPTR,A
   \   000059   A3           INC       DPTR
   \   00005A   E9           MOV       A,R1
   \   00005B   12....       LCALL     ?Subroutine26 & 0xFFFF
   2637            //devtag.pro.security.0724.todo - verify usage
   2638            device.secure  = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_31:
   \   00005E   C0E0         PUSH      A
   \   000060   740D         MOV       A,#0xd
   \   000062   12....       LCALL     ?XSTACK_DISP0_8
   \   000065   D0E0         POP       A
   \   000067   F0           MOVX      @DPTR,A
   2639          
   2640            // validate device for SKKE
   2641            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000068                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000068   7407         MOV       A,#0x7
   \   00006A   12....       LCALL     ?XSTACK_DISP101_8
   \   00006D   12....       LCALL     `??ZDSecMgrDeviceValidateSKKE::?relay`; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   000070   E9           MOV       A,R1
   \   000071   7009         JNZ       ??ZDSecMgrEstablishKeyInd_2
   2642            {
   2643              rsp.accept = TRUE;
   \   000073   7404         MOV       A,#0x4
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   7401         MOV       A,#0x1
   \   00007A   8006         SJMP      ??ZDSecMgrEstablishKeyInd_3
   2644            }
   2645            else
   2646            {
   2647              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00007C   7404         MOV       A,#0x4
   \   00007E   12....       LCALL     ?XSTACK_DISP0_8
   \   000081   E4           CLR       A
   2648            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000082   12....       LCALL     ??Subroutine131_0 & 0xFFFF
   2649          
   2650            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_261:
   \   000085   12....       LCALL     ?Subroutine17 & 0xFFFF
   2651            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_252:
   \   000088   12....       LCALL     ?XSTACK_DISP0_8
   \   00008B   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   2652            //devtag.0604.todo - remove obsolete
   2653            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_199:
   \   00008E   EE           MOV       A,R6
   \   00008F   240D         ADD       A,#0xd
   \   000091   F582         MOV       DPL,A
   \   000093   E4           CLR       A
   \   000094   3F           ADDC      A,R7
   \   000095   F583         MOV       DPH,A
   \   000097   E0           MOVX      A,@DPTR
   \   000098   C0E0         PUSH      A
   \   00009A   7405         MOV       A,#0x5
   \   00009C   12....       LCALL     ?XSTACK_DISP0_8
   \   00009F   D0E0         POP       A
   \   0000A1   12....       LCALL     ?Subroutine26 & 0xFFFF
   2654            rsp.nwkSecure   = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_32:
   \   0000A4   C0E0         PUSH      A
   \   0000A6   7406         MOV       A,#0x6
   \   0000A8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AB   D0E0         POP       A
   \   0000AD   12....       LCALL     ?Subroutine23 & 0xFFFF
   2655          
   2656            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_26:
   \   0000B0   12....       LCALL     `??APSME_EstablishKeyRsp::?relay`; Banked call to: APSME_EstablishKeyRsp
   2657          }
   \   0000B3   7411         MOV       A,#0x11
   \   0000B5   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   EE           MOV       A,R6
   \   000002   240E         ADD       A,#0xe
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   3F           ADDC      A,R7
   \   000008   F583         MOV       DPH,A
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   E8           MOV       A,R0
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   E9           MOV       A,R1
   \   00000A                REQUIRE ??Subroutine130_0
   \   00000A                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   EE           MOV       A,R6
   \   000002   2404         ADD       A,#0x4
   \   000004   F8           MOV       R0,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F9           MOV       R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine143_0
   \   000004                ; // Fall through to label ??Subroutine143_0
   2658          
   2659          //devtag.pro.security
   2660          #if 0
   2661          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2662          {
   2663            ZDSecMgrDevice_t        device;
   2664            APSME_EstablishKeyRsp_t rsp;
   2665          
   2666          
   2667            device.extAddr = ind->initExtAddr;
   2668            device.secure  = ind->secure;
   2669          
   2670            if ( ind->secure == FALSE )
   2671            {
   2672              // SKKE from Trust Center is not secured between child and parent
   2673              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2674              device.parentAddr = ind->srcAddr;
   2675            }
   2676            else
   2677            {
   2678              // SKKE from initiator should be secured
   2679              device.nwkAddr    = ind->srcAddr;
   2680              device.parentAddr = INVALID_NODE_ADDR;
   2681            }
   2682          
   2683            rsp.dstAddr     = ind->srcAddr;
   2684            rsp.initExtAddr = &ind->initExtAddr[0];
   2685            rsp.secure      = ind->secure;
   2686          
   2687            // validate device for SKKE
   2688            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2689            {
   2690              rsp.accept = TRUE;
   2691            }
   2692            else
   2693            {
   2694              rsp.accept = FALSE;
   2695            }
   2696          
   2697            APSME_EstablishKeyRsp( &rsp );
   2698          }
   2699          #endif
   2700          
   2701          /******************************************************************************
   2702           * @fn          ZDSecMgrTransportKeyInd
   2703           *
   2704           * @brief       Process the ZDO_TransportKeyInd_t message.
   2705           *
   2706           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2707           *
   2708           * @return      none
   2709           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2710          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2711          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2712            uint8 index;
   2713            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2714          
   2715            // load Trust Center data if needed
   2716            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EA           MOV       A,R2
   \   00000F   2416         ADD       A,#0x16
   \   000011   FA           MOV       R2,A
   \   000012   E4           CLR       A
   \   000013   3F           ADDC      A,R7
   \   000014   FB           MOV       R3,A
   \   000015   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2717          
   2718            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000018   8E82         MOV       DPL,R6
   \   00001A   8F83         MOV       DPH,R7
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   7003         JNZ       $+5
   \   000023   02....       LJMP      ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2719            {
   2720              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2721              //ZDSecMgrTCMasterKey( ind );
   2722              {
   2723                if ( zgPreConfigKeys != TRUE )
   2724                {
   2725                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2726                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2727                }
   2728                else
   2729                {
   2730                  // error condition - reject key
   2731                }
   2732              }
   2733            }
   2734            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2735                      ( ind->keyType == 6                 ) ||
   2736                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000026   6401         XRL       A,#0x1
   \   000028   601A         JZ        ??ZDSecMgrTransportKeyInd_1
   \   00002A   8E82         MOV       DPL,R6
   \   00002C   8F83         MOV       DPH,R7
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   6406         XRL       A,#0x6
   \   000035   600D         JZ        ??ZDSecMgrTransportKeyInd_1
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   6405         XRL       A,#0x5
   \   000042   7077         JNZ       ??ZDSecMgrTransportKeyInd_0
   2737            {
   2738              // check for dummy NWK key (all zeros)
   2739              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000044   7800         MOV       R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000046   E8           MOV       A,R0
   \   000047   FA           MOV       R2,A
   \   000048   EE           MOV       A,R6
   \   000049   2A           ADD       A,R2
   \   00004A   F582         MOV       DPL,A
   \   00004C   E4           CLR       A
   \   00004D   3F           ADDC      A,R7
   \   00004E   F583         MOV       DPH,A
   \   000050   A3           INC       DPTR
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   E0           MOVX      A,@DPTR
   \   000057   7007         JNZ       ??ZDSecMgrTransportKeyInd_3
   2740                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2741                    index++ );
   \   000059   08           INC       R0
   \   00005A   E8           MOV       A,R0
   \   00005B   C3           CLR       C
   \   00005C   9410         SUBB      A,#0x10
   \   00005E   40E6         JC        ??ZDSecMgrTransportKeyInd_2
   2742          
   2743              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000060   7410         MOV       A,#0x10
   \   000062   68           XRL       A,R0
   \   000063   702E         JNZ       ??ZDSecMgrTransportKeyInd_4
   2744              {
   2745                // load preconfigured key - once!!
   2746                if ( !_NIB.nwkKeyLoaded )
   \   000065   90....       MOV       DPTR,#_NIB + 61
   \   000068   E0           MOVX      A,@DPTR
   \   000069   704D         JNZ       ??ZDSecMgrTransportKeyInd_5
   2747                {
   2748                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00006B                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00006B   AC..         MOV       R4,?XSP + 0
   \   00006D   AD..         MOV       R5,?XSP + 1
   \   00006F   7A62         MOV       R2,#0x62
   \   000071   7B00         MOV       R3,#0x0
   \   000073   12....       LCALL     `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   2749                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000076                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000076   7900         MOV       R1,#0x0
   \   000078   AA..         MOV       R2,?XSP + 0
   \   00007A   AB..         MOV       R3,?XSP + 1
   \   00007C   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2750                  SSP_SwitchNwkKey( 0 );
   \   00007F                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007F   7900         MOV       R1,#0x0
   \   000081   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2751          
   2752                  // clear local copy of key
   2753                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000084                ; Setup parameters for call to function osal_memset
   \   000084   7C10         MOV       R4,#0x10
   \   000086   7D00         MOV       R5,#0x0
   \   000088   7900         MOV       R1,#0x0
   \   00008A   AA..         MOV       R2,?XSP + 0
   \   00008C   AB..         MOV       R3,?XSP + 1
   \   00008E   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   000091   8025         SJMP      ??ZDSecMgrTransportKeyInd_5
   2754                }
   2755              }
   2756              else
   2757              {
   2758                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000093                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000093   8E82         MOV       DPL,R6
   \   000095   8F83         MOV       DPH,R7
   \   000097   A3           INC       DPTR
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   F9           MOV       R1,A
   \   00009E   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   0000A1   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2759                if ( !_NIB.nwkKeyLoaded )
   \   0000A4   90....       MOV       DPTR,#_NIB + 61
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   700E         JNZ       ??ZDSecMgrTransportKeyInd_5
   2760                {
   2761                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000AA                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000AA   8E82         MOV       DPL,R6
   \   0000AC   8F83         MOV       DPH,R7
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   F9           MOV       R1,A
   \   0000B5   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2762                }
   2763              }
   2764          
   2765              // handle next step in authentication process
   2766              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000B8                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000B8   12....       LCALL     `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   2767            }
   2768            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2769            {
   2770              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2771              {
   2772                // This should not happen because TCLK should not be Tx
   2773              }
   2774            }
   2775            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2776            {
   2777              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2778              {
   2779                uint16           ami;
   2780                AddrMgrEntry_t   entry;
   2781                ZDSecMgrEntry_t* entryZD;
   2782          
   2783                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2784          
   2785                if ( ind->initiator == TRUE )
   2786                {
   2787                  // get the ami data
   2788                  entry.user  = ADDRMGR_USER_SECURITY;
   2789                  entry.index = ami;
   2790                  AddrMgrEntryGet( &entry );
   2791          
   2792                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2793                  {
   2794                    APSME_EstablishKeyReq_t req;
   2795                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2796          
   2797                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2798          
   2799                    if ( entryZD == NULL )
   2800                    {
   2801                      // get new entry
   2802                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2803                      {
   2804                        // finish setting up entry
   2805                        entryZD->ami = ami;
   2806                      }
   2807                    }
   2808          
   2809                    req.respExtAddr = ind->srcExtAddr;
   2810                    req.method      = APSME_SKKE_METHOD;
   2811                    req.dstAddr     = entry.nwkAddr;
   2812                    req.apsSecure   = FALSE;
   2813                    req.nwkSecure   = TRUE;
   2814                    APSME_EstablishKeyReq( &req );
   2815                  }
   2816                }
   2817                else
   2818                {
   2819                  if ( ami == INVALID_NODE_ADDR )
   2820                  {
   2821                    // store new EXT address
   2822                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2823                  }
   2824          
   2825                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2826                }
   2827              }
   2828            }
   2829            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2830            {
   2831              if ( ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   2832                   ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ) )
   2833              {
   2834                uint16           ami;
   2835                ZDSecMgrEntry_t* entry;
   2836          
   2837                // get the address index
   2838                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2839                {
   2840                  // store new EXT address
   2841                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2842                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2843                }
   2844          
   2845                ZDSecMgrEntryLookupAMI( ami, &entry );
   2846          
   2847                if ( entry == NULL )
   2848                {
   2849                  // get new entry
   2850                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2851                  {
   2852                    // finish setting up entry
   2853                    entry->ami = ami;
   2854                  }
   2855                }
   2856          
   2857                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2858          
   2859          #if defined NV_RESTORE
   2860                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   2861          #endif
   2862              }
   2863            }
   2864          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000BB   7410         MOV       A,#0x10
   \   0000BD   02....       LJMP      ??Subroutine126_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   EE           MOV       A,R6
   \   000001                REQUIRE ??Subroutine132_0
   \   000001                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   2406         ADD       A,#0x6
   \   000002   FA           MOV       R2,A
   \   000003   E4           CLR       A
   \   000004   3F           ADDC      A,R7
   \   000005   FB           MOV       R3,A
   \   000006   22           RET
   2865          
   2866          /******************************************************************************
   2867           * @fn          ZDSecMgrUpdateDeviceInd
   2868           *
   2869           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2870           *
   2871           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2872           *
   2873           * @return      none
   2874           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   740A         MOV       A,#0xa
   \   000002                REQUIRE ??Subroutine112_0
   \   000002                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2875          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2876          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2877            ZDSecMgrDevice_t device;
   2878          
   2879            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV       A,R2
   \   00000A   240C         ADD       A,#0xc
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3B           ADDC      A,R3
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine34 & 0xFFFF
   2880            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_205:
   \   000015   EA           MOV       A,R2
   \   000016   2404         ADD       A,#0x4
   \   000018   F8           MOV       R0,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F9           MOV       R1,A
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   12....       LCALL     ?Subroutine16 & 0xFFFF
   2881            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_4:
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine22 & 0xFFFF
   2882          
   2883            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2884            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2885            //{
   2886            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2887            //  {
   2888            //    device.secure = TRUE;
   2889            //  }
   2890            //  else
   2891            //  {
   2892            //    device.secure = FALSE;
   2893            //  }
   2894          
   2895              // try to join this device
   2896              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_18:
   \   00002A   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   2897            //}
   2898          }
   \   00002D   02....       LJMP      ?Subroutine10 & 0xFFFF
   2899          
   2900          /******************************************************************************
   2901           * @fn          ZDSecMgrRemoveDeviceInd
   2902           *
   2903           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2904           *
   2905           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2906           *
   2907           * @return      none
   2908           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2909          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2910          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2911            ZDSecMgrDevice_t device;
   2912          
   2913            // only accept from Trust Center
   2914            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000017   7021         JNZ       ??CrossCallReturnLabel_15
   2915            {
   2916              // look up NWK address
   2917              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000019                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000019   AC..         MOV       R4,?XSP + 0
   \   00001B   AD..         MOV       R5,?XSP + 1
   \   00001D   EA           MOV       A,R2
   \   00001E   2404         ADD       A,#0x4
   \   000020   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000023   7015         JNZ       ??CrossCallReturnLabel_15
   2918              {
   2919                device.parentAddr = NLME_GetShortAddr();
   \   000025                ; Setup parameters for call to function NLME_GetShortAddr
   \   000025   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000028   7404         MOV       A,#0x4
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   EA           MOV       A,R2
   \   00002E   F0           MOVX      @DPTR,A
   \   00002F   A3           INC       DPTR
   \   000030   EB           MOV       A,R3
   \   000031   12....       LCALL     ??Subroutine130_0 & 0xFFFF
   2920                device.extAddr    = ind->childExtAddr;
   2921          
   2922                // remove device
   2923                ZDSecMgrDeviceRemove( &device );
   2924              }
   2925            }
   \                     ??CrossCallReturnLabel_254:
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   12....       LCALL     ?Subroutine21 & 0xFFFF
   2926          }
   \                     ??CrossCallReturnLabel_15:
   \   00003A   740A         MOV       A,#0xa
   \   00003C   02....       LJMP      ??Subroutine126_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   \   000006   22           RET
   2927          
   2928          /******************************************************************************
   2929           * @fn          ZDSecMgrRequestKeyInd
   2930           *
   2931           * @brief       Process the ZDO_RequestKeyInd_t message.
   2932           *
   2933           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2934           *
   2935           * @return      none
   2936           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2937          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2938          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2939            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   6401         XRL       A,#0x1
   \   00000F   6010         JZ        ??ZDSecMgrRequestKeyInd_0
   2940            {
   2941            }
   2942            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   6402         XRL       A,#0x2
   \   00001C   7003         JNZ       ??ZDSecMgrRequestKeyInd_0
   2943            {
   2944              ZDSecMgrAppKeyReq( ind );
   \   00001E                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   00001E   12....       LCALL     `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   2945            }
   2946            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2947            {
   2948            }
   2949            //else ignore
   2950          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000021   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   2951          
   2952          /******************************************************************************
   2953           * @fn          ZDSecMgrSwitchKeyInd
   2954           *
   2955           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2956           *
   2957           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2958           *
   2959           * @return      none
   2960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2961          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2962          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2963            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2964          
   2965            // Save if nv
   2966            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2967          }
   \   000014   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   2968          
   2969          /******************************************************************************
   2970           * @fn          ZDSecMgrAuthenticateInd
   2971           *
   2972           * @brief       Process the ZDO_AuthenticateInd_t message.
   2973           *
   2974           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2975           *
   2976           * @return      none
   2977           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2978          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   2979          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2980            APSME_AuthenticateReq_t req;
   2981            AddrMgrEntry_t          entry;
   2982          
   2983            // update the address manager
   2984            //---------------------------------------------------------------------------
   2985            // note:
   2986            // required for EA processing, but ultimately EA logic could also use the
   2987            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   2988            // table is supposed to have authentication states for neighbors
   2989            //---------------------------------------------------------------------------
   2990            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV       A,#0x7
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   12....       LCALL     ?Subroutine19 & 0xFFFF
   2991            entry.nwkAddr = ind->aps.initNwkAddr;
   \                     ??CrossCallReturnLabel_11:
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   2992            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_200:
   \   00001E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001E   EA           MOV       A,R2
   \   00001F   2404         ADD       A,#0x4
   \   000021   FC           MOV       R4,A
   \   000022   E4           CLR       A
   \   000023   3F           ADDC      A,R7
   \   000024   FD           MOV       R5,A
   \   000025   740A         MOV       A,#0xa
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   AA82         MOV       R2,DPL
   \   00002C   AB83         MOV       R3,DPH
   \   00002E   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   2993          
   2994            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000031                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000031   7407         MOV       A,#0x7
   \   000033   12....       LCALL     ?XSTACK_DISP101_8
   \   000036   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000039   7026         JNZ       ??ZDSecMgrAuthenticateInd_0
   2995            {
   2996              // set request fields
   2997              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00003B   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   00003E   12....       LCALL     ?Subroutine17 & 0xFFFF
   2998              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_253:
   \   000041   12....       LCALL     ?XSTACK_DISP0_8
   \   000044   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   2999              req.action    = APSME_EA_ACCEPT;
   \                     ??CrossCallReturnLabel_201:
   \   000047   7406         MOV       A,#0x6
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   7401         MOV       A,#0x1
   \   00004E   F0           MOVX      @DPTR,A
   3000              req.challenge = ind->aps.challenge;
   \   00004F   EE           MOV       A,R6
   \   000050   240C         ADD       A,#0xc
   \   000052   F8           MOV       R0,A
   \   000053   E4           CLR       A
   \   000054   3F           ADDC      A,R7
   \   000055   F9           MOV       R1,A
   \   000056   7404         MOV       A,#0x4
   \   000058   12....       LCALL     ?XSTACK_DISP0_8
   \   00005B   12....       LCALL     ?Subroutine22 & 0xFFFF
   3001          
   3002              // start EA processing
   3003              APSME_AuthenticateReq( &req );
   3004            }
   \                     ??CrossCallReturnLabel_19:
   \   00005E   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   3005          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000061   7414         MOV       A,#0x14
   \   000063   02....       LJMP      ??Subroutine126_0 & 0xFFFF
   3006          
   3007          /******************************************************************************
   3008           * @fn          ZDSecMgrAuthenticateCfm
   3009           *
   3010           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3011           *
   3012           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3013           *
   3014           * @return      none
   3015           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3016          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3017          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3018            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV       A,R2
   \   000005   240B         ADD       A,#0xb
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F583         MOV       DPH,A
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   701F         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3019            {
   3020              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   7014         JNZ       ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV       DPTR,#devState
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   6405         XRL       A,#0x5
   \   000021   700C         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3021              {
   3022                // inform ZDO that device has been authenticated
   3023                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV       R2,#-0x80
   \   000025   7B00         MOV       R3,#0x0
   \   000027   90....       MOV       DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
   \   00002C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   3024              }
   3025            }
   3026          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP      ??Subroutine124_0 & 0xFFFF
   3027          
   3028          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3029          /******************************************************************************
   3030           * @fn          ZDSecMgrUpdateNwkKey
   3031           *
   3032           * @brief       Load a new NWK key and trigger a network wide update.
   3033           *
   3034           * @param       key       - [in] new NWK key
   3035           * @param       keySeqNum - [in] new NWK key sequence number
   3036           *
   3037           * @return      ZStatus_t
   3038           */
   3039          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3040          {
   3041            ZStatus_t               status;
   3042            APSME_TransportKeyReq_t req;
   3043          
   3044            // initialize common elements of local variables
   3045            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3046            {
   3047              req.keyType   = KEY_TYPE_NWK_HIGH;
   3048            }
   3049            else
   3050            {
   3051              req.keyType   = KEY_TYPE_NWK;
   3052            }
   3053          
   3054            req.dstAddr   = dstAddr;
   3055            req.keySeqNum = keySeqNum;
   3056            req.key       = key;
   3057            req.extAddr   = NULL;
   3058            req.nwkSecure = TRUE;
   3059            req.apsSecure = TRUE;
   3060            req.tunnel    = NULL;
   3061          
   3062            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3063                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3064            {
   3065              ZDSecMgrEntry_t*        entry;
   3066              uint16                  index;
   3067              AddrMgrEntry_t          addrEntry;
   3068          
   3069              addrEntry.user = ADDRMGR_USER_SECURITY;
   3070          
   3071              status = ZFailure;
   3072          
   3073              // verify data is available
   3074              if ( ZDSecMgrEntries != NULL )
   3075              {
   3076                // find available entry
   3077                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3078                {
   3079                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3080                  {
   3081                    // return successful result
   3082                    entry = &ZDSecMgrEntries[index];
   3083          
   3084                    // get NWK address
   3085                    addrEntry.index = entry->ami;
   3086                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3087                    {
   3088                      req.dstAddr = addrEntry.nwkAddr;
   3089                      req.extAddr = addrEntry.extAddr;
   3090                      status = APSME_TransportKeyReq( &req );
   3091                    }
   3092                  }
   3093                }
   3094              }
   3095            }
   3096            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3097            {
   3098              status = APSME_TransportKeyReq( &req );
   3099            }
   3100          
   3101            SSP_UpdateNwkKey( key, keySeqNum );
   3102          
   3103            // Save if nv
   3104            ZDApp_NVUpdate();
   3105          
   3106            return status;
   3107          }
   3108          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3109          
   3110          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3111          /******************************************************************************
   3112           * @fn          ZDSecMgrSwitchNwkKey
   3113           *
   3114           * @brief       Causes the NWK key to switch via a network wide command.
   3115           *
   3116           * @param       keySeqNum - [in] new NWK key sequence number
   3117           *
   3118           * @return      ZStatus_t
   3119           */
   3120          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3121          {
   3122            ZStatus_t            status;
   3123            APSME_SwitchKeyReq_t req;
   3124          
   3125            // initialize common elements of local variables
   3126            req.dstAddr = dstAddr;
   3127            req.keySeqNum = keySeqNum;
   3128          
   3129            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3130                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3131            {
   3132              ZDSecMgrEntry_t*     entry;
   3133              uint16               index;
   3134              AddrMgrEntry_t       addrEntry;
   3135          
   3136              addrEntry.user = ADDRMGR_USER_SECURITY;
   3137          
   3138              status = ZFailure;
   3139          
   3140              // verify data is available
   3141              if ( ZDSecMgrEntries != NULL )
   3142              {
   3143                // find available entry
   3144                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3145                {
   3146                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3147                  {
   3148                    // return successful result
   3149                    entry = &ZDSecMgrEntries[index];
   3150          
   3151                    // get NWK address
   3152                    addrEntry.index = entry->ami;
   3153          
   3154                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3155                    {
   3156                      req.dstAddr = addrEntry.nwkAddr;
   3157                      status = APSME_SwitchKeyReq( &req );
   3158                    }
   3159                  }
   3160                }
   3161              }
   3162            }
   3163            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3164            {
   3165              status = APSME_SwitchKeyReq( &req );
   3166            }
   3167          
   3168            SSP_SwitchNwkKey( keySeqNum );
   3169          
   3170            // Save if nv
   3171            ZDApp_NVUpdate();
   3172          
   3173            return status;
   3174          }
   3175          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3176          
   3177          /******************************************************************************
   3178           * @fn          ZDSecMgrRequestAppKey
   3179           *
   3180           * @brief       Request an application key with partner.
   3181           *
   3182           * @param       partExtAddr - [in] partner extended address
   3183           *
   3184           * @return      ZStatus_t
   3185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3186          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   3187          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3188            ZStatus_t status;
   3189            APSME_RequestKeyReq_t req;
   3190          
   3191            req.dstAddr = 0;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   3192            req.keyType = KEY_TYPE_APP_MASTER;
   \   000011   04           INC       A
   \   000012   12....       LCALL     ?XSTACK_DISP0_8
   \   000015   7402         MOV       A,#0x2
   \   000017   F0           MOVX      @DPTR,A
   3193          
   3194            req.partExtAddr = partExtAddr;
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ?Subroutine20 & 0xFFFF
   3195            status = APSME_RequestKeyReq( &req );
   3196          
   3197            return status;
   \                     ??CrossCallReturnLabel_14:
   \   00001E   12....       LCALL     `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000021   7404         MOV       A,#0x4
   \   000023   02....       LJMP      ??Subroutine112_0 & 0xFFFF
   3198          }
   3199          
   3200          #if ( ZG_BUILD_JOINING_TYPE )
   3201          /******************************************************************************
   3202           * @fn          ZDSecMgrSetupPartner
   3203           *
   3204           * @brief       Setup for application key partner.
   3205           *
   3206           * @param       partNwkAddr - [in] partner network address
   3207           *
   3208           * @return      ZStatus_t
   3209           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3210          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3211          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3212            AddrMgrEntry_t entry;
   3213            ZStatus_t      status;
   3214          
   3215            status = ZFailure;
   \   000012   75..01       MOV       ?V0,#0x1
   3216          
   3217            // update the address manager
   3218            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   7402         MOV       A,#0x2
   \   00001D   F0           MOVX      @DPTR,A
   3219            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC       A
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   12....       LCALL     ?Subroutine29 & 0xFFFF
   3220            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \                     ??CrossCallReturnLabel_40:
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   AA82         MOV       R2,DPL
   \   00002A   AB83         MOV       R3,DPH
   \   00002C   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3221          
   3222            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00002F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00002F   12....       LCALL     ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000032   7038         JNZ       ??ZDSecMgrSetupPartner_0
   3223            {
   3224              status = ZSuccess;
   \   000034   75..00       MOV       ?V0,#0x0
   3225          
   3226              // check for address discovery
   3227              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000037   74FE         MOV       A,#-0x2
   \   000039   65..         XRL       A,?V2
   \   00003B   7004         JNZ       ??ZDSecMgrSetupPartner_1
   \   00003D   74FF         MOV       A,#-0x1
   \   00003F   65..         XRL       A,?V3
   \                     ??ZDSecMgrSetupPartner_1:
   \   000041   700F         JNZ       ??ZDSecMgrSetupPartner_2
   3228              {
   3229                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000043                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000043   7D00         MOV       R5,#0x0
   \   000045   7C00         MOV       R4,#0x0
   \   000047   7900         MOV       R1,#0x0
   \   000049   EE           MOV       A,R6
   \   00004A   FA           MOV       R2,A
   \   00004B   EF           MOV       A,R7
   \   00004C   FB           MOV       R3,A
   \   00004D   12....       LCALL     `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   \   000050   8017         SJMP      ??ZDSecMgrSetupPartner_3
   3230              }
   3231              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000052                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000052   EE           MOV       A,R6
   \   000053   FA           MOV       R2,A
   \   000054   EF           MOV       A,R7
   \   000055   FB           MOV       R3,A
   \   000056   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000059   E9           MOV       A,R1
   \   00005A   7010         JNZ       ??ZDSecMgrSetupPartner_0
   3232              {
   3233                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00005C                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   00005C   7D00         MOV       R5,#0x0
   \   00005E   7C00         MOV       R4,#0x0
   \   000060   7900         MOV       R1,#0x0
   \   000062   AA..         MOV       R2,?V2
   \   000064   AB..         MOV       R3,?V3
   \   000066   12....       LCALL     `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_3:
   \   000069   E9           MOV       A,R1
   \   00006A   F5..         MOV       ?V0,A
   3234              }
   3235            }
   3236          
   3237            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   00006C   A9..         MOV       R1,?V0
   \   00006E   740D         MOV       A,#0xd
   \   000070   02....       LJMP      ?Subroutine6 & 0xFFFF
   3238          }
   3239          #endif // ( ZG_BUILD_JOINING_TYPE )
   3240          
   3241          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3242          /******************************************************************************
   3243           * @fn          ZDSecMgrAppKeyTypeSet
   3244           *
   3245           * @brief       Set application key type.
   3246           *
   3247           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3248           *                                                   KEY_TYPE_APP_LINK@3
   3249           *
   3250           * @return      ZStatus_t
   3251           */
   3252          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3253          {
   3254            if ( keyType == KEY_TYPE_APP_LINK )
   3255            {
   3256              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3257            }
   3258            else
   3259            {
   3260              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3261            }
   3262          
   3263            return ZSuccess;
   3264          }
   3265          #endif
   3266          
   3267          /******************************************************************************
   3268           * ZigBee Device Security Manager - Stub Implementations
   3269           */
   3270          /******************************************************************************
   3271           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3272           *
   3273           * @brief       Get MASTER key for specified EXT address.
   3274           *
   3275           * @param       extAddr - [in] EXT address
   3276           * @param       pKeyNvId - [out] MASTER key NV ID
   3277           *
   3278           * @return      ZStatus_t
   3279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3280          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3281          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3282            ZStatus_t status;
   3283            uint16 ami;
   3284          
   3285            // lookup entry for specified EXT address
   3286            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   3287          
   3288            if ( status == ZSuccess )
   \   000018   7012         JNZ       ??APSME_MasterKeyGet_0
   3289            {
   3290              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   EE           MOV       A,R6
   \   00001B   FC           MOV       R4,A
   \   00001C   EF           MOV       A,R7
   \   00001D   FD           MOV       R5,A
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   3291            }
   \                     ??CrossCallReturnLabel_225:
   \   000027   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   00002A   8008         SJMP      ??APSME_MasterKeyGet_1
   3292            else
   3293            {
   3294              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   00002C   8E82         MOV       DPL,R6
   \   00002E   8F83         MOV       DPH,R7
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   F0           MOVX      @DPTR,A
   3295            }
   3296          
   3297            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000034   02....       LJMP      ?Subroutine1 & 0xFFFF
   3298          }
   3299          
   3300          /******************************************************************************
   3301           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3302           *
   3303           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3304           *
   3305           * @param       extAddr - [in] EXT address
   3306           * @param       data    - [in] APSME_LinkKeyData_t
   3307           *
   3308           * @return      ZStatus_t
   3309           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3310          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3311          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3312            ZStatus_t status;
   3313            ZDSecMgrEntry_t* entry;
   3314            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3315            uint16 Index;
   3316          
   3317            // lookup entry index for specified EXT address
   3318            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP102_8
   \   000021   12....       LCALL     `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV       A,#0x2
   \   000026   12....       LCALL     ?DEALLOC_XSTACK8
   \   000029   E9           MOV       A,R1
   \   00002A   F5..         MOV       ?V0,A
   3319          
   3320            if ( status == ZSuccess )
   \   00002C   6003         JZ        $+5
   \   00002E   02....       LJMP      ??CrossCallReturnLabel_295 & 0xFFFF
   3321            {
   3322              // point to NV item
   3323              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000031   7402         MOV       A,#0x2
   \   000033   12....       LCALL     ?XSTACK_DISP0_8
   \   000036   E0           MOVX      A,@DPTR
   \   000037   2401         ADD       A,#0x1
   \   000039   F8           MOV       R0,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   3402         ADDC      A,#0x2
   \   00003E   F9           MOV       R1,A
   \   00003F   85..82       MOV       DPL,?XSP + 0
   \   000042   85..83       MOV       DPH,?XSP + 1
   \   000045   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000048   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   3324          
   3325              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_202:
   \   00004B                ; Setup parameters for call to function osal_mem_alloc
   \   00004B   12....       LCALL     ?Subroutine72 & 0xFFFF
   3326          
   3327              if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_104:
   \   00004E   7003         JNZ       $+5
   \   000050   02....       LJMP      ??CrossCallReturnLabel_295 & 0xFFFF
   3328              {
   3329                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3330                osal_nv_read( entry->keyNvId, 0,
   3331                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000053                ; Setup parameters for call to function osal_nv_read
   \   000053   78..         MOV       R0,#?V2
   \   000055   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000058   75..18       MOV       ?V4,#0x18
   \   00005B   75..00       MOV       ?V5,#0x0
   \   00005E   78..         MOV       R0,#?V4
   \   000060   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000063   7C00         MOV       R4,#0x0
   \   000065   7D00         MOV       R5,#0x0
   \   000067   7404         MOV       A,#0x4
   \   000069   12....       LCALL     ?XSTACK_DISP0_8
   \   00006C   12....       LCALL     ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   00006F   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000072   12....       LCALL     ?DEALLOC_XSTACK8
   3332          
   3333                // set new values of the key
   3334                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   000075                ; Setup parameters for call to function osal_memcpy
   \   000075   8E..         MOV       ?V4,R6
   \   000077   8F..         MOV       ?V5,R7
   \   000079   75..00       MOV       ?V6,#0x0
   \   00007C   78..         MOV       R0,#?V4
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000081   7C10         MOV       R4,#0x10
   \   000083   7D00         MOV       R5,#0x0
   \   000085   AA..         MOV       R2,?V2
   \   000087   AB..         MOV       R3,?V3
   \   000089   12....       LCALL     ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
   3335                pApsLinkKey->rxFrmCntr = 0;
   \   00008F   E5..         MOV       A,?V2
   \   000091   2414         ADD       A,#0x14
   \   000093   12....       LCALL     ?Subroutine14 & 0xFFFF
   3336                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_296:
   \   000096   E5..         MOV       A,?V2
   \   000098   2410         ADD       A,#0x10
   \   00009A   12....       LCALL     ?Subroutine14 & 0xFFFF
   3337          
   3338                osal_nv_write( entry->keyNvId, 0,
   3339                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_297:
   \   00009D                ; Setup parameters for call to function osal_nv_write
   \   00009D   78..         MOV       R0,#?V2
   \   00009F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A2   75..18       MOV       ?V4,#0x18
   \   0000A5   75..00       MOV       ?V5,#0x0
   \   0000A8   78..         MOV       R0,#?V4
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AD   7C00         MOV       R4,#0x0
   \   0000AF   7D00         MOV       R5,#0x0
   \   0000B1   7404         MOV       A,#0x4
   \   0000B3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0000B9   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   0000BC   12....       LCALL     ?DEALLOC_XSTACK8
   3340          
   3341                // clear copy of key in RAM
   3342                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000BF                ; Setup parameters for call to function osal_memset
   \   0000BF   12....       LCALL     ?Subroutine41 & 0xFFFF
   3343          
   3344                osal_mem_free(pApsLinkKey);
   \                     ??CrossCallReturnLabel_51:
   \   0000C2   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   0000C5   12....       LCALL     ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   0000C8   E8           MOV       A,R0
   \   0000C9   75F009       MOV       B,#0x9
   \   0000CC   A4           MUL       AB
   \   0000CD   F8           MOV       R0,A
   \   0000CE   AAF0         MOV       R2,B
   \   0000D0   75F009       MOV       B,#0x9
   \   0000D3   E9           MOV       A,R1
   \   0000D4   A4           MUL       AB
   \   0000D5   2A           ADD       A,R2
   \   0000D6   F9           MOV       R1,A
   \   0000D7   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   0000D9   28           ADD       A,R0
   \   0000DA   F8           MOV       R0,A
   \   0000DB   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000DD   39           ADDC      A,R1
   \   0000DE   F9           MOV       R1,A
   \   0000DF   E8           MOV       A,R0
   \   0000E0   24F7         ADD       A,#-0x9
   \   0000E2   F582         MOV       DPL,A
   \   0000E4   E9           MOV       A,R1
   \   0000E5   34ED         ADDC      A,#-0x13
   \   0000E7   12....       LCALL     ??Subroutine138_0 & 0xFFFF
   3345          
   3346                // set initial values for counters in RAM
   3347                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3348                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_294:
   \   0000EA   E8           MOV       A,R0
   \   0000EB   24FB         ADD       A,#-0x5
   \   0000ED   F582         MOV       DPL,A
   \   0000EF   E9           MOV       A,R1
   \   0000F0   34ED         ADDC      A,#-0x13
   \   0000F2   12....       LCALL     ??Subroutine138_0 & 0xFFFF
   3349              }
   3350            }
   3351          
   3352            return status;
   \                     ??CrossCallReturnLabel_295:
   \   0000F5   A9..         MOV       R1,?V0
   \   0000F7   7404         MOV       A,#0x4
   \   0000F9   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   3353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   35..         ADDC      A,?V3
   \   000005                REQUIRE ??Subroutine138_0
   \   000005                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine139_0
   \   000002                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   A3           INC       DPTR
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine140_0
   \   000006                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL     ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   12....       LCALL     ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   7C18         MOV       R4,#0x18
   \   000002   7D00         MOV       R5,#0x0
   \   000004   7900         MOV       R1,#0x0
   \   000006   AA..         MOV       R2,?V2
   \   000008   AB..         MOV       R3,?V3
   \   00000A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   00000D                ; Setup parameters for call to function osal_mem_free
   \   00000D                ; Setup parameters for call to function osal_mem_free
   \   00000D   AA..         MOV       R2,?V2
   \   00000F   AB..         MOV       R3,?V3
   \   000011   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000014   22           RET
   3354          
   3355          /******************************************************************************
   3356           * @fn          ZDSecMgrAuthenticationSet
   3357           *
   3358           * @brief       Mark the specific device as authenticated or not
   3359           *
   3360           * @param       extAddr - [in] EXT address
   3361           * @param       option  - [in] authenticated or not
   3362           *
   3363           * @return      ZStatus_t
   3364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3365          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3366          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   3367            ZStatus_t        status;
   3368            ZDSecMgrEntry_t* entry;
   3369          
   3370          
   3371            // lookup entry index for specified EXT address
   3372            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV       R4,?XSP + 0
   \   00000E   AD..         MOV       R5,?XSP + 1
   \   000010   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV       A,R1
   \   000014   F9           MOV       R1,A
   3373          
   3374            if ( status == ZSuccess )
   \   000015   7007         JNZ       ??ZDSecMgrAuthenticationSet_0
   3375            {
   3376              entry->authenticateOption = option;
   \   000017   12....       LCALL     ?Subroutine58 & 0xFFFF
   3377            }
   \                     ??CrossCallReturnLabel_300:
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   EE           MOV       A,R6
   \   00001D   F0           MOVX      @DPTR,A
   3378          
   3379            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00001E   02....       LJMP      ??Subroutine125_0 & 0xFFFF
   3380          }
   3381          
   3382          /******************************************************************************
   3383           * @fn          ZDSecMgrAuthenticationCheck
   3384           *
   3385           * @brief       Check if the specific device has been authenticated or not
   3386           *              For non-trust center device, always return TRUE
   3387           *
   3388           * @param       shortAddr - [in] short address
   3389           *
   3390           * @return      TRUE @ authenticated with CBKE
   3391           *              FALSE @ not authenticated
   3392           */
   3393          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3394          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3395          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3396          #if defined (TC_LINKKEY_JOIN)
   3397          
   3398            ZDSecMgrEntry_t* entry;
   3399            uint8 extAddr[Z_EXTADDR_LEN];
   3400          
   3401            // If the local device is not the trust center, always return TRUE
   3402            if ( NLME_GetShortAddr() != zgTrustCenterAddr )
   3403            {
   3404              return TRUE;
   3405            }
   3406            // Otherwise, check the authentication option
   3407            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3408            {
   3409              // lookup entry index for specified EXT address
   3410              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3411              {
   3412                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3413                {
   3414                  return TRUE;
   3415                }
   3416                else
   3417                {
   3418                  return FALSE;
   3419                }
   3420              }
   3421            }
   3422            return FALSE;
   3423          
   3424          #else
   3425            (void)shortAddr;  // Intentionally unreferenced parameter
   3426          
   3427            // For non AMI/SE Profile, perform no check and always return TRUE.
   3428            return TRUE;
   \   000000   7901         MOV       R1,#0x1
   \   000002   02....       LJMP      ?BRET
   3429          
   3430          #endif // TC_LINKKEY_JOIN
   3431          }
   3432          
   3433          /******************************************************************************
   3434           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3435           *
   3436           * @brief       Get Key NV ID for specified NWK address.
   3437           *
   3438           * @param       extAddr - [in] EXT address
   3439           * @param       keyNvId - [out] NV ID
   3440           *
   3441           * @return      ZStatus_t
   3442           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3443          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3444          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3445            ZStatus_t status;
   3446            ZDSecMgrEntry_t* entry;
   3447          
   3448            // lookup entry index for specified NWK address
   3449            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV       A,R1
   \   000016   F9           MOV       R1,A
   3450          
   3451            if ( status == ZSuccess )
   \   000017   7014         JNZ       ??APSME_LinkKeyNVIdGet_0
   3452            {
   3453              // return the index to the NV table
   3454              *pKeyNvId = entry->keyNvId;
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   12....       LCALL     ?Subroutine52 & 0xFFFF
   3455            }
   \                     ??CrossCallReturnLabel_74:
   \   000022   FB           MOV       R3,A
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   EA           MOV       A,R2
   \   000028   F0           MOVX      @DPTR,A
   \   000029   A3           INC       DPTR
   \   00002A   EB           MOV       A,R3
   \   00002B   8007         SJMP      ??APSME_LinkKeyNVIdGet_1
   3456            else
   3457            {
   3458              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   00002D   8E82         MOV       DPL,R6
   \   00002F   8F83         MOV       DPH,R7
   \   000031   E4           CLR       A
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000034   F0           MOVX      @DPTR,A
   3459            }
   3460          
   3461            return status;
   \   000035   02....       LJMP      ??Subroutine125_0 & 0xFFFF
   3462          }
   3463          
   3464          /******************************************************************************
   3465           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3466           *
   3467           * @brief       Verifies if Link Key in NV has been set.
   3468           *
   3469           * @param       extAddr - [in] EXT address
   3470           *
   3471           * @return      TRUE - Link Key has been established
   3472           *              FALSE - Link Key in NV has default value.
   3473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3474          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3475          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   3476            APSME_LinkKeyData_t *pKeyData = NULL;
   3477            uint16 apsLinkKeyNvId;
   3478            uint8 nullKey[SEC_KEY_LEN];
   3479            uint8 status = FALSE;
   \   00000E   75..00       MOV       ?V0,#0x0
   3480          
   3481            // initialize default vealue to compare to
   3482            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV       R4,#0x10
   \   000013   7D00         MOV       R5,#0x0
   \   000015   7900         MOV       R1,#0x0
   \   000017   7402         MOV       A,#0x2
   \   000019   12....       LCALL     ?XSTACK_DISP101_8
   \   00001C   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3483          
   3484            // check for APS link NV ID
   3485            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001F                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001F   AC..         MOV       R4,?XSP + 0
   \   000021   AD..         MOV       R5,?XSP + 1
   \   000023   EE           MOV       A,R6
   \   000024   FA           MOV       R2,A
   \   000025   EF           MOV       A,R7
   \   000026   FB           MOV       R3,A
   \   000027   12....       LCALL     `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   3486          
   3487            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00002A   12....       LCALL     ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   00002D   6056         JZ        ??APSME_IsLinkKeyValid_0
   3488            {
   3489              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00002F                ; Setup parameters for call to function osal_mem_alloc
   \   00002F   12....       LCALL     ?Subroutine72 & 0xFFFF
   3490          
   3491              if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_105:
   \   000032   6051         JZ        ??APSME_IsLinkKeyValid_0
   3492              {
   3493                // retrieve key from NV
   3494                if ( osal_nv_read( apsLinkKeyNvId, 0,
   3495                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000034                ; Setup parameters for call to function osal_nv_read
   \   000034   78..         MOV       R0,#?V2
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   75..18       MOV       ?V4,#0x18
   \   00003C   75..00       MOV       ?V5,#0x0
   \   00003F   78..         MOV       R0,#?V4
   \   000041   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000044   7C00         MOV       R4,#0x0
   \   000046   7D00         MOV       R5,#0x0
   \   000048   7404         MOV       A,#0x4
   \   00004A   12....       LCALL     ?XSTACK_DISP0_8
   \   00004D   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000050   12....       LCALL     ?DEALLOC_XSTACK8
   \   000053   E9           MOV       A,R1
   \   000054   702F         JNZ       ??APSME_IsLinkKeyValid_0
   3496                {
   3497                  // if stored key is different than default value, then a key has been established
   3498                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000056                ; Setup parameters for call to function osal_memcmp
   \   000056   7402         MOV       A,#0x2
   \   000058   12....       LCALL     ?XSTACK_DISP100_8
   \   00005B   88..         MOV       ?V4,R0
   \   00005D   89..         MOV       ?V5,R1
   \   00005F   75..00       MOV       ?V6,#0x0
   \   000062   78..         MOV       R0,#?V4
   \   000064   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000067   7C10         MOV       R4,#0x10
   \   000069   7D00         MOV       R5,#0x0
   \   00006B   85..82       MOV       DPL,?V2
   \   00006E   85..83       MOV       DPH,?V3
   \   000071   A982         MOV       R1,DPL
   \   000073   AA83         MOV       R2,DPH
   \   000075   7B00         MOV       R3,#0x0
   \   000077   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   00007A   7403         MOV       A,#0x3
   \   00007C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007F   E9           MOV       A,R1
   \   000080   7003         JNZ       ??APSME_IsLinkKeyValid_0
   3499                  {
   3500                    status = TRUE;
   \   000082   75..01       MOV       ?V0,#0x1
   3501                  }
   3502                }
   3503              }
   3504            }
   3505          
   3506            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   000085   A9..         MOV       R1,?V0
   \   000087   02....       LJMP      ?Subroutine3 & 0xFFFF
   3507          }
   3508          
   3509          /******************************************************************************
   3510           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3511           *
   3512           * @brief       Verify and process key transportation to child.
   3513           *
   3514           * @param       ind - [in] APSME_TransportKeyInd_t
   3515           *
   3516           * @return      uint8 - success(TRUE:FALSE)
   3517           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3518          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3519          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3520            // verify from Trust Center
   3521            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   12....       LCALL     ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00000C   7035         JNZ       ??APSME_KeyFwdToChild_0
   3522            {
   3523              // check for initial NWK key
   3524              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3525                   ( ind->keyType == 6                 ) ||
   3526                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   6401         XRL       A,#0x1
   \   000017   6016         JZ        ??APSME_KeyFwdToChild_1
   \   000019   8A82         MOV       DPL,R2
   \   00001B   8B83         MOV       DPH,R3
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6406         XRL       A,#0x6
   \   000022   600B         JZ        ??APSME_KeyFwdToChild_1
   \   000024   8A82         MOV       DPL,R2
   \   000026   8B83         MOV       DPH,R3
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   6405         XRL       A,#0x5
   \   00002D   7010         JNZ       ??APSME_KeyFwdToChild_2
   3527              {
   3528                // set association status to authenticated
   3529                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00002F                ; Setup parameters for call to function AssocGetWithExt
   \   00002F   8A82         MOV       DPL,R2
   \   000031   8B83         MOV       DPH,R3
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   12....       LCALL     ?Subroutine68 & 0xFFFF
   3530              }
   \                     ??CrossCallReturnLabel_98:
   \   00003C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00003C   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   3531          
   3532              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   00003F   7901         MOV       R1,#0x1
   \   000041   8002         SJMP      ??APSME_KeyFwdToChild_3
   3533            }
   3534          
   3535            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000043   7900         MOV       R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   000045   02....       LJMP      ??Subroutine119_0 & 0xFFFF
   3536          }
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrAddLinkKey
   3540           *
   3541           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3542           *              as authenticated in the authenticateOption. Note that this function
   3543           *              is hardwared to CBKE right now.
   3544           *
   3545           * @param       shortAddr - short address of the partner device
   3546           * @param       extAddr - extended address of the partner device
   3547           * @param       key - link key
   3548           *
   3549           * @return      ZStatus_t
   3550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3551          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3552          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3553            uint16           ami;
   3554            ZDSecMgrEntry_t* entry;
   3555          
   3556            /* Store the device address in the addr manager */
   3557            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?DEALLOC_XSTACK8
   \   000024   E9           MOV       A,R1
   \   000025   6004         JZ        ??ZDSecMgrAddLinkKey_0
   3558            {
   3559              /* Adding to Addr Manager fails */
   3560              return ZFailure;
   \   000027   7901         MOV       R1,#0x1
   \   000029   8036         SJMP      ??ZDSecMgrAddLinkKey_1
   3561            }
   3562          
   3563            /* Lookup entry using specified address index */
   3564            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV       R4,?XSP + 0
   \   00002D   AD..         MOV       R5,?XSP + 1
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   12....       LCALL     ?Subroutine65 & 0xFFFF
   3565          
   3566            // If no existing entry, create one
   3567            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_92:
   \   000037   12....       LCALL     ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   00003A   7018         JNZ       ??CrossCallReturnLabel_203
   3568            {
   3569              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00003C   AA..         MOV       R2,?XSP + 0
   \   00003E   AB..         MOV       R3,?XSP + 1
   \   000040   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000043   E9           MOV       A,R1
   \   000044   701E         JNZ       ??ZDSecMgrAddLinkKey_2
   3570              {
   3571                entry->ami = ami;
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?XSTACK_DISP0_8
   \   00004B   12....       LCALL     ?Subroutine60 & 0xFFFF
   3572              }
   \                     ??CrossCallReturnLabel_86:
   \   00004E   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000051   12....       LCALL     ??Subroutine114_0 & 0xFFFF
   3573              else
   3574              {
   3575                /* Security Manager full */
   3576                return ZBufferFull;
   3577              }
   3578            }
   3579            // Write the link key
   3580            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_203:
   \   000054                ; Setup parameters for call to function APSME_LinkKeySet
   \   000054   740E         MOV       A,#0xe
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   12....       LCALL     ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   00005C   12....       LCALL     `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   3581          
   3582          #if defined (TC_LINKKEY_JOIN)
   3583            // Mark the device as authenticated.
   3584            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3585          #endif
   3586          
   3587          #if defined NV_RESTORE
   3588            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3589          #endif
   3590          
   3591            return ZSuccess;
   \   00005F   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000061   02....       LJMP      ?Subroutine7 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000064   7911         MOV       R1,#0x11
   \   000066   80F9         SJMP      ??ZDSecMgrAddLinkKey_1
   3592          }
   3593          
   3594          #if defined ( NV_RESTORE )
   3595          /******************************************************************************
   3596           * @fn          ZDSecMgrInitNV
   3597           *
   3598           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3599           *
   3600           * @param       none
   3601           *
   3602           * @return      uint8 - <osal_nv_item_init> return codes
   3603           */
   3604          uint8 ZDSecMgrInitNV(void)
   3605          {
   3606          
   3607            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   3608                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3609          
   3610            // If the item does not already exist, set all values to 0
   3611            if (rtrn != SUCCESS)
   3612            {
   3613              nvDeviceListHdr_t hdr;
   3614              hdr.numRecs = 0;
   3615              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3616            }
   3617          
   3618            return rtrn;
   3619          }
   3620          #endif // NV_RESTORE
   3621          
   3622          #if defined ( NV_RESTORE )
   3623          /*********************************************************************
   3624           * @fn      ZDSecMgrWriteNV()
   3625           *
   3626           * @brief   Save off the APS link key list to NV
   3627           *
   3628           * @param   none
   3629           *
   3630           * @return  none
   3631           */
   3632          static void ZDSecMgrWriteNV( void )
   3633          {
   3634            uint16 i;
   3635            nvDeviceListHdr_t hdr;
   3636          
   3637            hdr.numRecs = 0;
   3638          
   3639            if (ZDSecMgrEntries != NULL)
   3640            {
   3641              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3642              {
   3643                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3644                {
   3645                  // Save off the record
   3646                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3647                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3648                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3649                  hdr.numRecs++;
   3650                }
   3651              }
   3652            }
   3653          
   3654            // Save off the header
   3655            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3656          }
   3657          #endif // NV_RESTORE
   3658          
   3659          #if defined ( NV_RESTORE )
   3660          /******************************************************************************
   3661           * @fn          ZDSecMgrRestoreFromNV
   3662           *
   3663           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3664           *              the key data itself as they remain in NV until they are used.
   3665           *              Only list data is restored.
   3666           *
   3667           * @param       none
   3668           *
   3669           * @return      None.
   3670           */
   3671          static void ZDSecMgrRestoreFromNV( void )
   3672          {
   3673            nvDeviceListHdr_t hdr;
   3674            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3675          
   3676            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3677                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3678            {
   3679              uint8 x;
   3680          
   3681              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3682          
   3683              for (x = 0; x < hdr.numRecs; x++)
   3684              {
   3685                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3686                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3687                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3688                {
   3689                  // update data only for valid entries
   3690                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3691                  {
   3692                    if (pApsLinkKey != NULL)
   3693                    {
   3694                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3695                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   3696                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3697          
   3698                      // set new values for the counter
   3699                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3700          
   3701                      // restore values for counters in RAM
   3702                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   3703                                                      pApsLinkKey->txFrmCntr;
   3704          
   3705                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   3706                                                      pApsLinkKey->rxFrmCntr;
   3707          
   3708                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   3709                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3710          
   3711                      // clear copy of key in RAM
   3712                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3713                    }
   3714                  }
   3715                }
   3716              }
   3717          
   3718              if (pApsLinkKey != NULL)
   3719              {
   3720                osal_mem_free(pApsLinkKey);
   3721              }
   3722            }
   3723          }
   3724          #endif // NV_RESTORE
   3725          
   3726          /*********************************************************************
   3727           * @fn          ZDSecMgrSetDefaultNV
   3728           *
   3729           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3730           *
   3731           * @param       none
   3732           *
   3733           * @return      none
   3734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   EE           MOV       A,R6
   \   000005   2401         ADD       A,#0x1
   \   000007   FA           MOV       R2,A
   \   000008   EF           MOV       A,R7
   \   000009                REQUIRE ??Subroutine106_0
   \   000009                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   3402         ADDC      A,#0x2
   \   000002                REQUIRE ??Subroutine107_0
   \   000002                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3735          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3736          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3737            uint16 i;
   3738            nvDeviceListHdr_t hdr;
   3739            ZDSecMgrEntry_t secMgrEntry;
   3740            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3741          
   3742            // Initialize the header
   3743            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   3744          
   3745            // clear the header
   3746            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V0,R0
   \   00001A   89..         MOV       ?V1,R1
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV       ?V0,#0x2
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV       R4,#0x0
   \   00002E   7D00         MOV       R5,#0x0
   \   000030   7A4C         MOV       R2,#0x4c
   \   000032   7B00         MOV       R3,#0x0
   \   000034   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000037   12....       LCALL     ?DEALLOC_XSTACK8
   3747          
   3748            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00003A                ; Setup parameters for call to function osal_memset
   \   00003A   7C05         MOV       R4,#0x5
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   7900         MOV       R1,#0x0
   \   000040   7402         MOV       A,#0x2
   \   000042   12....       LCALL     ?XSTACK_DISP101_8
   \   000045   12....       LCALL     ?Subroutine40 & 0xFFFF
   3749          
   3750            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3751            {
   3752              // Clear the record
   3753              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3754                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3755                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??CrossCallReturnLabel_49:
   \   000048                ; Setup parameters for call to function osal_nv_write
   \   000048   7402         MOV       A,#0x2
   \   00004A   12....       LCALL     ?XSTACK_DISP100_8
   \   00004D   88..         MOV       ?V0,R0
   \   00004F   89..         MOV       ?V1,R1
   \   000051   78..         MOV       R0,#?V0
   \   000053   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000056   75..05       MOV       ?V0,#0x5
   \   000059   75..00       MOV       ?V1,#0x0
   \   00005C   78..         MOV       R0,#?V0
   \   00005E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000061   EE           MOV       A,R6
   \   000062   F8           MOV       R0,A
   \   000063   EF           MOV       A,R7
   \   000064   F9           MOV       R1,A
   \   000065   E8           MOV       A,R0
   \   000066   75F005       MOV       B,#0x5
   \   000069   A4           MUL       AB
   \   00006A   F8           MOV       R0,A
   \   00006B   AAF0         MOV       R2,B
   \   00006D   75F005       MOV       B,#0x5
   \   000070   E9           MOV       A,R1
   \   000071   A4           MUL       AB
   \   000072   2A           ADD       A,R2
   \   000073   F9           MOV       R1,A
   \   000074   E8           MOV       A,R0
   \   000075   2402         ADD       A,#0x2
   \   000077   FC           MOV       R4,A
   \   000078   E4           CLR       A
   \   000079   39           ADDC      A,R1
   \   00007A   FD           MOV       R5,A
   \   00007B   7A4C         MOV       R2,#0x4c
   \   00007D   7B00         MOV       R3,#0x0
   \   00007F   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   3756            }
   \                     ??CrossCallReturnLabel_159:
   \   000082   12....       LCALL     ?DEALLOC_XSTACK8
   \   000085   0E           INC       R6
   \   000086   EE           MOV       A,R6
   \   000087   7001         JNZ       ??ZDSecMgrSetDefaultNV_0
   \   000089   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   00008A   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00008D   40B9         JC        ??CrossCallReturnLabel_49
   3757          
   3758            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00008F                ; Setup parameters for call to function osal_mem_alloc
   \   00008F   7A18         MOV       R2,#0x18
   \   000091   12....       LCALL     ?Subroutine76 & 0xFFFF
   3759          
   3760            if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_109:
   \   000094   6030         JZ        ??ZDSecMgrSetDefaultNV_1
   3761            {
   3762              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000096                ; Setup parameters for call to function osal_memset
   \   000096   7C18         MOV       R4,#0x18
   \   000098   7D00         MOV       R5,#0x0
   \   00009A   7900         MOV       R1,#0x0
   \   00009C   12....       LCALL     ?Subroutine40 & 0xFFFF
   3763          
   3764              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3765              {
   3766                // Clear the record
   3767                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3768                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??CrossCallReturnLabel_50:
   \   00009F                ; Setup parameters for call to function osal_nv_write
   \   00009F   78..         MOV       R0,#?V0
   \   0000A1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A4   75..18       MOV       ?V2,#0x18
   \   0000A7   75..00       MOV       ?V3,#0x0
   \   0000AA   78..         MOV       R0,#?V2
   \   0000AC   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AF   12....       LCALL     ?Subroutine36 & 0xFFFF
   3769              }
   \                     ??CrossCallReturnLabel_150:
   \   0000B2   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B5   0E           INC       R6
   \   0000B6   EE           MOV       A,R6
   \   0000B7   7001         JNZ       ??ZDSecMgrSetDefaultNV_2
   \   0000B9   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   0000BA   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0000BD   40E0         JC        ??CrossCallReturnLabel_50
   3770          
   3771              osal_mem_free(pApsLinkKey);
   \   0000BF                ; Setup parameters for call to function osal_mem_free
   \   0000BF   AA..         MOV       R2,?V0
   \   0000C1   AB..         MOV       R3,?V1
   \   0000C3   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3772            }
   3773          }
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000C6   7407         MOV       A,#0x7
   \   0000C8                REQUIRE ?Subroutine6
   \   0000C8                ; // Fall through to label ?Subroutine6

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   7B00         MOV       R3,#0x0
   \   000002   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EA           MOV       A,R2
   \   00000A   4B           ORL       A,R3
   \   00000B   22           RET
   3774          
   3775          /******************************************************************************
   3776           * @fn          ZDSecMgrAPSRemove
   3777           *
   3778           * @brief       Remove device from network.
   3779           *
   3780           * @param       nwkAddr - device's NWK address
   3781           * @param       extAddr - device's Extended address
   3782           * @param       parentAddr - parent's NWK address
   3783           *
   3784           * @return      ZStatus_t
   3785           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3786          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3787          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3788            ZDSecMgrDevice_t device;
   3789          
   3790            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3791                 ( extAddr == NULL )              ||
   3792                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ        ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV       A,R4
   \   000014   4D           ORL       A,R5
   \   000015   6012         JZ        ??ZDSecMgrAPSRemove_1
   \   000017   740A         MOV       A,#0xa
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   00001F   74FE         MOV       A,#-0x2
   \   000021   68           XRL       A,R0
   \   000022   7003         JNZ       ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV       A,#-0x1
   \   000026   69           XRL       A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ       ??ZDSecMgrAPSRemove_3
   3793            {
   3794              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV       R1,#0x1
   \   00002B   8017         SJMP      ??ZDSecMgrAPSRemove_4
   3795            }
   3796          
   3797            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL     ?Subroutine30 & 0xFFFF
   3798            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_251:
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   EC           MOV       A,R4
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   ED           MOV       A,R5
   \   000039   F0           MOVX      @DPTR,A
   3799            device.parentAddr = parentAddr;
   \   00003A   7404         MOV       A,#0x4
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine21 & 0xFFFF
   3800          
   3801            // remove device
   3802            ZDSecMgrDeviceRemove( &device );
   3803          
   3804            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_16:
   \   000042   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000044   02....       LJMP      ?Subroutine10 & 0xFFFF
   3805          }
   3806          
   3807          /******************************************************************************
   3808           * @fn          APSME_TCLinkKeyInit
   3809           *
   3810           * @brief       Initialize the NV table for preconfigured TC link key
   3811           *
   3812           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3813           *              Trust Center Link Key is written to NV. A single tclk is used
   3814           *              by all devices joining the network.
   3815           *
   3816           * @param       setDefault - TRUE to set default values
   3817           *
   3818           * @return      none
   3819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3820          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3821          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3822            uint8             i;
   3823            APSME_TCLinkKey_t tcLinkKey;
   3824            uint8             rtrn;
   3825          
   3826            // Initialize all NV items for preconfigured TCLK
   3827            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3828            {
   3829              // Making sure data is cleared for every key all the time
   3830              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV       R4,#0x20
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3831          
   3832              // Initialize first element of the table with the default TCLK
   3833              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000017   90....       MOV       DPTR,#zgUseDefaultTCLK
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6401         XRL       A,#0x1
   \   00001D   702A         JNZ       ??APSME_TCLinkKeyInit_0
   3834              {
   3835                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C08         MOV       R4,#0x8
   \   000021   7D00         MOV       R5,#0x0
   \   000023   79FF         MOV       R1,#-0x1
   \   000025   AA..         MOV       R2,?XSP + 0
   \   000027   AB..         MOV       R3,?XSP + 1
   \   000029   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3836                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00002C                ; Setup parameters for call to function osal_memcpy
   \   00002C   75....       MOV       ?V0,#defaultTCLinkKey & 0xff
   \   00002F   75....       MOV       ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   000032   75..80       MOV       ?V2,#-0x80
   \   000035   78..         MOV       R0,#?V0
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00003A   7C10         MOV       R4,#0x10
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   740B         MOV       A,#0xb
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   12....       LCALL     ?Subroutine75 & 0xFFFF
   3837              }
   \                     ??CrossCallReturnLabel_288:
   \   000046   12....       LCALL     ?DEALLOC_XSTACK8
   3838          
   3839              // If the item doesn't exist in NV memory, create and initialize
   3840              // it with the default value passed in, either defaultTCLK or 0
   3841              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   3842                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3843          
   3844              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   000049                ; Setup parameters for call to function osal_nv_item_init
   \   000049   A8..         MOV       R0,?XSP + 0
   \   00004B   A9..         MOV       R1,?XSP + 1
   \   00004D   88..         MOV       ?V0,R0
   \   00004F   89..         MOV       ?V1,R1
   \   000051   78..         MOV       R0,#?V0
   \   000053   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000056   7C20         MOV       R4,#0x20
   \   000058   7D00         MOV       R5,#0x0
   \   00005A   7A01         MOV       R2,#0x1
   \   00005C   7B01         MOV       R3,#0x1
   \   00005E   12....       LCALL     ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   000061   12....       LCALL     ?DEALLOC_XSTACK8
   \   000064   E9           MOV       A,R1
   \   000065   7068         JNZ       ??APSME_TCLinkKeyInit_1
   3845              {
   3846                // set the Frame counters to 0 to existing keys in NV
   3847                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3848                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000067                ; Setup parameters for call to function osal_nv_read
   \   000067   78..         MOV       R0,#?V0
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   75..20       MOV       ?V0,#0x20
   \   00006F   75..00       MOV       ?V1,#0x0
   \   000072   78..         MOV       R0,#?V0
   \   000074   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000077   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   00007A   12....       LCALL     ?DEALLOC_XSTACK8
   3849          
   3850          #if defined ( NV_RESTORE )
   3851                if (setDefault == TRUE)
   3852                {
   3853                  // clear the value stored in NV
   3854                  tcLinkKey.txFrmCntr = 0;
   3855                }
   3856                else
   3857                {
   3858                  // increase the value stored in NV
   3859                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3860                }
   3861          #else
   3862                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3863                // already existed in the NV memory
   3864                tcLinkKey.txFrmCntr = 0;
   \   00007D   7418         MOV       A,#0x18
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   12....       LCALL     ??Subroutine139_0 & 0xFFFF
   3865                tcLinkKey.rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_292:
   \   000085   741C         MOV       A,#0x1c
   \   000087   12....       LCALL     ?XSTACK_DISP0_8
   \   00008A   12....       LCALL     ??Subroutine139_0 & 0xFFFF
   3866          #endif  // NV_RESTORE
   3867          
   3868                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3869                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??CrossCallReturnLabel_293:
   \   00008D                ; Setup parameters for call to function osal_nv_write
   \   00008D   A8..         MOV       R0,?XSP + 0
   \   00008F   A9..         MOV       R1,?XSP + 1
   \   000091   88..         MOV       ?V0,R0
   \   000093   89..         MOV       ?V1,R1
   \   000095   78..         MOV       R0,#?V0
   \   000097   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009A   75..20       MOV       ?V0,#0x20
   \   00009D   75..00       MOV       ?V1,#0x0
   \   0000A0   78..         MOV       R0,#?V0
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A5   7C00         MOV       R4,#0x0
   \   0000A7   7D00         MOV       R5,#0x0
   \   0000A9   7A01         MOV       R2,#0x1
   \   0000AB   7B01         MOV       R3,#0x1
   \   0000AD   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   0000B0   12....       LCALL     ?DEALLOC_XSTACK8
   3870          
   3871                // set initial values for counters in RAM
   3872                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   0000B3   7418         MOV       A,#0x18
   \   0000B5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B8   12....       LCALL     ?XLOAD_R0123
   \   0000BB   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   0000BE   12....       LCALL     ?XSTORE_R0123
   3873                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   0000C1   741C         MOV       A,#0x1c
   \   0000C3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C6   12....       LCALL     ?XLOAD_R0123
   \   0000C9   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   0000CC   12....       LCALL     ?XSTORE_R0123
   3874              }
   3875            }
   3876          
   3877            // clear copy of key in RAM
   3878            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   0000CF                ; Setup parameters for call to function osal_memset
   \   0000CF   7C20         MOV       R4,#0x20
   \   0000D1   7D00         MOV       R5,#0x0
   \   0000D3   7900         MOV       R1,#0x0
   \   0000D5   AA..         MOV       R2,?XSP + 0
   \   0000D7   AB..         MOV       R3,?XSP + 1
   \   0000D9   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3879          
   3880          }
   \   0000DC   7420         MOV       A,#0x20
   \   0000DE   02....       LJMP      ?Subroutine5 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   7A01         MOV       R2,#0x1
   \   000006   7B01         MOV       R3,#0x1
   \   000008                REQUIRE ??Subroutine145_0
   \   000008                ; // Fall through to label ??Subroutine145_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET
   3881          
   3882          /******************************************************************************
   3883           * @fn          APSME_TCLinkKeySync
   3884           *
   3885           * @brief       Sync Trust Center LINK key data.
   3886           *
   3887           * @param       srcAddr - [in] srcAddr
   3888           * @param       si      - [in, out] SSP_Info_t
   3889           *
   3890           * @return      ZStatus_t
   3891           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3892          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3893          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3894            uint8 i;
   3895            ZStatus_t status = ZSecNoKey;
   \   000012   75..A1       MOV       ?V0,#-0x5f
   3896            APSME_TCLinkKey_t tcLinkKey;
   3897            uint32 *tclkRxFrmCntr;
   3898          
   3899            // Look up the IEEE address of the trust center if it's available
   3900            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   000015                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000015   EC           MOV       A,R4
   \   000016   12....       LCALL     ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000019   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   00001C   E9           MOV       A,R1
   \   00001D   700E         JNZ       ??APSME_TCLinkKeySync_0
   3901            {
   3902              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00001F                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00001F   EE           MOV       A,R6
   \   000020   2406         ADD       A,#0x6
   \   000022   FC           MOV       R4,A
   \   000023   E4           CLR       A
   \   000024   3F           ADDC      A,R7
   \   000025   FD           MOV       R5,A
   \   000026   AA..         MOV       R2,?V2
   \   000028   AB..         MOV       R3,?V3
   \   00002A   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3903            }
   3904          
   3905            // Look up the TC link key associated with the device
   3906            // or the default TC link key (extAddr is all FFs), whichever is found
   3907            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3908            {
   3909              // Read entry i of the TC link key table from NV
   3910              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   3911                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   00002D                ; Setup parameters for call to function osal_nv_read
   \   00002D   A8..         MOV       R0,?XSP + 0
   \   00002F   A9..         MOV       R1,?XSP + 1
   \   000031   88..         MOV       ?V2,R0
   \   000033   89..         MOV       ?V3,R1
   \   000035   78..         MOV       R0,#?V2
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   75..20       MOV       ?V2,#0x20
   \   00003D   75..00       MOV       ?V3,#0x0
   \   000040   78..         MOV       R0,#?V2
   \   000042   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000045   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   3912          
   3913              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) ||
   3914                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00004B                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00004B   AC..         MOV       R4,?XSP + 0
   \   00004D   AD..         MOV       R5,?XSP + 1
   \   00004F   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000052   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000055   E9           MOV       A,R1
   \   000056   700A         JNZ       ??APSME_TCLinkKeySync_1
   \   000058                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000058   AA..         MOV       R2,?XSP + 0
   \   00005A   AB..         MOV       R3,?XSP + 1
   \   00005C   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   00005F   E9           MOV       A,R1
   \   000060   603C         JZ        ??APSME_TCLinkKeySync_2
   3915              {
   3916                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   3917          
   3918                // verify that the incoming frame counter is valid
   3919                if ( si->frmCntr >= *tclkRxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   000062   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   000065   78..         MOV       R0,#?V0
   \   000067   12....       LCALL     ?L_MOV_X
   \   00006A   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   00006D   12....       LCALL     ?UL_GT_X
   \   000070   4029         JC        ??APSME_TCLinkKeySync_3
   3920                {
   3921                  // set the keyNvId to use
   3922                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000072   EE           MOV       A,R6
   \   000073   240F         ADD       A,#0xf
   \   000075   F582         MOV       DPL,A
   \   000077   E4           CLR       A
   \   000078   3F           ADDC      A,R7
   \   000079   F583         MOV       DPH,A
   \   00007B   7401         MOV       A,#0x1
   \   00007D   F0           MOVX      @DPTR,A
   \   00007E   A3           INC       DPTR
   \   00007F   F0           MOVX      @DPTR,A
   3923          
   3924                  // update the rx frame counter
   3925                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   000080   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000083   12....       LCALL     ?L_MOV_X
   \   000086   90....       MOV       DPTR,#__Constant_1
   \   000089   78..         MOV       R0,#?V0
   \   00008B   12....       LCALL     ?L_ADD_X
   \   00008E   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?L_MOV_TO_X
   3926          
   3927                  status = ZSuccess;
   \   000096   75..00       MOV       ?V0,#0x0
   \   000099   8003         SJMP      ??APSME_TCLinkKeySync_2
   3928                }
   3929                else
   3930                {
   3931                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   00009B   75..A2       MOV       ?V0,#-0x5e
   3932                }
   3933                // break from the loop
   3934                break;
   3935              }
   3936            }
   3937          
   3938            // clear copy of key in RAM
   3939            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   00009E                ; Setup parameters for call to function osal_memset
   \   00009E   7C20         MOV       R4,#0x20
   \   0000A0   7D00         MOV       R5,#0x0
   \   0000A2   7900         MOV       R1,#0x0
   \   0000A4   AA..         MOV       R2,?XSP + 0
   \   0000A6   AB..         MOV       R3,?XSP + 1
   \   0000A8   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3940          
   3941            return status;
   \   0000AB   A9..         MOV       R1,?V0
   \   0000AD   7420         MOV       A,#0x20
   \   0000AF   02....       LJMP      ?Subroutine6 & 0xFFFF
   3942          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   EE           MOV       A,R6
   \   000001   2412         ADD       A,#0x12
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F583         MOV       DPH,A
   \   000009   78..         MOV       R0,#?V0
   \   00000B   22           RET
   3943          
   3944          /******************************************************************************
   3945           * @fn          APSME_TCLinkKeyLoad
   3946           *
   3947           * @brief       Load Trust Center LINK key data.
   3948           *
   3949           * @param       dstAddr - [in] dstAddr
   3950           * @param       si      - [in, out] SSP_Info_t
   3951           *
   3952           * @return      ZStatus_t
   3953           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3954          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3955          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV       A,#-0x2d
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V0,R4
   \   00000C   8D..         MOV       ?V1,R5
   3956            uint8 i;
   3957            ZStatus_t status = ZSecNoKey;
   \   00000E   7EA1         MOV       R6,#-0x5f
   3958            APSME_TCLinkKey_t tcLinkKey;
   3959            AddrMgrEntry_t addrEntry;
   3960            uint32 *tclkTxFrmCntr;
   3961            uint8 extAddrFound;
   3962            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   3963          
   3964            // Look up the ami of the srcAddr if available
   3965            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000010   85..82       MOV       DPL,?XSP + 0
   \   000013   85..83       MOV       DPH,?XSP + 1
   \   000016   E4           CLR       A
   \   000017   F0           MOVX      @DPTR,A
   3966            addrEntry.nwkAddr = dstAddr;
   \   000018   04           INC       A
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine129_0 & 0xFFFF
   3967          
   3968            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_249:
   \   00001F   EC           MOV       A,R4
   \   000020   2406         ADD       A,#0x6
   \   000022   F5..         MOV       ?V2,A
   \   000024   E4           CLR       A
   \   000025   35..         ADDC      A,?V1
   \   000027   F5..         MOV       ?V3,A
   \   000029                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000029   AC..         MOV       R4,?V2
   \   00002B   FD           MOV       R5,A
   \   00002C   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3969          
   3970            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \   00002F                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002F   AA..         MOV       R2,?V2
   \   000031   AB..         MOV       R3,?V3
   \   000033   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000036   E9           MOV       A,R1
   \   000037   FF           MOV       R7,A
   3971          
   3972            // Look up the TC link key associated with the device
   3973            // or the master TC link key (ami = 0xFFFF), whichever is found
   3974            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3975            {
   3976              // Read entry i of the TC link key table from NV
   3977              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   3978                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000038                ; Setup parameters for call to function osal_nv_read
   \   000038   740D         MOV       A,#0xd
   \   00003A   12....       LCALL     ?XSTACK_DISP100_8
   \   00003D   88..         MOV       ?V2,R0
   \   00003F   89..         MOV       ?V3,R1
   \   000041   78..         MOV       R0,#?V2
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   75..20       MOV       ?V2,#0x20
   \   000049   75..00       MOV       ?V3,#0x0
   \   00004C   78..         MOV       R0,#?V2
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   3979          
   3980              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000057   EF           MOV       A,R7
   \   000058   6014         JZ        ??APSME_TCLinkKeyLoad_0
   \   00005A                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00005A   740D         MOV       A,#0xd
   \   00005C   12....       LCALL     ?XSTACK_DISP102_8
   \   00005F   E5..         MOV       A,?V0
   \   000061   2406         ADD       A,#0x6
   \   000063   FA           MOV       R2,A
   \   000064   E4           CLR       A
   \   000065   35..         ADDC      A,?V1
   \   000067   FB           MOV       R3,A
   \   000068   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00006B   E9           MOV       A,R1
   \   00006C   700C         JNZ       ??APSME_TCLinkKeyLoad_1
   3981              {
   3982                status = ZSuccess;
   3983          
   3984                break; // break from the loop
   3985              }
   3986          
   3987              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00006E                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00006E   740D         MOV       A,#0xd
   \   000070   12....       LCALL     ?XSTACK_DISP101_8
   \   000073   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000076   E9           MOV       A,R1
   \   000077   6046         JZ        ??APSME_TCLinkKeyLoad_2
   3988              {
   3989                if ( !extAddrFound )
   \   000079   EF           MOV       A,R7
   3990                {
   3991                  status = ZSuccess;
   3992          
   3993                  break; // break from the loop
   3994                }
   3995          
   3996                // Remember the default TCLK index
   3997                defaultTCLKIdx = i;
   3998              }
   3999            }
   4000          
   4001            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   4002            {
   4003              // Exact match was not found; use the default TC Link Key
   4004              i = defaultTCLKIdx;
   4005              status = ZSuccess;
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00007A   7E00         MOV       R6,#0x0
   4006            }
   4007          
   4008            if ( status == ZSuccess )
   4009            {
   4010              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4011          
   4012              // set the keyNvId to use
   4013              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   00007C   E5..         MOV       A,?V0
   \   00007E   240F         ADD       A,#0xf
   \   000080   F582         MOV       DPL,A
   \   000082   E4           CLR       A
   \   000083   35..         ADDC      A,?V1
   \   000085   F583         MOV       DPH,A
   \   000087   7401         MOV       A,#0x1
   \   000089   F0           MOVX      @DPTR,A
   \   00008A   A3           INC       DPTR
   \   00008B   F0           MOVX      @DPTR,A
   4014          
   4015              // update link key related fields
   4016              si->keyID   = SEC_KEYID_LINK;
   \   00008C   E5..         MOV       A,?V0
   \   00008E   240E         ADD       A,#0xe
   \   000090   F582         MOV       DPL,A
   \   000092   E4           CLR       A
   \   000093   35..         ADDC      A,?V1
   \   000095   F583         MOV       DPH,A
   \   000097   E4           CLR       A
   \   000098   F0           MOVX      @DPTR,A
   4017              si->frmCntr = *tclkTxFrmCntr;
   \   000099   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   00009C   12....       LCALL     ?XLOAD_R0123
   \   00009F   E5..         MOV       A,?V0
   \   0000A1   2412         ADD       A,#0x12
   \   0000A3   F582         MOV       DPL,A
   \   0000A5   E4           CLR       A
   \   0000A6   35..         ADDC      A,?V1
   \   0000A8   F583         MOV       DPH,A
   \   0000AA   12....       LCALL     ?XSTORE_R0123
   4018          
   4019              // update outgoing frame counter
   4020              (*tclkTxFrmCntr)++;
   \   0000AD   90....       MOV       DPTR,#__Constant_1
   \   0000B0   78..         MOV       R0,#?V0
   \   0000B2   12....       LCALL     ?L_MOV_X
   \   0000B5   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   0000B8   78..         MOV       R0,#?V0
   \   0000BA   12....       LCALL     ?L_ADD_TO_X
   \   0000BD   8013         SJMP      ??APSME_TCLinkKeyLoad_3
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000BF                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   4021          
   4022          #if defined ( NV_RESTORE )
   4023              // write periodically to NV
   4024              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4025              {
   4026                // set the flag to write key to NV
   4027                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4028          
   4029                // Notify the ZDApp that the frame counter has changed.
   4030                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4031              }
   4032          #endif
   4033            }
   \   0000BF   AA..         MOV       R2,?XSP + 0
   \   0000C1   AB..         MOV       R3,?XSP + 1
   \   0000C3   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0000C6   E9           MOV       A,R1
   \   0000C7   6401         XRL       A,#0x1
   \   0000C9   7007         JNZ       ??APSME_TCLinkKeyLoad_3
   4034          
   4035            // If no TC link key found, remove the device from the address manager
   4036            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   4037            {
   4038              AddrMgrEntryRelease( &addrEntry );
   \   0000CB                ; Setup parameters for call to function AddrMgrEntryRelease
   \   0000CB   AA..         MOV       R2,?XSP + 0
   \   0000CD   AB..         MOV       R3,?XSP + 1
   \   0000CF   12....       LCALL     `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   4039            }
   4040          
   4041              // clear copy of key in RAM
   4042            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000D2                ; Setup parameters for call to function osal_memset
   \   0000D2   7C20         MOV       R4,#0x20
   \   0000D4   7D00         MOV       R5,#0x0
   \   0000D6   7900         MOV       R1,#0x0
   \   0000D8   740D         MOV       A,#0xd
   \   0000DA   12....       LCALL     ?XSTACK_DISP101_8
   \   0000DD   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4043          
   4044            return status;
   \   0000E0   EE           MOV       A,R6
   \   0000E1   F9           MOV       R1,A
   \   0000E2   742D         MOV       A,#0x2d
   \   0000E4   02....       LJMP      ?Subroutine6 & 0xFFFF
   4045          }
   4046          
   4047          /******************************************************************************
   4048           * @fn          APSME_IsDefaultTCLK
   4049           *
   4050           * @brief       Return TRUE or FALSE based on the extended address.  If the
   4051           *              input ext address is all FFs, it means the trust center link
   4052           *              assoiciated with the address is the default trust center link key
   4053           *
   4054           * @param       extAddr - [in] extended address
   4055           *
   4056           * @return      uint8 TRUE/FALSE
   4057           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4058          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4059          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   4060            uint8 i = 0;
   \   000005   7C00         MOV       R4,#0x0
   4061          
   4062            if( extAddr == NULL )
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   6020         JZ        ??APSME_IsDefaultTCLK_0
   4063            {
   4064              return FALSE;
   4065            }
   4066          
   4067            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_1:
   \   00000B   EC           MOV       A,R4
   \   00000C   FD           MOV       R5,A
   \   00000D   7401         MOV       A,#0x1
   \   00000F   2D           ADD       A,R5
   \   000010   FC           MOV       R4,A
   \   000011   ED           MOV       A,R5
   \   000012   C3           CLR       C
   \   000013   9408         SUBB      A,#0x8
   \   000015   5018         JNC       ??APSME_IsDefaultTCLK_2
   4068            {
   4069              if( *extAddr++ != 0xFF )
   \   000017   EA           MOV       A,R2
   \   000018   F8           MOV       R0,A
   \   000019   EB           MOV       A,R3
   \   00001A   8882         MOV       DPL,R0
   \   00001C   F583         MOV       DPH,A
   \   00001E   A3           INC       DPTR
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   8882         MOV       DPL,R0
   \   000025   F583         MOV       DPH,A
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F4           CPL       A
   \   000029   60E0         JZ        ??APSME_IsDefaultTCLK_1
   4070              {
   4071                return FALSE;
   \                     ??APSME_IsDefaultTCLK_0:
   \   00002B   7900         MOV       R1,#0x0
   \   00002D   8002         SJMP      ??APSME_IsDefaultTCLK_3
   4072              }
   4073            }
   4074          
   4075            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   00002F   7901         MOV       R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   000031   02....       LJMP      ??Subroutine127_0 & 0xFFFF
   4076          }
   4077          
   4078          /******************************************************************************
   4079           * @fn          ZDSecMgrNwkKeyInit
   4080           *
   4081           * @brief       Initialize the NV items for
   4082           *                  ZCD_NV_NWKKEY,
   4083           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   4084           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   4085           *
   4086           * @param       setDefault
   4087           *
   4088           * @return      none
   4089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4090          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4091          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV       A,#-0x26
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4092            uint8 status;
   4093            nwkKeyDesc nwkKey;
   4094          
   4095            // Initialize NV items for NWK key, this structure contains the frame counter
   4096            // and is only used when NV_RESTORE is enabled
   4097            nwkActiveKeyItems keyItems;
   4098          
   4099            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV       R4,#0x15
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   7411         MOV       A,#0x11
   \   000012   12....       LCALL     ?XSTACK_DISP101_8
   \   000015   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4100          
   4101            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4102          
   4103          #if defined ( NV_RESTORE )
   4104            // reset the values of NV items if NV_RESTORE is not enabled
   4105            if ((status == SUCCESS) && (setDefault == TRUE))
   4106            {
   4107              // clear NV data to default values
   4108              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4109            }
   4110          #else
   4111            (void)setDefault;   // to eliminate compiler warning
   4112          
   4113            // reset the values of NV items if NV_RESTORE is not enabled
   4114            if (status == SUCCESS)
   \   000018                ; Setup parameters for call to function osal_nv_item_init
   \   000018   7411         MOV       A,#0x11
   \   00001A   12....       LCALL     ?XSTACK_DISP100_8
   \   00001D   88..         MOV       ?V0,R0
   \   00001F   89..         MOV       ?V1,R1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C15         MOV       R4,#0x15
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7A82         MOV       R2,#-0x7e
   \   00002C   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   00002F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000032   E9           MOV       A,R1
   \   000033   701E         JNZ       ??ZDSecMgrNwkKeyInit_0
   4115            {
   4116              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000035                ; Setup parameters for call to function osal_nv_write
   \   000035   78..         MOV       R0,#?V0
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   75..15       MOV       ?V0,#0x15
   \   00003D   75..00       MOV       ?V1,#0x0
   \   000040   78..         MOV       R0,#?V0
   \   000042   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000045   7C00         MOV       R4,#0x0
   \   000047   7D00         MOV       R5,#0x0
   \   000049   7A82         MOV       R2,#-0x7e
   \   00004B   7B00         MOV       R3,#0x0
   \   00004D   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   4117            }
   \                     ??CrossCallReturnLabel_161:
   \   000050   12....       LCALL     ?DEALLOC_XSTACK8
   4118          #endif // defined (NV_RESTORE)
   4119          
   4120            // Initialize NV items for NWK Active and Alternate keys. These items are used
   4121            // all the time, independently of NV_RESTORE being set or not
   4122            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000053                ; Setup parameters for call to function osal_memset
   \   000053   7C11         MOV       R4,#0x11
   \   000055   7D00         MOV       R5,#0x0
   \   000057   7900         MOV       R1,#0x0
   \   000059   AA..         MOV       R2,?XSP + 0
   \   00005B   AB..         MOV       R3,?XSP + 1
   \   00005D   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4123          
   4124            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4125          
   4126          #if defined ( NV_RESTORE )
   4127            // reset the values of NV items if NV_RESTORE is not enabled
   4128            if ((status == SUCCESS) && (setDefault == TRUE))
   4129            {
   4130              // clear NV data to default values
   4131              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4132            }
   4133          #else
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if (status == SUCCESS)
   \   000060                ; Setup parameters for call to function osal_nv_item_init
   \   000060   A8..         MOV       R0,?XSP + 0
   \   000062   A9..         MOV       R1,?XSP + 1
   \   000064   88..         MOV       ?V0,R0
   \   000066   89..         MOV       ?V1,R1
   \   000068   78..         MOV       R0,#?V0
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006D   7C11         MOV       R4,#0x11
   \   00006F   7D00         MOV       R5,#0x0
   \   000071   7A3A         MOV       R2,#0x3a
   \   000073   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   000076   12....       LCALL     ?DEALLOC_XSTACK8
   \   000079   E9           MOV       A,R1
   \   00007A   701E         JNZ       ??ZDSecMgrNwkKeyInit_1
   4136            {
   4137              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   00007C                ; Setup parameters for call to function osal_nv_write
   \   00007C   78..         MOV       R0,#?V0
   \   00007E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000081   75..11       MOV       ?V0,#0x11
   \   000084   75..00       MOV       ?V1,#0x0
   \   000087   78..         MOV       R0,#?V0
   \   000089   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008C   7C00         MOV       R4,#0x0
   \   00008E   7D00         MOV       R5,#0x0
   \   000090   7A3A         MOV       R2,#0x3a
   \   000092   7B00         MOV       R3,#0x0
   \   000094   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   4138            }
   \                     ??CrossCallReturnLabel_162:
   \   000097   12....       LCALL     ?DEALLOC_XSTACK8
   4139          #endif // defined (NV_RESTORE)
   4140          
   4141            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4142          
   4143          #if defined ( NV_RESTORE )
   4144            // reset the values of NV items if NV_RESTORE is not enabled
   4145            if ((status == SUCCESS) && (setDefault == TRUE))
   4146            {
   4147              // clear NV data to default values
   4148              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4149            }
   4150          #else
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   00009A                ; Setup parameters for call to function osal_nv_item_init
   \   00009A   A8..         MOV       R0,?XSP + 0
   \   00009C   A9..         MOV       R1,?XSP + 1
   \   00009E   88..         MOV       ?V0,R0
   \   0000A0   89..         MOV       ?V1,R1
   \   0000A2   78..         MOV       R0,#?V0
   \   0000A4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A7   7C11         MOV       R4,#0x11
   \   0000A9   7D00         MOV       R5,#0x0
   \   0000AB   7A3B         MOV       R2,#0x3b
   \   0000AD   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   0000B0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B3   E9           MOV       A,R1
   \   0000B4   701E         JNZ       ??ZDSecMgrNwkKeyInit_2
   4153            {
   4154              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000B6                ; Setup parameters for call to function osal_nv_write
   \   0000B6   78..         MOV       R0,#?V0
   \   0000B8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000BB   75..11       MOV       ?V0,#0x11
   \   0000BE   75..00       MOV       ?V1,#0x0
   \   0000C1   78..         MOV       R0,#?V0
   \   0000C3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C6   7C00         MOV       R4,#0x0
   \   0000C8   7D00         MOV       R5,#0x0
   \   0000CA   7A3B         MOV       R2,#0x3b
   \   0000CC   7B00         MOV       R3,#0x0
   \   0000CE   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   4155            }
   \                     ??CrossCallReturnLabel_163:
   \   0000D1   12....       LCALL     ?DEALLOC_XSTACK8
   4156          #endif // defined (NV_RESTORE)
   4157          
   4158          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   0000D4   7426         MOV       A,#0x26
   \   0000D6   02....       LJMP      ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   7B00         MOV       R3,#0x0
   \   000002                REQUIRE ??Subroutine146_0
   \   000002                ; // Fall through to label ??Subroutine146_0
   4159          
   4160          /*********************************************************************
   4161           * @fn          ZDSecMgrReadKeyFromNv
   4162           *
   4163           * @brief       Looks for a specific key in NV based on Index value
   4164           *
   4165           * @param   keyNvId - Index of key to look in NV
   4166           *                    valid values are:
   4167           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   4168           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   4169           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4170           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4171           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4172           *                    ZCD_NV_PRECFGKEY
   4173           *
   4174           * @param  *keyinfo - Data is read into this buffer.
   4175           *
   4176           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4177           *          Otherwise, NV_OPER_FAILED for failure.
   4178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4179          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4180          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4181            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4182                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV       A,#0x3a
   \   000007   6A           XRL       A,R2
   \   000008   7001         JNZ       ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV       A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6006         JZ        ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV       A,#0x3b
   \   00000F   6A           XRL       A,R2
   \   000010   4B           ORL       A,R3
   \   000011   7018         JNZ       ??ZDSecMgrReadKeyFromNv_2
   4183            {
   4184              // get NWK active or alternate key from NV
   4185              return (osal_nv_read(keyNvId,
   4186                                   osal_offsetof(nwkKeyDesc, key),
   4187                                   SEC_KEY_LEN,
   4188                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000013                ; Setup parameters for call to function osal_nv_read
   \   000013   8C..         MOV       ?V0,R4
   \   000015   8D..         MOV       ?V1,R5
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   75..10       MOV       ?V0,#0x10
   \   00001F   75..00       MOV       ?V1,#0x0
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000027   7C01         MOV       R4,#0x1
   \   000029   8062         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4189            }
   4190            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4191                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00002B   EA           MOV       A,R2
   \   00002C   24FF         ADD       A,#-0x1
   \   00002E   F8           MOV       R0,A
   \   00002F   EB           MOV       A,R3
   \   000030   34FE         ADDC      A,#-0x2
   \   000032   F9           MOV       R1,A
   \   000033   E8           MOV       A,R0
   \   000034   49           ORL       A,R1
   \   000035   7018         JNZ       ??ZDSecMgrReadKeyFromNv_4
   4192            {
   4193              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4194              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4195              return (osal_nv_read(keyNvId,
   4196                                   osal_offsetof(APSME_TCLinkKey_t, key),
   4197                                   SEC_KEY_LEN,
   4198                                   keyinfo));
   \   000037                ; Setup parameters for call to function osal_nv_read
   \   000037   8C..         MOV       ?V0,R4
   \   000039   8D..         MOV       ?V1,R5
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..10       MOV       ?V0,#0x10
   \   000043   75..00       MOV       ?V1,#0x0
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   7C08         MOV       R4,#0x8
   \   00004D   803E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4199            }
   4200            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4201                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00004F   19           DEC       R1
   \   000050   C3           CLR       C
   \   000051   E8           MOV       A,R0
   \   000052   12....       LCALL     ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000055   5018         JNC       ??ZDSecMgrReadKeyFromNv_5
   4202            {
   4203              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4204              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4205              return (osal_nv_read(keyNvId,
   4206                                   osal_offsetof(APSME_LinkKeyData_t, key),
   4207                                   SEC_KEY_LEN,
   4208                                   keyinfo));
   \   000057                ; Setup parameters for call to function osal_nv_read
   \   000057   8C..         MOV       ?V0,R4
   \   000059   8D..         MOV       ?V1,R5
   \   00005B   78..         MOV       R0,#?V0
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000060   75..10       MOV       ?V0,#0x10
   \   000063   75..00       MOV       ?V1,#0x0
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV       R4,#0x0
   \   00006D   801E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4209            }
   4210            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4211                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   00006F   19           DEC       R1
   \   000070   C3           CLR       C
   \   000071   E8           MOV       A,R0
   \   000072   12....       LCALL     ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000075   501A         JNC       ??ZDSecMgrReadKeyFromNv_6
   4212            {
   4213              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4214              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4215              return (osal_nv_read(keyNvId,
   4216                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   4217                                   SEC_KEY_LEN,
   4218                                   keyinfo));
   \   000077                ; Setup parameters for call to function osal_nv_read
   \   000077   8C..         MOV       ?V0,R4
   \   000079   8D..         MOV       ?V1,R5
   \   00007B   78..         MOV       R0,#?V0
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000080   75..10       MOV       ?V0,#0x10
   \   000083   75..00       MOV       ?V1,#0x0
   \   000086   78..         MOV       R0,#?V0
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008B   7C02         MOV       R4,#0x2
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00008D   7D00         MOV       R5,#0x0
   \   00008F   8022         SJMP      ??ZDSecMgrReadKeyFromNv_7
   4219            }
   4220            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   000091   7462         MOV       A,#0x62
   \   000093   6A           XRL       A,R2
   \   000094   4B           ORL       A,R3
   \   000095   7024         JNZ       ??ZDSecMgrReadKeyFromNv_8
   4221            {
   4222              // Read entry keyNvId of the Preconfig key from NV.
   4223              return (osal_nv_read(keyNvId,
   4224                                   0,
   4225                                   SEC_KEY_LEN,
   4226                                   keyinfo));
   \   000097                ; Setup parameters for call to function osal_nv_read
   \   000097   8C..         MOV       ?V0,R4
   \   000099   8D..         MOV       ?V1,R5
   \   00009B   78..         MOV       R0,#?V0
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   75..10       MOV       ?V0,#0x10
   \   0000A3   75..00       MOV       ?V1,#0x0
   \   0000A6   78..         MOV       R0,#?V0
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   7C00         MOV       R4,#0x0
   \   0000AD   7D00         MOV       R5,#0x0
   \   0000AF   7A62         MOV       R2,#0x62
   \   0000B1   7B00         MOV       R3,#0x0
   4227            }
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000B3   12....       LCALL     ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0000B6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B9   8002         SJMP      ??ZDSecMgrReadKeyFromNv_9
   4228          
   4229            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000BB   790A         MOV       R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   0000BD   02....       LJMP      ??Subroutine119_0 & 0xFFFF
   4230          }
   4231          
   4232          /******************************************************************************
   4233           * @fn          ZDSecMgrApsLinkKeyInit
   4234           *
   4235           * @brief       Initialize the NV table for Application link keys
   4236           *
   4237           * @param       none
   4238           *
   4239           * @return      none
   4240           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4241          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4242          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV       A,#-0x18
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4243            APSME_LinkKeyData_t pApsLinkKey;
   4244            uint8 i;
   4245            uint8 status;
   4246          
   4247            // Initialize all NV items for APS link key, if not exist already.
   4248            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV       R4,#0x18
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4249          
   4250            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   7E00         MOV       R6,#0x0
   4251            {
   4252              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   4253                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4254          
   4255          #if defined ( NV_RESTORE )
   4256              (void)status;   // to eliminate compiler warning
   4257          #else
   4258              // reset the values of NV items if NV_RESTORE is not enabled
   4259              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000019                ; Setup parameters for call to function osal_nv_item_init
   \   000019   A8..         MOV       R0,?XSP + 0
   \   00001B   A9..         MOV       R1,?XSP + 1
   \   00001D   88..         MOV       ?V0,R0
   \   00001F   89..         MOV       ?V1,R1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C18         MOV       R4,#0x18
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   EE           MOV       A,R6
   \   00002B   2401         ADD       A,#0x1
   \   00002D   FA           MOV       R2,A
   \   00002E   E4           CLR       A
   \   00002F   3402         ADDC      A,#0x2
   \   000031   FB           MOV       R3,A
   \   000032   12....       LCALL     ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   000035   12....       LCALL     ?DEALLOC_XSTACK8
   \   000038   E9           MOV       A,R1
   \   000039   701F         JNZ       ??ZDSecMgrApsLinkKeyInit_1
   4260              {
   4261                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   4262                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00003B                ; Setup parameters for call to function osal_nv_write
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..18       MOV       ?V0,#0x18
   \   000043   75..00       MOV       ?V1,#0x0
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   7C00         MOV       R4,#0x0
   \   00004D   7D00         MOV       R5,#0x0
   \   00004F   EE           MOV       A,R6
   \   000050   2401         ADD       A,#0x1
   \   000052   FA           MOV       R2,A
   \   000053   E4           CLR       A
   \   000054   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   4263          
   4264              }
   4265          #endif // defined (NV_RESTORE)
   4266            }
   \                     ??CrossCallReturnLabel_152:
   \   000057   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   00005A   0E           INC       R6
   \   00005B   EE           MOV       A,R6
   \   00005C   C3           CLR       C
   \   00005D   9403         SUBB      A,#0x3
   \   00005F   40B8         JC        ??ZDSecMgrApsLinkKeyInit_0
   4267          }
   \   000061   7418         MOV       A,#0x18
   \   000063   02....       LJMP      ??Subroutine118_0 & 0xFFFF
   4268          
   4269          /******************************************************************************
   4270           * @fn          ZDSecMgrInitNVKeyTables
   4271           *
   4272           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4273           *
   4274           * @param       setDefault - TRUE to set default values
   4275           *
   4276           * @return      none
   4277           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4278          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4279          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   4280            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL     `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   4281            ZDSecMgrMasterKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000A   12....       LCALL     `??ZDSecMgrMasterKeyInit::?relay`; Banked call to: ZDSecMgrMasterKeyInit
   4282            ZDSecMgrApsLinkKeyInit();
   \   00000D                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000D   12....       LCALL     `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   4283            APSME_TCLinkKeyInit(setDefault);
   \   000010                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000010   EE           MOV       A,R6
   \   000011   F9           MOV       R1,A
   \   000012   12....       LCALL     `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   4284          }
   \   000015   02....       LJMP      ??Subroutine127_0 & 0xFFFF
   4285          
   4286          /******************************************************************************
   4287           * @fn          ZDSecMgrSaveApsLinkKey
   4288           *
   4289           * @brief       Save APS Link Key to NV. It will loop through all the keys
   4290           *              to see which one to save.
   4291           *
   4292           * @param       none
   4293           *
   4294           * @return      none
   4295           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4296          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4297          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   4298            APSME_LinkKeyData_t *pKeyData = NULL;
   4299            int i;
   4300          
   4301            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   12....       LCALL     ?Subroutine72 & 0xFFFF
   4302          
   4303            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_106:
   \   000008   7003         JNZ       $+5
   \   00000A   02....       LJMP      ??CrossCallReturnLabel_52 & 0xFFFF
   4304            {
   4305              // checks all pending flags to know which one to save
   4306              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   00000D   7E00         MOV       R6,#0x0
   \   00000F   7F00         MOV       R7,#0x0
   4307              {
   4308                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   000011   EE           MOV       A,R6
   \   000012   F8           MOV       R0,A
   \   000013   EF           MOV       A,R7
   \   000014   F9           MOV       R1,A
   \   000015   E8           MOV       A,R0
   \   000016   75F009       MOV       B,#0x9
   \   000019   A4           MUL       AB
   \   00001A   F8           MOV       R0,A
   \   00001B   AAF0         MOV       R2,B
   \   00001D   75F009       MOV       B,#0x9
   \   000020   E9           MOV       A,R1
   \   000021   A4           MUL       AB
   \   000022   2A           ADD       A,R2
   \   000023   F9           MOV       R1,A
   \   000024   74..         MOV       A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000026   28           ADD       A,R0
   \   000027   F582         MOV       DPL,A
   \   000029   74..         MOV       A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00002B   39           ADDC      A,R1
   \   00002C   F583         MOV       DPH,A
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   6401         XRL       A,#0x1
   \   000031   6003         JZ        $+5
   \   000033   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   4309                {
   4310                  // retrieve key from NV
   4311                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4312                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000036                ; Setup parameters for call to function osal_nv_read
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   75..18       MOV       ?V0,#0x18
   \   00003E   75..00       MOV       ?V1,#0x0
   \   000041   78..         MOV       R0,#?V0
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   7C00         MOV       R4,#0x0
   \   000048   7D00         MOV       R5,#0x0
   \   00004A   EE           MOV       A,R6
   \   00004B   2401         ADD       A,#0x1
   \   00004D   FA           MOV       R2,A
   \   00004E   EF           MOV       A,R7
   \   00004F   3402         ADDC      A,#0x2
   \   000051   FB           MOV       R3,A
   \   000052   12....       LCALL     ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000055   12....       LCALL     ?DEALLOC_XSTACK8
   \   000058   E9           MOV       A,R1
   \   000059   7074         JNZ       ??ZDSecMgrSaveApsLinkKey_1
   4313                  {
   4314                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00005B   EE           MOV       A,R6
   \   00005C   F8           MOV       R0,A
   \   00005D   EF           MOV       A,R7
   \   00005E   F9           MOV       R1,A
   \   00005F   E8           MOV       A,R0
   \   000060   75F009       MOV       B,#0x9
   \   000063   A4           MUL       AB
   \   000064   F8           MOV       R0,A
   \   000065   AAF0         MOV       R2,B
   \   000067   75F009       MOV       B,#0x9
   \   00006A   E9           MOV       A,R1
   \   00006B   A4           MUL       AB
   \   00006C   2A           ADD       A,R2
   \   00006D   F9           MOV       R1,A
   \   00006E   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   000070   28           ADD       A,R0
   \   000071   F5..         MOV       ?V0,A
   \   000073   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000075   39           ADDC      A,R1
   \   000076   F5..         MOV       ?V1,A
   \   000078   85..82       MOV       DPL,?V0
   \   00007B   F583         MOV       DPH,A
   \   00007D   12....       LCALL     ?XLOAD_R0123
   \   000080   E5..         MOV       A,?V2
   \   000082   2410         ADD       A,#0x10
   \   000084   F582         MOV       DPL,A
   \   000086   E4           CLR       A
   \   000087   35..         ADDC      A,?V3
   \   000089   F583         MOV       DPH,A
   \   00008B   12....       LCALL     ?XSTORE_R0123
   4315                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   00008E   85..82       MOV       DPL,?V0
   \   000091   85..83       MOV       DPH,?V1
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   12....       LCALL     ?XLOAD_R0123
   \   00009B   E5..         MOV       A,?V2
   \   00009D   2414         ADD       A,#0x14
   \   00009F   F582         MOV       DPL,A
   \   0000A1   E4           CLR       A
   \   0000A2   35..         ADDC      A,?V3
   \   0000A4   F583         MOV       DPH,A
   \   0000A6   12....       LCALL     ?XSTORE_R0123
   4316          
   4317                    // Write the APS link key back to the NV
   4318                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4319                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000A9                ; Setup parameters for call to function osal_nv_write
   \   0000A9   78..         MOV       R0,#?V2
   \   0000AB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AE   75..18       MOV       ?V4,#0x18
   \   0000B1   75..00       MOV       ?V5,#0x0
   \   0000B4   78..         MOV       R0,#?V4
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B9   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   0000BC   12....       LCALL     ?DEALLOC_XSTACK8
   4320          
   4321                    // clear the pending write flag
   4322                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000BF   85..82       MOV       DPL,?V0
   \   0000C2   85..83       MOV       DPH,?V1
   \   0000C5   A3           INC       DPTR
   \   0000C6   A3           INC       DPTR
   \   0000C7   A3           INC       DPTR
   \   0000C8   A3           INC       DPTR
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   E4           CLR       A
   \   0000CE   F0           MOVX      @DPTR,A
   4323                  }
   4324                }
   4325              }
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   0000CF   0E           INC       R6
   \   0000D0   EE           MOV       A,R6
   \   0000D1   7001         JNZ       ??ZDSecMgrSaveApsLinkKey_2
   \   0000D3   0F           INC       R7
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000D4   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000D7   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000D9   65D0         XRL       A,PSW
   \   0000DB   33           RLC       A
   \   0000DC   5003         JNC       $+5
   \   0000DE   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   4326          
   4327              // clear copy of key in RAM
   4328              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000E1                ; Setup parameters for call to function osal_memset
   \   0000E1   12....       LCALL     ?Subroutine41 & 0xFFFF
   4329          
   4330              osal_mem_free(pKeyData);
   4331            }
   4332          }
   \                     ??CrossCallReturnLabel_52:
   \   0000E4   02....       LJMP      ?Subroutine2 & 0xFFFF
   4333          
   4334          /******************************************************************************
   4335           * @fn          ZDSecMgrSaveTCLinkKey
   4336           *
   4337           * @brief       Save TC Link Key to NV. It will loop through all the keys
   4338           *              to see which one to save.
   4339           *
   4340           * @param       none
   4341           *
   4342           * @return      none
   4343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4344          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4345          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   4346            APSME_TCLinkKey_t *pKeyData = NULL;
   4347            uint16 i;
   4348          
   4349            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV       R2,#0x20
   \   000007   12....       LCALL     ?Subroutine76 & 0xFFFF
   4350          
   4351            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_110:
   \   00000A   607A         JZ        ??ZDSecMgrSaveTCLinkKey_0
   4352            {
   4353              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4354              {
   4355                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00000C   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 8
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   6401         XRL       A,#0x1
   \   000012   705E         JNZ       ??ZDSecMgrSaveTCLinkKey_1
   4356                {
   4357                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   4358                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000014                ; Setup parameters for call to function osal_nv_read
   \   000014   78..         MOV       R0,#?V0
   \   000016   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000019   75..20       MOV       ?V2,#0x20
   \   00001C   75..00       MOV       ?V3,#0x0
   \   00001F   78..         MOV       R0,#?V2
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000024   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000027   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002A   E9           MOV       A,R1
   \   00002B   7045         JNZ       ??ZDSecMgrSaveTCLinkKey_1
   4359                  {
   4360                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   00002D   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   000030   12....       LCALL     ?XLOAD_R0123
   \   000033   E5..         MOV       A,?V0
   \   000035   2418         ADD       A,#0x18
   \   000037   F582         MOV       DPL,A
   \   000039   E4           CLR       A
   \   00003A   35..         ADDC      A,?V1
   \   00003C   F583         MOV       DPH,A
   \   00003E   12....       LCALL     ?XSTORE_R0123
   4361                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000041   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   000044   12....       LCALL     ?XLOAD_R0123
   \   000047   E5..         MOV       A,?V0
   \   000049   241C         ADD       A,#0x1c
   \   00004B   F582         MOV       DPL,A
   \   00004D   E4           CLR       A
   \   00004E   35..         ADDC      A,?V1
   \   000050   F583         MOV       DPH,A
   \   000052   12....       LCALL     ?XSTORE_R0123
   4362          
   4363                    // Write the TC link key back to the NV
   4364                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   4365                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   000055                ; Setup parameters for call to function osal_nv_write
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   78..         MOV       R0,#?V2
   \   00005C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005F   7C00         MOV       R4,#0x0
   \   000061   7D00         MOV       R5,#0x0
   \   000063   7A01         MOV       R2,#0x1
   \   000065   7B01         MOV       R3,#0x1
   \   000067   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   00006A   12....       LCALL     ?DEALLOC_XSTACK8
   4366          
   4367                    // clear the pending write flag
   4368                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00006D   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 8
   \   000070   E4           CLR       A
   \   000071   F0           MOVX      @DPTR,A
   4369                  }
   4370                }
   4371              }
   4372                // clear copy of key in RAM
   4373              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   000072                ; Setup parameters for call to function osal_memset
   \   000072   7C20         MOV       R4,#0x20
   \   000074   7D00         MOV       R5,#0x0
   \   000076   7900         MOV       R1,#0x0
   \   000078   AA..         MOV       R2,?V0
   \   00007A   AB..         MOV       R3,?V1
   \   00007C   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4374          
   4375              osal_mem_free(pKeyData);
   \   00007F                ; Setup parameters for call to function osal_mem_free
   \   00007F   AA..         MOV       R2,?V0
   \   000081   AB..         MOV       R3,?V1
   \   000083   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4376            }
   4377          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   000086   02....       LJMP      ??Subroutine142_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL     ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000003   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   \   000006   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1
   4378          
   4379          #if defined ( ZBA_FALLBACK_NWKKEY )
   4380          /******************************************************************************
   4381           * @fn          ZDSecMgrFallbackNwkKey
   4382           *
   4383           * @brief       Use the ZBA fallback network key.
   4384           *
   4385           * @param       none
   4386           *
   4387           * @return      none
   4388           */
   4389          void ZDSecMgrFallbackNwkKey( void )
   4390          {
   4391            if ( !_NIB.nwkKeyLoaded )
   4392            {
   4393              uint8 fallbackKey[SEC_KEY_LEN];
   4394          
   4395              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   4396              SSP_UpdateNwkKey( fallbackKey, 0);
   4397              SSP_SwitchNwkKey( 0 );
   4398          
   4399              // clear local copy of key
   4400              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   4401          
   4402              // handle next step in authentication process
   4403              ZDSecMgrAuthNwkKey();
   4404            }
   4405          }
   4406          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   4407          
   4408          #if defined ( NV_RESTORE )
   4409          /******************************************************************************
   4410           * @fn          ZDSecMgrClearNVKeyValues
   4411           *
   4412           * @brief       If NV_RESTORE is enabled and the status of the network needs
   4413           *              default values this fuction clears ZCD_NV_NWKKEY,
   4414           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   4415           *
   4416           * @param       none
   4417           *
   4418           * @return      none
   4419           */
   4420          void ZDSecMgrClearNVKeyValues(void)
   4421          {
   4422            nwkActiveKeyItems keyItems;
   4423            nwkKeyDesc nwkKey;
   4424          
   4425            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4426          
   4427            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4428          
   4429            // Initialize NV items for NWK Active and Alternate keys.
   4430            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4431          
   4432            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4433          
   4434            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4435          }
   4436          #endif // defined ( NV_RESTORE )
   4437          
   4438          /******************************************************************************
   4439          ******************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     66   APSME_IsDefaultTCLK
      0     37   APSME_IsLinkKeyValid
        0     33   -> APSME_LinkKeyNVIdGet
        0     33   -> osal_mem_alloc
        0     36   -> osal_memcmp
        0     33   -> osal_memset
        0     37   -> osal_nv_read
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     44   APSME_LinkKeyNVIdGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     37   APSME_LinkKeySet
        0     21   -> ZDSecMgrEntryLookupExtGetIndex
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     22   -> osal_memcpy
        0     19   -> osal_memset
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
      0     11   APSME_MasterKeyGet
        0     11   -> ZDSecMgrExtAddrLookup
        0     11   -> ZDSecMgrMasterKeyLookup
      0      0   APSME_SKA_TimerExpired
      0     56   APSME_TCLinkKeyInit
        0     46   -> osal_memcpy
        0     43   -> osal_memset
        0     45   -> osal_nv_item_init
        0     47   -> osal_nv_read
        0     47   -> osal_nv_write
      0     61   APSME_TCLinkKeyLoad
        0     57   -> APSME_IsDefaultTCLK
        0     57   -> APSME_LookupExtAddr
        0     57   -> AddrMgrEntryLookupNwk
        0     57   -> AddrMgrEntryRelease
        0     57   -> AddrMgrExtAddrEqual
        0     57   -> AddrMgrExtAddrValid
        0     57   -> osal_memset
        0     61   -> osal_nv_read
      0     48   APSME_TCLinkKeySync
        0     44   -> APSME_IsDefaultTCLK
        0     44   -> APSME_LookupExtAddr
        0     44   -> AddrMgrExtAddrEqual
        0     44   -> AddrMgrExtAddrValid
        0     44   -> osal_memset
        0     48   -> osal_nv_read
      2     12   ZDSecMgrAPSRemove
        2     10   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     35   ZDSecMgrAddrMgrUpdate
        0     22   -> AddrMgrEntryGet
        0     22   -> AddrMgrEntryUpdate
      0     55   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     57   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     57   ZDSecMgrAppKeyReq
        0     49   -> APSME_LookupExtAddr
        0     49   -> APSME_LookupNwkAddr
        0     49   -> APSME_TransportKeyReq
        0     57   -> ZDSecMgrAppKeyGet
        0     49   -> osal_memset
      0     47   ZDSecMgrApsLinkKeyInit
        0     34   -> osal_memset
        0     36   -> osal_nv_item_init
        0     38   -> osal_nv_write
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     25   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      2      0   ZDSecMgrAuthenticateCfm
        2      0   -> osal_set_event
      0     29   ZDSecMgrAuthenticateInd
        0     29   -> APSME_AuthenticateReq
        0     29   -> AddrMgrEntryUpdate
        0     29   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     24   ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlSet
      2      0   ZDSecMgrCtrlInit
        2      0   -> osal_mem_alloc
      0     22   ZDSecMgrCtrlLookup
      2      0   ZDSecMgrCtrlRelease
      0     14   ZDSecMgrCtrlReset
        0     12   -> ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlLookup
        0     14   -> ZDSecMgrCtrlSet
      1     23   ZDSecMgrCtrlSet
      2      2   ZDSecMgrCtrlTerm
        2      2   -> ZDSecMgrCtrlLookup
      1     42   ZDSecMgrDeviceCtrlHandler
        0      9   -> ZDSecMgrEstablishKey
        0      9   -> ZDSecMgrSendMasterKey
        0      9   -> ZDSecMgrSendNwkKey
        0      9   -> osal_start_timerEx
      2      0   ZDSecMgrDeviceCtrlSetup
        2      0   -> ZDSecMgrDeviceCtrlHandler
      0     13   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     43   ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrAddrMgrUpdate
        0     13   -> ZDSecMgrEntryFree
        0     13   -> ZDSecMgrEntryLookup
        0     13   -> ZDSecMgrEntryLookupAMI
        0     13   -> ZDSecMgrEntryNew
      2      0   ZDSecMgrDeviceEntryRemove
        2      0   -> ZDSecMgrEntryFree
      0     24   ZDSecMgrDeviceJoin
        0     14   -> ZDSecMgrAddrStore
        0     12   -> ZDSecMgrDeviceRemove
        0     12   -> ZDSecMgrDeviceValidate
        0     12   -> ZDSecMgrSendNwkKey
      0      9   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      2      8   ZDSecMgrDeviceJoinFwd
        2      8   -> APSME_UpdateDeviceReq
      2     35   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinFwd
      0     38   ZDSecMgrDeviceRemove
        0     19   -> APSME_RemoveDeviceReq
        0     19   -> AssocGetWithExt
        0     19   -> NLME_GetShortAddr
        0     19   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      2     12   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      0     33   ZDSecMgrDeviceValidateCM
        0     32   -> ZDSecMgrAddrStore
        0     30   -> ZDSecMgrDeviceEntryAdd
        0     30   -> ZDSecMgrMasterKeyLoad
        0     33   -> osal_memcpy
        0     30   -> osal_memset
      2      0   ZDSecMgrDeviceValidateRM
      0     40   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      0     31   ZDSecMgrEntryFree
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_write
      2      0   ZDSecMgrEntryInit
        2      0   -> osal_mem_alloc
      0     35   ZDSecMgrEntryLookup
        0     22   -> AddrMgrEntryLookupNwk
      0     23   ZDSecMgrEntryLookupAMI
      0     24   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     32   ZDSecMgrEntryLookupExtGetIndex
        0     11   -> ZDSecMgrExtAddrLookup
      0     23   ZDSecMgrEntryNew
      0     26   ZDSecMgrEstablishKey
        0     17   -> APSME_EstablishKeyReq
        0     17   -> NLME_GetShortAddr
      0      0   ZDSecMgrEstablishKeyCfm
      1     27   ZDSecMgrEstablishKeyInd
        0     27   -> APSME_EstablishKeyRsp
        0     27   -> ZDSecMgrDeviceValidateSKKE
        0     27   -> ZDSecMgrTCDataLoad
        0     27   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     36   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_SecurityNM
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrMasterKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      0     41   ZDSecMgrMasterKeyInit
        0     28   -> osal_memset
        0     30   -> osal_nv_item_init
        0     32   -> osal_nv_write
      0     48   ZDSecMgrMasterKeyLoad
        0     14   -> ZDSecMgrExtAddrLookup
        0     14   -> ZDSecMgrMasterKeyLookup
        0     14   -> ZDSecMgrMasterKeyStore
        0     18   -> osal_nv_write
      0     77   ZDSecMgrMasterKeyLookup
        0     32   -> osal_memset
        0     36   -> osal_nv_read
      0     68   ZDSecMgrMasterKeyStore
        0     36   -> osal_memcpy
        0     33   -> osal_memset
        0     37   -> osal_nv_read
        0     37   -> osal_nv_write
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     39   ZDSecMgrReadKeyFromNv
        0     14   -> osal_nv_read
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      2      4   ZDSecMgrRequestAppKey
        2      4   -> APSME_RequestKeyReq
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     18   ZDSecMgrSaveApsLinkKey
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_read
        0     18   -> osal_nv_write
      0     16   ZDSecMgrSaveTCLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      0     54   ZDSecMgrSendMasterKey
        0     41   -> APSME_TransportKeyReq
        0     41   -> NLME_GetShortAddr
        0     41   -> ZDSecMgrMasterKeyLookup
        0     41   -> osal_memset
        0     45   -> osal_nv_read
      1     56   ZDSecMgrSendNwkKey
        0     40   -> APSME_TransportKeyReq
        0     40   -> NLME_GetShortAddr
        0     44   -> NLME_ReadNwkKeyInfo
        0     40   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0     25   ZDSecMgrSetupPartner
        0     25   -> AddrMgrEntryUpdate
        0     25   -> AddrMgrExtAddrSet
        0     25   -> AddrMgrExtAddrValid
        0     25   -> ZDP_IEEEAddrReq
        0     25   -> ZDP_NwkAddrReq
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      0     61   ZDSecMgrTCDataLoad
        0     33   -> ZDSecMgrAddrStore
        0     31   -> ZDSecMgrMasterKeyLookup
        0     31   -> ZDSecMgrMasterKeyStore
        0     34   -> osal_memcpy
        0     31   -> osal_memset
      0     44   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     25   ZDSecMgrTransportKeyInd
        0     25   -> SSP_SwitchNwkKey
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDSecMgrAuthNwkKey
        0     25   -> ZDSecMgrReadKeyFromNv
        0     25   -> ZDSecMgrTCDataLoad
        0     25   -> osal_memset
      2     10   ZDSecMgrUpdateDeviceInd
        2     10   -> ZDSecMgrDeviceJoin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
       5  ??Subroutine102_0
       6  ??Subroutine103_0
       7  ??Subroutine104_0
       8  ??Subroutine105_0
       2  ??Subroutine106_0
       1  ??Subroutine107_0
       6  ??Subroutine108_0
       6  ??Subroutine109_0
       7  ??Subroutine110_0
       9  ??Subroutine111_0
       6  ??Subroutine112_0
       6  ??Subroutine113_0
       4  ??Subroutine114_0
       5  ??Subroutine115_0
       2  ??Subroutine116_0
       6  ??Subroutine117_0
       3  ??Subroutine118_0
       5  ??Subroutine119_0
       8  ??Subroutine120_0
       2  ??Subroutine121_0
       4  ??Subroutine122_0
       6  ??Subroutine123_0
       7  ??Subroutine124_0
       2  ??Subroutine125_0
       3  ??Subroutine126_0
       5  ??Subroutine127_0
       6  ??Subroutine128_0
       6  ??Subroutine129_0
       6  ??Subroutine130_0
      11  ??Subroutine131_0
       7  ??Subroutine132_0
       6  ??Subroutine133_0
       3  ??Subroutine134_0
       6  ??Subroutine135_0
       5  ??Subroutine136_0
       6  ??Subroutine137_0
       2  ??Subroutine138_0
       9  ??Subroutine139_0
       4  ??Subroutine140_0
       5  ??Subroutine141_0
       5  ??Subroutine142_0
       2  ??Subroutine143_0
       4  ??Subroutine144_0
       6  ??Subroutine145_0
       6  ??Subroutine146_0
       2  ?Subroutine0
       2  ?Subroutine1
       2  ?Subroutine10
       6  ?Subroutine100
       5  ?Subroutine101
       4  ?Subroutine11
       3  ?Subroutine12
      12  ?Subroutine13
       5  ?Subroutine14
       4  ?Subroutine15
      10  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine18
       6  ?Subroutine19
       5  ?Subroutine2
       8  ?Subroutine20
       7  ?Subroutine21
       4  ?Subroutine22
       4  ?Subroutine23
       9  ?Subroutine24
      13  ?Subroutine25
      12  ?Subroutine26
       4  ?Subroutine27
       9  ?Subroutine28
       8  ?Subroutine29
       2  ?Subroutine3
       6  ?Subroutine30
      13  ?Subroutine31
       3  ?Subroutine32
       3  ?Subroutine33
       3  ?Subroutine34
       8  ?Subroutine35
       9  ?Subroutine36
       1  ?Subroutine37
      20  ?Subroutine38
       2  ?Subroutine39
       7  ?Subroutine4
       8  ?Subroutine40
      21  ?Subroutine41
       7  ?Subroutine42
       1  ?Subroutine43
      29  ?Subroutine44
       6  ?Subroutine45
      10  ?Subroutine46
      18  ?Subroutine47
       2  ?Subroutine48
       9  ?Subroutine49
       8  ?Subroutine5
       5  ?Subroutine50
       4  ?Subroutine51
       7  ?Subroutine52
       5  ?Subroutine53
      13  ?Subroutine54
      14  ?Subroutine55
      15  ?Subroutine56
       7  ?Subroutine57
       6  ?Subroutine58
      13  ?Subroutine59
       3  ?Subroutine6
       4  ?Subroutine60
       4  ?Subroutine61
      11  ?Subroutine62
       6  ?Subroutine63
      18  ?Subroutine64
       7  ?Subroutine65
       7  ?Subroutine66
       7  ?Subroutine67
       7  ?Subroutine68
       4  ?Subroutine69
       5  ?Subroutine7
       4  ?Subroutine70
       4  ?Subroutine71
      14  ?Subroutine72
       8  ?Subroutine73
      30  ?Subroutine74
       4  ?Subroutine75
      12  ?Subroutine76
      11  ?Subroutine77
      11  ?Subroutine78
      13  ?Subroutine79
       5  ?Subroutine8
      12  ?Subroutine80
       1  ?Subroutine81
       7  ?Subroutine82
       6  ?Subroutine83
       4  ?Subroutine84
       6  ?Subroutine85
       9  ?Subroutine86
      10  ?Subroutine87
      11  ?Subroutine88
       6  ?Subroutine89
       5  ?Subroutine9
      10  ?Subroutine90
      15  ?Subroutine91
      13  ?Subroutine92
       5  ?Subroutine93
       4  ?Subroutine94
       1  ?Subroutine95
       8  ?Subroutine96
       4  ?Subroutine97
      22  ?Subroutine98
       8  ?Subroutine99
      52  APSME_IsDefaultTCLK
     138  APSME_IsLinkKeyValid
      72  APSME_KeyFwdToChild
      56  APSME_LinkKeyNVIdGet
     252  APSME_LinkKeySet
      55  APSME_MasterKeyGet
       3  APSME_SKA_TimerExpired
     225  APSME_TCLinkKeyInit
     231  APSME_TCLinkKeyLoad
     178  APSME_TCLinkKeySync
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      71  ZDSecMgrAPSRemove
     104  ZDSecMgrAddLinkKey
      66  ZDSecMgrAddrMgrUpdate
      67  ZDSecMgrAddrStore
      43  ZDSecMgrAppKeyGet
     254  ZDSecMgrAppKeyReq
       1  ZDSecMgrAppKeyType
     102  ZDSecMgrApsLinkKeyInit
      23  ZDSecMgrAssocDeviceAuth
      59  ZDSecMgrAuthInitiate
      27  ZDSecMgrAuthNwkKey
      50  ZDSecMgrAuthenticateCfm
     102  ZDSecMgrAuthenticateInd
       5  ZDSecMgrAuthenticationCheck
      33  ZDSecMgrAuthenticationSet
       3  ZDSecMgrConfig
     109  ZDSecMgrCtrlAdd
       2  ZDSecMgrCtrlData
      71  ZDSecMgrCtrlInit
     129  ZDSecMgrCtrlLookup
      18  ZDSecMgrCtrlRelease
      75  ZDSecMgrCtrlReset
      79  ZDSecMgrCtrlSet
      27  ZDSecMgrCtrlTerm
     117  ZDSecMgrDeviceCtrlHandler
      66  ZDSecMgrDeviceCtrlSetup
      91  ZDSecMgrDeviceCtrlUpdate
     137  ZDSecMgrDeviceEntryAdd
      10  ZDSecMgrDeviceEntryRemove
      71  ZDSecMgrDeviceJoin
      35  ZDSecMgrDeviceJoinDirect
     154  ZDSecMgrDeviceJoinFwd
       9  ZDSecMgrDeviceNew
     158  ZDSecMgrDeviceRemove
      29  ZDSecMgrDeviceRemoveByExtAddr
      48  ZDSecMgrDeviceValidate
     121  ZDSecMgrDeviceValidateCM
      17  ZDSecMgrDeviceValidateRM
      50  ZDSecMgrDeviceValidateSKKE
       2  ZDSecMgrEntries
      91  ZDSecMgrEntryFree
      66  ZDSecMgrEntryInit
     137  ZDSecMgrEntryLookup
     102  ZDSecMgrEntryLookupAMI
      54  ZDSecMgrEntryLookupExt
     117  ZDSecMgrEntryLookupExtGetIndex
     119  ZDSecMgrEntryNew
      94  ZDSecMgrEstablishKey
       3  ZDSecMgrEstablishKeyCfm
     184  ZDSecMgrEstablishKeyInd
     237  ZDSecMgrEvent
      69  ZDSecMgrExtAddrLookup
      66  ZDSecMgrExtAddrStore
       3  ZDSecMgrInit
      24  ZDSecMgrInitNVKeyTables
     122  ZDSecMgrMasterKeyInit
      82  ZDSecMgrMasterKeyLoad
     148  ZDSecMgrMasterKeyLookup
     229  ZDSecMgrMasterKeyStore
     178  ZDSecMgrNewDeviceEvent
     217  ZDSecMgrNwkKeyInit
      39  ZDSecMgrPermitJoining
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      24  ZDSecMgrPermitJoiningTimeout
     192  ZDSecMgrReadKeyFromNv
      63  ZDSecMgrRemoveDeviceInd
      38  ZDSecMgrRequestAppKey
      36  ZDSecMgrRequestKeyInd
     231  ZDSecMgrSaveApsLinkKey
     137  ZDSecMgrSaveTCLinkKey
     216  ZDSecMgrSendMasterKey
     252  ZDSecMgrSendNwkKey
     200  ZDSecMgrSetDefaultNV
     115  ZDSecMgrSetupPartner
      23  ZDSecMgrSwitchKeyInd
       1  ZDSecMgrTCAuthenticated
     128  ZDSecMgrTCDataLoad
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      52  ZDSecMgrTCExtAddrCheck
      16  ZDSecMgrTCMasterKey
     192  ZDSecMgrTransportKeyInd
      48  ZDSecMgrUpdateDeviceInd
       4  __Constant_1
     510  -- Other

 
 9 267 bytes in segment BANKED_CODE
   510 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
    84 bytes in segment XDATA_Z
 
   527 bytes of CODE     memory
     0 bytes of CONST    memory (+ 4 bytes shared)
 9 267 bytes of HUGECODE memory
    85 bytes of XDATA    memory

Errors: none
Warnings: none
