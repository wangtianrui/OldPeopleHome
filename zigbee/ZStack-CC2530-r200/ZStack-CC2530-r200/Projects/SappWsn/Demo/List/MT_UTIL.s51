///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              23/Apr/2019  16:49:34
// Copyright 2004-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_UTIL.c
//    Command line       =  
//        -f C:\Users\VULCAN\AppData\Local\Temp\EWEAF9.tmp
//        (E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_UTIL.c
//        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D xMT_SYS_FUNC -D
//        MT_ZDO_FUNC -D SAPP_ZSTACK_DEMO -lC
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
//        -lA
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
//        --diag_suppress Pe001,Pa010 -o
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
//        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0056
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440) -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
//        -I
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
//        -Ohz --require_prototypes --no_code_motion)
//    Locale             =  Chinese (Simplified)_CHN.936
//    List file          =  
//        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List\MT_UTIL.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME MT_UTIL

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_UTIL.c
//    1 /***************************************************************************************************
//    2   Filename:       MT_UTIL.c
//    3   Revised:        $Date: 2011-07-15 15:48:37 -0700 (Fri, 15 Jul 2011) $
//    4   Revision:       $Revision: 26799 $
//    5 
//    6   Description:    MonitorTest Utility Functions
//    7 
//    8   Copyright 2007-2011 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License").  You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product.  Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  ***************************************************************************************************/
//   39 
//   40 /***************************************************************************************************
//   41  * INCLUDES
//   42  ***************************************************************************************************/
//   43 #include "ZComDef.h"
//   44 
//   45 #include "AddrMgr.h"
//   46 
//   47 #include "OnBoard.h"   /* This is here because of the key reading */
//   48 #include "hal_key.h"
//   49 #include "hal_led.h"
//   50 #include "OSAL_Nv.h"
//   51 #include "osal.h"
//   52 #include "NLMEDE.h"
//   53 #include "MT.h"
//   54 #include "MT_UTIL.h"
//   55 #include "MT_MAC.h"
//   56 #include "ssp.h"
//   57 #if defined ZCL_KEY_ESTABLISH
//   58 #include "zcl_key_establish.h"
//   59 #endif
//   60 #if defined TC_LINKKEY_JOIN
//   61 #include "zcl_se.h"
//   62 #endif
//   63 
//   64 #if !defined NONWK
//   65 #include "MT_ZDO.h"
//   66 #include "MT_SAPI.h"
//   67 #include "MT_NWK.h"
//   68 #include "MT_AF.h"
//   69 #include "AssocList.h"
//   70 #include "ZDApp.h"
//   71 #include "ZDSecMgr.h"
//   72 #endif
//   73 /***************************************************************************************************
//   74  * CONSTANTS
//   75  ***************************************************************************************************/
//   76 #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
//   77 #define MT_UTIL_STATUS_LEN    1
//   78 #define MT_UTIL_FRM_CTR_LEN   4
//   79 // Status + LinkKeyDataLen + Tx+Rx Frame counter.
//   80 #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
//   81 // Status + NV id
//   82 #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
//   83 
//   84 /***************************************************************************************************
//   85  * LOCAL VARIABLES
//   86  ***************************************************************************************************/
//   87 #if defined ZCL_KEY_ESTABLISH
//   88 uint8 zcl_key_establish_task_id;
//   89 #endif
//   90 
//   91 /***************************************************************************************************
//   92  * LOCAL FUNCTIONS
//   93  ***************************************************************************************************/
//   94 #ifdef AUTO_PEND
//   95 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
//   96 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
//   97 #endif
//   98 
//   99 #if defined (MT_UTIL_FUNC)
//  100 void MT_UtilGetDeviceInfo(void);
//  101 void MT_UtilGetNvInfo(void);
//  102 void MT_UtilSetPanID(uint8 *pBuf);
//  103 void MT_UtilSetChannels(uint8 *pBuf);
//  104 void MT_UtilSetSecLevel(uint8 *pBuf);
//  105 void MT_UtilSetPreCfgKey(uint8 *pBuf);
//  106 void MT_UtilCallbackSub(uint8 *pData);
//  107 void MT_UtilKeyEvent(uint8 *pBuf);
//  108 void MT_UtilTimeAlive(void);
//  109 void MT_UtilLedControl(uint8 *pBuf);
//  110 void MT_UtilSrcMatchEnable (uint8 *pBuf);
//  111 void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
//  112 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
//  113 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
//  114 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
//  115 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
//  116 
//  117 #if !defined NONWK
//  118 void MT_UtilDataReq(uint8 *pBuf);
//  119 static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf);
//  120 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
//  121 #if defined MT_SYS_KEY_MANAGEMENT
//  122 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
//  123 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
//  124 #endif //MT_SYS_KEY_MANAGEMENT
//  125 static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
//  126 static void MT_UtilAssocCount(uint8 *pBuf);
//  127 static void MT_UtilAssocFindDevice(uint8 *pBuf);
//  128 static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
//  129 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
//  130 #if defined ZCL_KEY_ESTABLISH
//  131 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
//  132 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
//  133 #endif // ZCL_KEY_ESTABLISH
//  134 static void MT_UtilSync(void);
//  135 #endif // !defined NONWK
//  136 #endif // MT_UTIL_FUNC
//  137 
//  138 #if defined (MT_UTIL_FUNC)
//  139 /***************************************************************************************************
//  140  * @fn      MT_UtilProcessing
//  141  *
//  142  * @brief   Process all the DEBUG commands that are issued by test tool
//  143  *
//  144  * @param   pBuf  - pointer to received SPI data message
//  145  *
//  146  * @return  status
//  147  ***************************************************************************************************/
//  148 uint8 MT_UtilCommandProcessing(uint8 *pBuf)
//  149 {
//  150   uint8 status = MT_RPC_SUCCESS;
//  151 
//  152   switch (pBuf[MT_RPC_POS_CMD1])
//  153   {
//  154 // CC253X MAC Network Processor does not have NV support
//  155 #if !defined(CC253X_MACNP)
//  156     case MT_UTIL_GET_DEVICE_INFO:
//  157       MT_UtilGetDeviceInfo();
//  158       break;
//  159 
//  160     case MT_UTIL_GET_NV_INFO:
//  161       MT_UtilGetNvInfo();
//  162       break;
//  163 
//  164     case MT_UTIL_SET_PANID:
//  165       MT_UtilSetPanID(pBuf);
//  166       break;
//  167 
//  168     case MT_UTIL_SET_CHANNELS:
//  169       MT_UtilSetChannels(pBuf);
//  170       break;
//  171 
//  172     case MT_UTIL_SET_SECLEVEL:
//  173       MT_UtilSetSecLevel(pBuf);
//  174       break;
//  175 
//  176     case MT_UTIL_SET_PRECFGKEY:
//  177       MT_UtilSetPreCfgKey(pBuf);
//  178       break;
//  179 #endif
//  180     case MT_UTIL_CALLBACK_SUB_CMD:
//  181       MT_UtilCallbackSub(pBuf);
//  182       break;
//  183 
//  184     case MT_UTIL_KEY_EVENT:
//  185 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  186       MT_UtilKeyEvent(pBuf);
//  187 #endif
//  188       break;
//  189 
//  190     case MT_UTIL_TIME_ALIVE:
//  191       MT_UtilTimeAlive();
//  192       break;
//  193 
//  194     case MT_UTIL_LED_CONTROL:
//  195 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  196       MT_UtilLedControl(pBuf);
//  197 #endif
//  198       break;
//  199 
//  200     case MT_UTIL_SRC_MATCH_ENABLE:
//  201       MT_UtilSrcMatchEnable(pBuf);
//  202       break;
//  203 
//  204     case MT_UTIL_SRC_MATCH_ADD_ENTRY:
//  205       MT_UtilSrcMatchAddEntry(pBuf);
//  206       break;
//  207 
//  208     case MT_UTIL_SRC_MATCH_DEL_ENTRY:
//  209       MT_UtilSrcMatchDeleteEntry(pBuf);
//  210       break;
//  211 
//  212     case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
//  213       MT_UtilSrcMatchCheckSrcAddr(pBuf);
//  214       break;
//  215 
//  216     case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
//  217       MT_UtilSrcMatchAckAllPending(pBuf);
//  218       break;
//  219 
//  220     case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
//  221       MT_UtilSrcMatchCheckAllPending(pBuf);
//  222       break;
//  223 
//  224     case MT_UTIL_TEST_LOOPBACK:
//  225       MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
//  226                                     pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
//  227       break;
//  228 
//  229 #if !defined NONWK
//  230     case MT_UTIL_DATA_REQ:
//  231       MT_UtilDataReq(pBuf);
//  232       break;
//  233 
//  234     case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
//  235       MT_UtilAddrMgrExtAddrLookup(pBuf);
//  236       break;
//  237 
//  238     case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
//  239       MT_UtilAddrMgrEntryLookupNwk(pBuf);
//  240       break;
//  241 
//  242 #if defined MT_SYS_KEY_MANAGEMENT
//  243     case MT_UTIL_APSME_LINK_KEY_DATA_GET:
//  244       MT_UtilAPSME_LinkKeyDataGet(pBuf);
//  245       break;
//  246 
//  247     case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
//  248       MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
//  249       break;
//  250 #endif // MT_SYS_KEY_MANAGEMENT
//  251 
//  252     case MT_UTIL_APSME_REQUEST_KEY_CMD:
//  253       MT_UtilAPSME_RequestKeyCmd(pBuf);
//  254       break;
//  255 
//  256     case MT_UTIL_ASSOC_COUNT:
//  257       MT_UtilAssocCount(pBuf);
//  258       break;
//  259 
//  260     case MT_UTIL_ASSOC_FIND_DEVICE:
//  261       MT_UtilAssocFindDevice(pBuf);
//  262       break;
//  263 
//  264     case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
//  265       MT_UtilAssocGetWithAddress(pBuf);
//  266       break;
//  267 
//  268 #if defined ZCL_KEY_ESTABLISH
//  269     case MT_UTIL_ZCL_KEY_EST_INIT_EST:
//  270       MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
//  271       break;
//  272 
//  273     case MT_UTIL_ZCL_KEY_EST_SIGN:
//  274       MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
//  275       break;
//  276 #endif
//  277 
//  278     case MT_UTIL_SYNC_REQ:
//  279       MT_UtilSync();
//  280       break;
//  281 #endif /* !defined NONWK */
//  282 
//  283     default:
//  284       status = MT_RPC_ERR_COMMAND_ID;
//  285       break;
//  286   }
//  287 
//  288   return status;
//  289 }
//  290 
//  291 /***************************************************************************************************
//  292  * @fn      MT_UtilGetDeviceInfo
//  293  *
//  294  * @brief   The Get Device Info serial message.
//  295  *
//  296  * @param   None.
//  297  *
//  298  * @return  void
//  299  ***************************************************************************************************/
//  300 void MT_UtilGetDeviceInfo(void)
//  301 {
//  302   uint8  *buf;
//  303   uint8  *pBuf;
//  304   uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
//  305   uint16 *assocList = NULL;
//  306 
//  307 #if !defined NONWK
//  308   uint8  assocCnt = 0;
//  309 
//  310   if (ZG_DEVICE_RTR_TYPE)
//  311   {
//  312     assocList = AssocMakeList( &assocCnt );
//  313     bufLen += (assocCnt * sizeof(uint16));
//  314   }
//  315 #endif
//  316 
//  317   buf = osal_mem_alloc( bufLen );
//  318   if ( buf )
//  319   {
//  320     pBuf = buf;
//  321 
//  322     *pBuf++ = ZSUCCESS; // Status
//  323 
//  324     osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  325     pBuf += Z_EXTADDR_LEN;
//  326 
//  327 #if defined NONWK
//  328     // Skip past ZStack only parameters for NONWK
//  329     *pBuf++ = 0;
//  330     *pBuf++ = 0;
//  331     *pBuf++ = 0;
//  332     *pBuf++ = 0;
//  333     *pBuf = 0;
//  334 #else
//  335     {
//  336       uint16 shortAddr = NLME_GetShortAddr();
//  337       *pBuf++ = LO_UINT16( shortAddr );
//  338       *pBuf++ = HI_UINT16( shortAddr );
//  339     }
//  340 
//  341     /* Return device type */
//  342     *pBuf++ = ZSTACK_DEVICE_BUILD;
//  343 
//  344     /*Return device state */
//  345     *pBuf++ = (uint8)devState;
//  346 
//  347     if (ZG_DEVICE_RTR_TYPE)
//  348     {
//  349       *pBuf++ = assocCnt;
//  350 
//  351       if ( assocCnt )
//  352       {
//  353         uint8 x;
//  354         uint16 *puint16 = assocList;
//  355 
//  356         for ( x = 0; x < assocCnt; x++, puint16++ )
//  357         {
//  358           *pBuf++ = LO_UINT16( *puint16 );
//  359           *pBuf++ = HI_UINT16( *puint16 );
//  360         }
//  361       }
//  362     }
//  363     else
//  364     {
//  365       *pBuf++ = 0;
//  366     }
//  367 #endif
//  368 
//  369     MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  370                                  MT_UTIL_GET_DEVICE_INFO,
//  371                                  bufLen, buf );
//  372 
//  373     osal_mem_free( buf );
//  374   }
//  375 
//  376   if ( assocList )
//  377   {
//  378     osal_mem_free( assocList );
//  379   }
//  380 }
//  381 
//  382 /***************************************************************************************************
//  383  * @fn      MT_UtilGetNvInfo
//  384  *
//  385  * @brief   The Get NV Info serial message.
//  386  *
//  387  * @param   None.
//  388  *
//  389  * @return  void
//  390  ***************************************************************************************************/
//  391 void MT_UtilGetNvInfo(void)
//  392 {
//  393   uint8 len;
//  394   uint8 stat;
//  395   uint8 *buf;
//  396   uint8 *pBuf;
//  397   uint16 tmp16;
//  398   uint32 tmp32;
//  399 
//  400   /*
//  401     Get required length of buffer
//  402     Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
//  403   */
//  404   len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
//  405 
//  406   buf = osal_mem_alloc( len );
//  407   if ( buf )
//  408   {
//  409     /* Assume NV not available */
//  410     osal_memset( buf, 0xFF, len );
//  411 
//  412     /* Skip over status */
//  413     pBuf = buf + 1;
//  414 
//  415     /* Start with 64-bit extended address */
//  416     stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  417     if ( stat ) stat = 0x01;
//  418     pBuf += Z_EXTADDR_LEN;
//  419 
//  420     /* Scan channel list (bit mask) */
//  421     if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
//  422       stat |= 0x02;
//  423     else
//  424     {
//  425       pBuf[0] = BREAK_UINT32( tmp32, 3 );
//  426       pBuf[1] = BREAK_UINT32( tmp32, 2 );
//  427       pBuf[2] = BREAK_UINT32( tmp32, 1 );
//  428       pBuf[3] = BREAK_UINT32( tmp32, 0 );
//  429     }
//  430     pBuf += sizeof( tmp32 );
//  431 
//  432     /* ZigBee PanID */
//  433     if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
//  434       stat |= 0x04;
//  435     else
//  436     {
//  437       pBuf[0] = LO_UINT16( tmp16 );
//  438       pBuf[1] = HI_UINT16( tmp16 );
//  439     }
//  440     pBuf += sizeof( tmp16 );
//  441 
//  442     /* Security level */
//  443     if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
//  444       stat |= 0x08;
//  445 
//  446     /* Pre-configured security key */
//  447     if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
//  448       stat |= 0x10;
//  449 
//  450     /* Status bit mask - bit=1 indicates failure */
//  451     *buf = stat;
//  452 
//  453     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
//  454                                   len, buf );
//  455 
//  456     osal_mem_free( buf );
//  457   }
//  458 }
//  459 
//  460 /***************************************************************************************************
//  461  * @fn      MT_UtilSetPanID
//  462  *
//  463  * @brief   Set PanID message
//  464  *
//  465  * @param   pBuf - pointer to the data
//  466  *
//  467  * @return  void
//  468  ***************************************************************************************************/
//  469 void MT_UtilSetPanID(uint8 *pBuf)
//  470 {
//  471   uint16 temp16;
//  472   uint8 retValue = ZFailure;
//  473   uint8 cmdId;
//  474 
//  475   /* parse header */
//  476   cmdId = pBuf[MT_RPC_POS_CMD1];
//  477   pBuf += MT_RPC_FRAME_HDR_SZ;
//  478 
//  479   temp16 = BUILD_UINT16(pBuf[0], pBuf[1]);
//  480   pBuf += sizeof(uint16);
//  481 
//  482   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  483 
//  484   /* Build and send back the response */
//  485   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  486 }
//  487 
//  488 /***************************************************************************************************
//  489  * @fn      MT_UtilSetChannels
//  490  *
//  491  * @brief   Set Channels
//  492  *
//  493  * @param   pBuf - pointer to the data
//  494  *
//  495  * @return  void
//  496  ***************************************************************************************************/
//  497 void MT_UtilSetChannels(uint8 *pBuf)
//  498 {
//  499   uint32 tmp32;
//  500   uint8 retValue = ZFailure;
//  501   uint8 cmdId;
//  502 
//  503   /* parse header */
//  504   cmdId = pBuf[MT_RPC_POS_CMD1];
//  505   pBuf += MT_RPC_FRAME_HDR_SZ;
//  506 
//  507   tmp32 = BUILD_UINT32(pBuf[0], pBuf[1], pBuf[2], pBuf[3]);
//  508 
//  509   retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
//  510 
//  511   /* Build and send back the response */
//  512   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  513 }
//  514 
//  515 /***************************************************************************************************
//  516  * @fn      MT_UtilSetSecLevel
//  517  *
//  518  * @brief   Set Sec Level
//  519  *
//  520  * @param   byte *msg - pointer to the data
//  521  *
//  522  * @return  void
//  523  ***************************************************************************************************/
//  524 void MT_UtilSetSecLevel(uint8 *pBuf)
//  525 {
//  526   uint8 retValue = ZFailure;
//  527   uint8 cmdId;
//  528 
//  529   /* parse header */
//  530   cmdId = pBuf[MT_RPC_POS_CMD1];
//  531   pBuf += MT_RPC_FRAME_HDR_SZ;
//  532 
//  533   retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
//  534 
//  535   /* Build and send back the response */
//  536   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  537 
//  538 }
//  539 
//  540 /***************************************************************************************************
//  541  * @fn      MT_UtilSetPreCfgKey
//  542  *
//  543  * @brief   Set Pre Cfg Key
//  544  *
//  545  * @param   pBuf - pointer to the data
//  546  *
//  547  * @return  void
//  548  ***************************************************************************************************/
//  549 void MT_UtilSetPreCfgKey(uint8 *pBuf)
//  550 {
//  551   uint8 retValue = ZFailure;
//  552   uint8 cmdId;
//  553 
//  554   /* parse header */
//  555   cmdId = pBuf[MT_RPC_POS_CMD1];
//  556   pBuf += MT_RPC_FRAME_HDR_SZ;
//  557 
//  558   retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
//  559 
//  560   /* Build and send back the response */
//  561   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  562 
//  563 }
//  564 
//  565 /***************************************************************************************************
//  566  * @fn      MT_UtilCallbackSub
//  567  *
//  568  * @brief   The Callback subscribe.
//  569  *
//  570  * @param   pBuf - pointer to the data
//  571  *
//  572  * @return  void
//  573  ***************************************************************************************************/
//  574 void MT_UtilCallbackSub(uint8 *pBuf)
//  575 {
//  576   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
//  577   uint8 retValue = ZFailure;
//  578 
//  579 #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
//  580   uint8 subSystem;
//  581   uint16 subscribed_command;
//  582 
//  583   // Move past header
//  584   retValue = ZSuccess;
//  585   pBuf += MT_RPC_FRAME_HDR_SZ;
//  586 
//  587   /* Command */
//  588   subscribed_command = BUILD_UINT16(pBuf[0], pBuf[1]);
//  589   pBuf += 2;
//  590 
//  591   /* Subsystem - 5 bits on the MSB of the command */
//  592   subSystem = HI_UINT16(subscribed_command) & 0x1F ;
//  593 
//  594   /* What is the action - SUBSCRIBE or !SUBSCRIBE */
//  595   if (*pBuf)
//  596   {
//  597     /* Turn ON */
//  598   #if defined( MT_MAC_CB_FUNC )
//  599     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  600       _macCallbackSub = 0xFFFF;
//  601   #endif
//  602 
//  603   #if defined( MT_NWK_CB_FUNC )
//  604     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  605       _nwkCallbackSub = 0xFFFF;
//  606   #endif
//  607 
//  608   #if defined( MT_ZDO_CB_FUNC )
//  609     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  610       _zdoCallbackSub = 0xFFFFFFFF;
//  611   #endif
//  612 
//  613   #if defined( MT_AF_CB_FUNC )
//  614     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  615       _afCallbackSub = 0xFFFF;
//  616   #endif
//  617 
//  618   #if defined( MT_SAPI_CB_FUNC )
//  619     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  620       _sapiCallbackSub = 0xFFFF;
//  621   #endif
//  622   }
//  623   else
//  624   {
//  625     /* Turn OFF */
//  626   #if defined( MT_MAC_CB_FUNC )
//  627     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  628       _macCallbackSub = 0x0000;
//  629   #endif
//  630 
//  631   #if defined( MT_NWK_CB_FUNC )
//  632     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  633       _nwkCallbackSub = 0x0000;
//  634   #endif
//  635 
//  636   #if defined( MT_ZDO_CB_FUNC )
//  637     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  638       _zdoCallbackSub = 0x00000000;
//  639   #endif
//  640 
//  641   #if defined( MT_AF_CB_FUNC )
//  642     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  643       _afCallbackSub = 0x0000;
//  644   #endif
//  645 
//  646   #if defined( MT_SAPI_CB_FUNC )
//  647     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  648         _sapiCallbackSub = 0x0000;
//  649   #endif
//  650   }
//  651 #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
//  652 
//  653   /* Build and send back the response */
//  654   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  655 }
//  656 
//  657 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  658 /***************************************************************************************************
//  659  * @fn      MT_UtilKeyEvent
//  660  *
//  661  * @brief   Process Key Event
//  662  *
//  663  * @param   pBuf - pointer to the data
//  664  *
//  665  * @return  void
//  666  ***************************************************************************************************/
//  667 void MT_UtilKeyEvent(uint8 *pBuf)
//  668 {
//  669   uint8 x = 0;
//  670   uint8 retValue = ZFailure;
//  671   uint8 cmdId;
//  672 
//  673   /* parse header */
//  674   cmdId = pBuf[MT_RPC_POS_CMD1];
//  675   pBuf += MT_RPC_FRAME_HDR_SZ;
//  676 
//  677   /* Translate between SPI values to device values */
//  678   if ( *pBuf & 0x01 )
//  679     x |= HAL_KEY_SW_1;
//  680   if ( *pBuf & 0x02 )
//  681     x |= HAL_KEY_SW_2;
//  682   if ( *pBuf & 0x04 )
//  683     x |= HAL_KEY_SW_3;
//  684   if ( *pBuf & 0x08 )
//  685   x |= HAL_KEY_SW_4;
//  686 #if defined ( HAL_KEY_SW_5 )
//  687   if ( *pBuf & 0x10 )
//  688     x |= HAL_KEY_SW_5;
//  689 #endif
//  690 #if defined ( HAL_KEY_SW_6 )
//  691   if ( *pBuf & 0x20 )
//  692     x |= HAL_KEY_SW_6;
//  693 #endif
//  694 #if defined ( HAL_KEY_SW_7 )
//  695   if ( *pBuf & 0x40 )
//  696     x |= HAL_KEY_SW_7;
//  697 #endif
//  698 #if defined ( HAL_KEY_SW_8 )
//  699   if ( *pBuf & 0x80 )
//  700     x |= HAL_KEY_SW_8;
//  701 #endif
//  702   pBuf++;
//  703 
//  704   retValue = OnBoard_SendKeys(x, *pBuf);
//  705 
//  706   /* Build and send back the response */
//  707   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  708 }
//  709 #endif
//  710 
//  711 /***************************************************************************************************
//  712  * @fn      MT_UtilTimeAlive
//  713  *
//  714  * @brief   Process Time Alive
//  715  *
//  716  * @param   None.
//  717  *
//  718  * @return  None
//  719  ***************************************************************************************************/
//  720 void MT_UtilTimeAlive(void)
//  721 {
//  722   uint8 timeAlive[4];
//  723   uint32 tmp32;
//  724 
//  725   /* Time since last reset (seconds) */
//  726   tmp32 = osal_GetSystemClock() / 1000;
//  727 
//  728   /* Convert to high byte first into temp buffer */
//  729   timeAlive[0] = BREAK_UINT32(tmp32, 0);
//  730   timeAlive[1] = BREAK_UINT32(tmp32, 1);
//  731   timeAlive[2] = BREAK_UINT32(tmp32, 2);
//  732   timeAlive[3] = BREAK_UINT32(tmp32, 3);
//  733 
//  734   /* Build and send back the response */
//  735   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  736                                        MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
//  737 }
//  738 
//  739 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  740 /***************************************************************************************************
//  741  * @fn      MT_UtilLedControl
//  742  *
//  743  * @brief   Process the LED Control Message
//  744  *
//  745  * @param   pBuf - pointer to the received data
//  746  *
//  747  * @return  None
//  748  ***************************************************************************************************/
//  749 void MT_UtilLedControl(uint8 *pBuf)
//  750 {
//  751   uint8 iLed, Led, iMode, Mode, cmdId;
//  752   uint8 retValue = ZFailure;
//  753 
//  754   /* parse header */
//  755   cmdId = pBuf[MT_RPC_POS_CMD1];
//  756   pBuf += MT_RPC_FRAME_HDR_SZ;
//  757 
//  758   /* LED and Mode */
//  759   iLed = *pBuf++;
//  760   iMode = *pBuf;
//  761 
//  762   if ( iLed == 1 )
//  763     Led = HAL_LED_1;
//  764   else if ( iLed == 2 )
//  765     Led = HAL_LED_2;
//  766 #if 0
//  767   else if ( iLed == 3 )
//  768     Led = HAL_LED_3;
//  769   else if ( iLed == 4 )
//  770     Led = HAL_LED_4;
//  771 #endif
//  772   else if ( iLed == 0xFF )
//  773     Led = HAL_LED_ALL;
//  774   else
//  775     Led = 0;
//  776 
//  777   if ( iMode == 0 )
//  778     Mode = HAL_LED_MODE_OFF;
//  779   else if ( iMode == 1 )
//  780     Mode = HAL_LED_MODE_ON;
//  781   else if ( iMode == 2 )
//  782     Mode = HAL_LED_MODE_BLINK;
//  783   else if ( iMode == 3 )
//  784     Mode = HAL_LED_MODE_FLASH;
//  785   else if ( iMode == 4 )
//  786     Mode = HAL_LED_MODE_TOGGLE;
//  787   else
//  788     Led = 0;
//  789 
//  790   if ( Led != 0 )
//  791   {
//  792     HalLedSet (Led, Mode);
//  793     retValue = ZSuccess;
//  794   }
//  795 
//  796   /* Build and send back the response */
//  797   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  798 }
//  799 #endif /* HAL_LED */
//  800 
//  801 
//  802 /***************************************************************************************************
//  803  * @fn          MT_UtilSrcMatchEnable
//  804  *
//  805  * @brief      Enabled AUTOPEND and source address matching.
//  806  *
//  807  * @param      pBuf - Buffer contains the data
//  808  *
//  809  * @return     void
//  810  ***************************************************************************************************/
//  811 void MT_UtilSrcMatchEnable (uint8 *pBuf)
//  812 {
//  813   uint8 retValue, cmdId;
//  814 
//  815   /* Parse header */
//  816   cmdId = pBuf[MT_RPC_POS_CMD1];
//  817   pBuf += MT_RPC_FRAME_HDR_SZ;
//  818 
//  819 #ifdef AUTO_PEND
//  820   /* Call the routine */
//  821   retValue = ZMacSrcMatchEnable (pBuf[0], pBuf[1]);
//  822 #else
//  823   retValue = ZMacUnsupported;
//  824 #endif
//  825 
//  826   /* Build and send back the response */
//  827   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  828 
//  829 }
//  830 
//  831 /***************************************************************************************************
//  832  * @fn          MT_UtilSrcMatchAddEntry
//  833  *
//  834  * @brief       Add a short or extended address to source address table.
//  835  *
//  836  * @param       pBuf - Buffer contains the data
//  837  *
//  838  * @return      void
//  839  ***************************************************************************************************/
//  840 void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
//  841 {
//  842   uint8 retValue, cmdId;
//  843 
//  844   /* Parse header */
//  845   cmdId = pBuf[MT_RPC_POS_CMD1];
//  846   pBuf += MT_RPC_FRAME_HDR_SZ;
//  847 
//  848 #ifdef AUTO_PEND
//  849   uint16 panID;
//  850   zAddrType_t devAddr;
//  851 
//  852   /* Address mode */
//  853   devAddr.addrMode = *pBuf++;
//  854 
//  855   /* Address based on the address mode */
//  856   MT_UtilSpi2Addr( &devAddr, pBuf);
//  857   pBuf += Z_EXTADDR_LEN;
//  858 
//  859   /* PanID */
//  860   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  861 
//  862   /* Call the routine */
//  863   retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
//  864 #else
//  865   retValue = ZMacUnsupported;
//  866 #endif
//  867 
//  868   /* Build and send back the response */
//  869   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  870 }
//  871 
//  872 /***************************************************************************************************
//  873  * @fn          MT_UtilSrcMatchDeleteEntry
//  874  *
//  875  * @brief      Delete a short or extended address from source address table.
//  876  *
//  877  * @param      pBuf - Buffer contains the data
//  878  *
//  879  * @return     void
//  880  ***************************************************************************************************/
//  881 void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
//  882 {
//  883   uint8 retValue, cmdId;
//  884 
//  885   /* Parse header */
//  886   cmdId = pBuf[MT_RPC_POS_CMD1];
//  887   pBuf += MT_RPC_FRAME_HDR_SZ;
//  888 
//  889 #ifdef AUTO_PEND
//  890   uint16 panID;
//  891   zAddrType_t devAddr;
//  892 
//  893   /* Address mode */
//  894   devAddr.addrMode = *pBuf++;
//  895 
//  896   /* Address based on the address mode */
//  897   MT_UtilSpi2Addr( &devAddr, pBuf);
//  898   pBuf += Z_EXTADDR_LEN;
//  899 
//  900   /* PanID */
//  901   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  902 
//  903   /* Call the routine */
//  904   retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
//  905 #else
//  906   retValue = ZMacUnsupported;
//  907 #endif
//  908 
//  909   /* Build and send back the response */
//  910   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  911 }
//  912 
//  913 /***************************************************************************************************
//  914  * @fn          MT_UtilSrcMatchCheckSrcAddr
//  915  *
//  916  * @brief      Check if a short or extended address is in the source address table.
//  917  *
//  918  * @param      pBuf - Buffer contains the data
//  919  *
//  920  * @return     void
//  921  ***************************************************************************************************/
//  922 void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
//  923 {
//  924   uint8 cmdId;
//  925   uint8 retArray[2];
//  926 
//  927   /* Parse header */
//  928   cmdId = pBuf[MT_RPC_POS_CMD1];
//  929   pBuf += MT_RPC_FRAME_HDR_SZ;
//  930 
//  931 #if 0  /* Unsupported  */
//  932   uint16 panID;
//  933   zAddrType_t devAddr;
//  934 
//  935   /* Address mode */
//  936   devAddr.addrMode = *pBuf++;
//  937 
//  938   /* Address based on the address mode */
//  939   MT_UtilSpi2Addr( &devAddr, pBuf);
//  940   pBuf += Z_EXTADDR_LEN;
//  941 
//  942   /* PanID */
//  943   panID = BUILD_UINT16( pBuf[0] , pBuf[1] );
//  944 
//  945   /* Call the routine */
//  946   retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
//  947 
//  948     /* Return failure if the index is invalid */
//  949   if (retArray[1] == ZMacSrcMatchInvalidIndex )
//  950   {
//  951     retArray[0] = ZFailure;
//  952   }
//  953   else
//  954   {
//  955     retArray[0] = ZSuccess;
//  956   }
//  957 #else
//  958   retArray[0] = ZMacUnsupported;
//  959   retArray[1] = ZMacSrcMatchInvalidIndex;
//  960 #endif
//  961 
//  962   /* Build and send back the response */
//  963   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
//  964 }
//  965 
//  966 /***************************************************************************************************
//  967  * @fn          MT_UtilSrcMatchAckAllPending
//  968  *
//  969  * @brief       Enabled/disable acknowledging all packets with pending bit set
//  970  *              It is normally enabled when adding new entries to
//  971  *              the source address table fails due to the table is full, or
//  972  *              disabled when more entries are deleted and the table has
//  973  *              empty slots.
//  974  *
//  975  * @param       pBuf - Buffer contains the data
//  976  *
//  977  * @return      void
//  978  ***************************************************************************************************/
//  979 void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
//  980 {
//  981   uint8 retValue, cmdId;
//  982 
//  983   /* Parse header */
//  984   cmdId = pBuf[MT_RPC_POS_CMD1];
//  985   pBuf += MT_RPC_FRAME_HDR_SZ;
//  986 
//  987 #ifdef AUTO_PEND
//  988   /* Call the routine */
//  989   retValue = ZMacSrcMatchAckAllPending(*pBuf);
//  990 #else
//  991   retValue = ZMacUnsupported;
//  992 #endif
//  993 
//  994   /* Build and send back the response */
//  995   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  996 }
//  997 
//  998 /***************************************************************************************************
//  999  * @fn          MT_UtilSrcMatchCheckAllPending
// 1000  *
// 1001  * @brief       Check if acknowledging all packets with pending bit set
// 1002  *              is enabled.
// 1003  *
// 1004  * @param       pBuf - Buffer contains the data
// 1005  *
// 1006  * @return      void
// 1007  ***************************************************************************************************/
// 1008 void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
// 1009 {
// 1010   uint8 retArray[2], cmdId;
// 1011 
// 1012   /* Parse header */
// 1013   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1014   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1015 
// 1016 #ifdef AUTO_PEND
// 1017   /* Call the routine */
// 1018   retArray[0] = ZMacSuccess;
// 1019   retArray[1] = ZMacSrcMatchCheckAllPending();
// 1020 #else
// 1021   retArray[0] = ZMacUnsupported;
// 1022   retArray[1] = FALSE;
// 1023 #endif
// 1024 
// 1025   /* Build and send back the response */
// 1026   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1027 }
// 1028 
// 1029 /***************************************************************************************************
// 1030  * SUPPORT
// 1031  ***************************************************************************************************/
// 1032 
// 1033 #ifdef AUTO_PEND
// 1034 /***************************************************************************************************
// 1035  * @fn      MT_UtilRevExtCpy
// 1036  *
// 1037  * @brief
// 1038  *
// 1039  *   Reverse-copy an extended address.
// 1040  *
// 1041  * @param   pDst - Pointer to data destination
// 1042  * @param   pSrc - Pointer to data source
// 1043  *
// 1044  * @return  void
// 1045  ***************************************************************************************************/
// 1046 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
// 1047 {
// 1048   int8 i;
// 1049 
// 1050   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
// 1051   {
// 1052     *pDst++ = pSrc[i];
// 1053   }
// 1054 }
// 1055 
// 1056 /***************************************************************************************************
// 1057  * @fn      MT_UtilSpi2Addr
// 1058  *
// 1059  * @brief   Copy an address from an SPI message to an address struct.  The
// 1060  *          addrMode in pAddr must already be set.
// 1061  *
// 1062  * @param   pDst - Pointer to address struct
// 1063  * @param   pSrc - Pointer SPI message byte array
// 1064  *
// 1065  * @return  void
// 1066  ***************************************************************************************************/
// 1067 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
// 1068 {
// 1069   if ( pDst->addrMode == Addr16Bit )
// 1070   {
// 1071     pDst->addr.shortAddr = BUILD_UINT16( pSrc[0] , pSrc[1] );
// 1072   }
// 1073   else if ( pDst->addrMode == Addr64Bit )
// 1074   {
// 1075     MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
// 1076   }
// 1077 }
// 1078 #endif // AUTO_PEND
// 1079 
// 1080 #if !defined NONWK
// 1081 /**************************************************************************************************
// 1082  * @fn      MT_UtilDataReq
// 1083  *
// 1084  * @brief   Process the MAC Data Request command.
// 1085  *
// 1086  * @param   pBuf - pointer to the received data
// 1087  *
// 1088  * @return  None
// 1089 **************************************************************************************************/
// 1090 void MT_UtilDataReq(uint8 *pBuf)
// 1091 {
// 1092   uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
// 1093   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
// 1094                                                                                1, &rtrn);
// 1095 }
// 1096 
// 1097 /***************************************************************************************************
// 1098  * @fn      MT_UtilAddrMgrExtAddrLookup
// 1099  *
// 1100  * @brief   Proxy the AddrMgrExtAddrLookup() function.
// 1101  *
// 1102  * @param   pBuf - pointer to the received buffer
// 1103  *
// 1104  * @return  void
// 1105  ***************************************************************************************************/
// 1106 static void MT_UtilAddrMgrExtAddrLookup(uint8 *pBuf)
// 1107 {
// 1108   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1109   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1110 
// 1111   (void)AddrMgrExtAddrLookup(BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1]), pBuf);
// 1112   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1113                                                                Z_EXTADDR_LEN, (uint8 *)pBuf);
// 1114 }
// 1115 
// 1116 /***************************************************************************************************
// 1117  * @fn      MT_UtilAddrMgrEntryLookupNwk
// 1118  *
// 1119  * @brief   Proxy the AddrMgrEntryLookupNwk() function.
// 1120  *
// 1121  * @param   pBuf - pointer to the received buffer
// 1122  *
// 1123  * @return  void
// 1124  ***************************************************************************************************/
// 1125 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
// 1126 {
// 1127   AddrMgrEntry_t entry;
// 1128   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1129   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1130 
// 1131   entry.nwkAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
// 1132   (void)AddrMgrEntryLookupNwk(&entry);
// 1133   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1134                                                                   Z_EXTADDR_LEN, entry.extAddr);
// 1135 }
// 1136 
// 1137 #if defined MT_SYS_KEY_MANAGEMENT
// 1138 /***************************************************************************************************
// 1139  * @fn      MT_UtilAPSME_LinkKeyDataGet
// 1140  *
// 1141  * @brief   Retrieves APS Link Key data from NV.
// 1142  *
// 1143  * @param   pBuf - pointer to the received buffer
// 1144  *
// 1145  * @return  void
// 1146  ***************************************************************************************************/
// 1147 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
// 1148 {
// 1149   uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
// 1150   APSME_LinkKeyData_t *pData = NULL;
// 1151   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1152   uint16 apsLinkKeyNvId;
// 1153   uint32 *apsRxFrmCntr;
// 1154   uint32 *apsTxFrmCntr;
// 1155 
// 1156   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1157 
// 1158   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1159 
// 1160   if (SUCCESS == *rsp)
// 1161   {
// 1162     pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
// 1163 
// 1164     if (pData != NULL)
// 1165     {
// 1166       // retrieve key from NV
// 1167       if ( osal_nv_read( apsLinkKeyNvId, 0,
// 1168                         sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
// 1169 
// 1170       {
// 1171         apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
// 1172         apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
// 1173 
// 1174         uint8 *ptr = rsp+1;
// 1175         (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
// 1176         ptr += SEC_KEY_LEN;
// 1177         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 0);
// 1178         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 1);
// 1179         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 2);
// 1180         *ptr++ = BREAK_UINT32(*apsTxFrmCntr, 3);
// 1181         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 0);
// 1182         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 1);
// 1183         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 2);
// 1184         *ptr++ = BREAK_UINT32(*apsRxFrmCntr, 3);
// 1185       }
// 1186 
// 1187       // clear copy of key in RAM
// 1188       osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
// 1189 
// 1190       osal_mem_free(pData);
// 1191     }
// 1192   }
// 1193   else
// 1194   {
// 1195     // set data key and counters 0xFF
// 1196     osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
// 1197   }
// 1198 
// 1199   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1200                                        MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
// 1201 
// 1202   // clear key data
// 1203   osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
// 1204 
// 1205 }
// 1206 
// 1207 /***************************************************************************************************
// 1208  * @fn      MT_UtilAPSME_LinkKeyNvIdGet
// 1209  *
// 1210  * @brief   Retrieves APS Link Key NV ID from the entry table.
// 1211  *
// 1212  * @param   pBuf - pointer to the received buffer
// 1213  *
// 1214  * @return  void
// 1215  ***************************************************************************************************/
// 1216 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
// 1217 {
// 1218   uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
// 1219   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1220   uint16 apsLinkKeyNvId;
// 1221 
// 1222   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1223 
// 1224   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1225 
// 1226   if (SUCCESS == *rsp)
// 1227   {
// 1228     rsp[1] = LO_UINT16(apsLinkKeyNvId);
// 1229     rsp[2] = HI_UINT16(apsLinkKeyNvId);
// 1230   }
// 1231   else
// 1232   {
// 1233     // send failure response with invalid NV ID
// 1234     osal_memset(&rsp[1], 0xFF, 2);
// 1235   }
// 1236 
// 1237   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1238                                        MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
// 1239 }
// 1240 #endif // MT_SYS_KEY_MANAGEMENT
// 1241 
// 1242 /***************************************************************************************************
// 1243  * @fn      MT_UtilAPSME_RequestKeyCmd
// 1244  *
// 1245  * @brief   Send RequestKey command message to TC for a specific partner Address.
// 1246  *
// 1247  * @param   pBuf  - pointer to the received buffer
// 1248  *
// 1249  * @return  void
// 1250  ***************************************************************************************************/
// 1251 void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
// 1252 {
// 1253   uint8 cmdId;
// 1254   uint8 partnerAddr[Z_EXTADDR_LEN];
// 1255   uint8 retValue;
// 1256 
// 1257   // parse header
// 1258   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1259   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1260 
// 1261   /* PartnerAddress */
// 1262   osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
// 1263 
// 1264   retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
// 1265 
// 1266   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
// 1267 }
// 1268 
// 1269 /***************************************************************************************************
// 1270  * @fn      MT_UtilAssocCount
// 1271  *
// 1272  * @brief   Proxy the AssocCount() function.
// 1273  *
// 1274  * @param   pBuf - pointer to the received buffer
// 1275  *
// 1276  * @return  void
// 1277  ***************************************************************************************************/
// 1278 static void MT_UtilAssocCount(uint8 *pBuf)
// 1279 {
// 1280   uint16 cnt;
// 1281   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1282   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1283 
// 1284   cnt = AssocCount(pBuf[0], pBuf[1]);
// 1285   pBuf[0] = LO_UINT16(cnt);
// 1286   pBuf[1] = HI_UINT16(cnt);
// 1287 
// 1288   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
// 1289 }
// 1290 
// 1291 /***************************************************************************************************
// 1292  * @fn      MT_UtilAssocFindDevice
// 1293  *
// 1294  * @brief   Get an associated device by index.
// 1295  *
// 1296  * @param   pBuf - pointer to the received buffer
// 1297  *
// 1298  * @return  void
// 1299  ***************************************************************************************************/
// 1300 static void MT_UtilAssocFindDevice(uint8 *pBuf)
// 1301 {
// 1302   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1303   uint8 buf[sizeof(associated_devices_t)];
// 1304 
// 1305   packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
// 1306   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1307                                        sizeof(associated_devices_t), buf);
// 1308 }
// 1309 
// 1310 /***************************************************************************************************
// 1311  * @fn      MT_UtilAssocGetWithAddress
// 1312  *
// 1313  * @brief   Get an associated device by address.
// 1314  *
// 1315  * @param   pBuf - pointer to the received buffer
// 1316  *
// 1317  * @return  void
// 1318  ***************************************************************************************************/
// 1319 static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
// 1320 {
// 1321   extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
// 1322   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1323   uint8 buf[sizeof(associated_devices_t)];
// 1324 
// 1325   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1326   packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
// 1327                                   BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
// 1328 
// 1329   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1330                                        sizeof(associated_devices_t), buf);
// 1331 }
// 1332 
// 1333 /***************************************************************************************************
// 1334  * @fn      packDev_t
// 1335  *
// 1336  * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
// 1337  *          the pDev parameter is NULL).
// 1338  *
// 1339  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1340  * @param   pDev - pointer to the structure.
// 1341  *
// 1342  * @return  void
// 1343  ***************************************************************************************************/
// 1344 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
// 1345 {
// 1346   if (NULL == pDev)
// 1347   {
// 1348     uint16 rtrn = INVALID_NODE_ADDR;
// 1349     *pBuf++ = LO_UINT16(rtrn);
// 1350     *pBuf++ = HI_UINT16(rtrn);
// 1351   }
// 1352   else
// 1353   {
// 1354     *pBuf++ = LO_UINT16(pDev->shortAddr);
// 1355     *pBuf++ = HI_UINT16(pDev->shortAddr);
// 1356     *pBuf++ = LO_UINT16(pDev->addrIdx);
// 1357     *pBuf++ = HI_UINT16(pDev->addrIdx);
// 1358     *pBuf++ = pDev->nodeRelation;
// 1359     *pBuf++ = pDev->devStatus;
// 1360     *pBuf++ = pDev->assocCnt;
// 1361     *pBuf++ = pDev->age;
// 1362     *pBuf++ = pDev->linkInfo.txCounter;
// 1363     *pBuf++ = pDev->linkInfo.txCost;
// 1364     *pBuf++ = pDev->linkInfo.rxLqi;
// 1365     *pBuf++ = pDev->linkInfo.inKeySeqNum;
// 1366     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 0);
// 1367     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 1);
// 1368     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 2);
// 1369     *pBuf++ = BREAK_UINT32(pDev->linkInfo.inFrmCntr, 3);
// 1370     *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
// 1371     *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
// 1372   }
// 1373 }
// 1374 
// 1375 #if defined ZCL_KEY_ESTABLISH
// 1376 /***************************************************************************************************
// 1377  * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
// 1378  *
// 1379  * @brief   Proxy the zclGeneral_KeyEstablish_InitiateKeyEstablishment() function.
// 1380  *
// 1381  * @param   pBuf - pointer to the received buffer
// 1382  *
// 1383  * @return  void
// 1384  ***************************************************************************************************/
// 1385 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
// 1386 {
// 1387   afAddrType_t partnerAddr;
// 1388   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1389   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1390 
// 1391   partnerAddr.panId = 0;  // Not an inter-pan message.
// 1392   partnerAddr.endPoint = pBuf[2];
// 1393   partnerAddr.addrMode = (afAddrMode_t)pBuf[3];
// 1394   if (afAddr64Bit == partnerAddr.addrMode)
// 1395   {
// 1396     (void)osal_memcpy(partnerAddr.addr.extAddr, pBuf+4, Z_EXTADDR_LEN);
// 1397   }
// 1398   else
// 1399   {
// 1400     partnerAddr.addr.shortAddr = BUILD_UINT16(pBuf[4], pBuf[5]);
// 1401   }
// 1402 
// 1403   zcl_key_establish_task_id = pBuf[0];
// 1404   *pBuf = zclGeneral_KeyEstablish_InitiateKeyEstablishment(MT_TaskID, &partnerAddr, pBuf[1]);
// 1405   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1406 }
// 1407 
// 1408 /***************************************************************************************************
// 1409  * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
// 1410  *
// 1411  * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
// 1412  *
// 1413  * @param   pBuf - pointer to the received buffer
// 1414  *
// 1415  * @return  void
// 1416  ***************************************************************************************************/
// 1417 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
// 1418 {
// 1419 #if defined TC_LINKKEY_JOIN
// 1420   uint8 *output = osal_mem_alloc(SE_PROFILE_SIGNATURE_LENGTH+1);
// 1421   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1422   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1423 
// 1424   if (NULL == output)
// 1425   {
// 1426     *pBuf = FAILURE;
// 1427     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1428   }
// 1429   else
// 1430   {
// 1431     *output = zclGeneral_KeyEstablishment_ECDSASign(pBuf+1, *pBuf, output+1);
// 1432     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1433                                          SE_PROFILE_SIGNATURE_LENGTH+1, output);
// 1434     osal_mem_free(output);
// 1435   }
// 1436 #endif
// 1437 }
// 1438 
// 1439 /***************************************************************************************************
// 1440  * @fn      MT_UtilKeyEstablishInd
// 1441  *
// 1442  * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
// 1443  *
// 1444  * @param   pInd - Pointer to a keyEstablishmentInd_t structure.
// 1445  *
// 1446  * @return  None
// 1447  ***************************************************************************************************/
// 1448 void MT_UtilKeyEstablishInd(keyEstablishmentInd_t *pInd)
// 1449 {
// 1450   uint8 msg[6];
// 1451 
// 1452   msg[0] = zcl_key_establish_task_id;
// 1453   msg[1] = pInd->hdr.event;
// 1454   msg[2] = pInd->hdr.status;
// 1455   msg[3] = pInd->waitTime;
// 1456   msg[4] = LO_UINT16(pInd->keyEstablishmentSuite);
// 1457   msg[5] = HI_UINT16(pInd->keyEstablishmentSuite);
// 1458 
// 1459   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
// 1460                                        MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
// 1461 }
// 1462 #endif
// 1463 
// 1464 /***************************************************************************************************
// 1465  * @fn      MT_UtilSync
// 1466  *
// 1467  * @brief   Process the MT_UTIL_SYNC command
// 1468  *
// 1469  * @param   None
// 1470  *
// 1471  * @return  None
// 1472  ***************************************************************************************************/
// 1473 static void MT_UtilSync(void)
// 1474 {
// 1475  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
// 1476 }
// 1477 #endif /* !defined NONWK */
// 1478 #endif /* MT_UTIL_FUNC */
// 1479 /**************************************************************************************************
// 1480  **************************************************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
