###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Apr/2019  16:49:33
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_NWK.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWE845.tmp
#        (E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_NWK.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK_DEMO -lC
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        -lA
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0056
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List\MT_NWK.lst
#    Object file        =  
#        E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj\MT_NWK.r51
#
###############################################################################

E:\qqÏÂÔØÎÄ¼þ\½á¿Î×÷Òµ\ZigBee\ÊµÑéÖ¸µ¼Êé\ÊµÑéÖ¸µ¼Êé\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Components\mt\MT_NWK.c
      1          /**************************************************************************************************
      2            Filename:       MT_NWK.c
      3            Revised:        $Date: 2010-05-06 16:49:18 -0700 (Thu, 06 May 2010) $
      4            Revision:       $Revision: 22409 $
      5          
      6          
      7              Description:    MonitorTest functions for the NWK layer.
      8          
      9              Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11              IMPORTANT: Your use of this Software is limited to those specific rights
     12              granted under the terms of a software license agreement between the user
     13              who downloaded the software, his/her employer (which must be your employer)
     14              and Texas Instruments Incorporated (the "License").  You may not use this
     15              Software unless you agree to abide by the terms of the License. The License
     16              limits your use, and you acknowledge, that the Software may not be modified,
     17              copied or distributed unless embedded on a Texas Instruments microcontroller
     18              or used solely and exclusively in conjunction with a Texas Instruments radio
     19              frequency transceiver, which is integrated into your product.  Other than for
     20              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21              works of, modify, distribute, perform, display or sell this Software and/or
     22              its documentation for any purpose.
     23          
     24              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36              Should you have any questions regarding your right to use this Software,
     37              contact Texas Instruments Incorporated at www.TI.com.
     38          
     39          **************************************************************************************************/
     40          
     41          /***************************************************************************************************
     42           * INCLUDES
     43           ***************************************************************************************************/
     44          #include "ZComDef.h"
     45          #include "MT.h"
     46          #include "MT_NWK.h"
     47          #include "NLMEDE.h"
     48          #include "nwk.h"
     49          #include "nwk_globals.h"
     50          #include "nwk_util.h"
     51          #include "OSAL.h"
     52          #include "ZDApp.h"
     53          
     54          #if !defined( WIN32 )
     55            #include "OnBoard.h"
     56          #endif
     57          
     58          /***************************************************************************************************
     59           * GLOBAL VARIABLES
     60           ***************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     61          uint16 _nwkCallbackSub;
   \                     _nwkCallbackSub:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     62          
     63          /*********************************************************************
     64           * TYPEDEFS
     65           */
     66          
     67          /***************************************************************************************************
     68           * LOCAL FUNCTIONS
     69           ***************************************************************************************************/
     70          #if defined (MT_NWK_FUNC)
     71          void MT_NldeDataRequest(uint8 *pBuf);
     72          void MT_NlmeNetworkFormationRequest(uint8 *pBuf);
     73          void MT_NlmePermitJoiningRequest(uint8 *pBuf);
     74          void MT_NlmeStartRouterRequest(uint8 *pBuf);
     75          void MT_NlmeJoinRequest(uint8 *pBuf);
     76          void MT_NlmeLeaveRequest(uint8 *pBuf);
     77          void MT_NlmeResetRequest(uint8 *pBuf);
     78          void MT_NlmeGetRequest(uint8 *pBuf);
     79          void MT_NlmeSetRequest(uint8 *pBuf);
     80          void MT_NlmeNetworkDiscoveryRequest(uint8 *pBuf);
     81          void MT_NlmeRouteDiscoveryRequest(uint8 *pBuf);
     82          void MT_NlmeDirectJoinRequest(uint8 *pBuf);
     83          void MT_NlmeOrphanJoinRequest(uint8 *pBuf);
     84          
     85          uint8 MT_Nwk_DataRequest( uint16 dstAddr, uint8 nsduLen, uint8* nsdu,
     86                                   uint8 nsduHandle, uint16 nsduHandleOptions,
     87                                   uint8 secure, uint8 discoverRoute,
     88                                   uint8 radius);
     89          #endif /* MT_NWK_FUNC */
     90          
     91          #if defined (MT_NWK_FUNC)
     92          /***************************************************************************************************
     93           * @fn      MT_NwkCommandProcessing
     94           *
     95           * @brief
     96           *
     97           *   Process all the NWK commands that are issued by test tool
     98           *
     99           * @param   cmd_id - Command ID
    100           * @param   len    - Length of received SPI data message
    101           * @param   pData  - pointer to received SPI data message
    102           *
    103           * @return  status
    104           ***************************************************************************************************/
    105          uint8 MT_NwkCommandProcessing(uint8 *pBuf)
    106          {
    107            uint8 status = MT_RPC_SUCCESS;
    108          
    109            switch (pBuf[MT_RPC_POS_CMD1])
    110            {
    111              case MT_NWK_INIT:
    112                nwk_init(NWK_TaskID);
    113                break;
    114          
    115              case MT_NLDE_DATA_REQ:
    116                MT_NldeDataRequest(pBuf);
    117                break;
    118          
    119              case MT_NLME_NETWORK_FORMATION_REQ:
    120                MT_NlmeNetworkFormationRequest(pBuf);
    121                break;
    122          
    123              case MT_NLME_PERMIT_JOINING_REQ:
    124                 MT_NlmePermitJoiningRequest(pBuf);
    125                break;
    126          
    127               case MT_NLME_JOIN_REQ:
    128                 MT_NlmeJoinRequest(pBuf);
    129                 break;
    130          
    131               case MT_NLME_LEAVE_REQ:
    132                 MT_NlmeLeaveRequest(pBuf);
    133                 break;
    134          
    135               case MT_NLME_RESET_REQ:
    136                 MT_NlmeResetRequest(pBuf);
    137                 break;
    138          
    139               case MT_NLME_GET_REQ:
    140                 MT_NlmeGetRequest(pBuf);
    141                 break;
    142          
    143               case MT_NLME_SET_REQ:
    144                 MT_NlmeSetRequest(pBuf);
    145                 break;
    146          
    147               case MT_NLME_NETWORK_DISCOVERY_REQ:
    148                 MT_NlmeNetworkDiscoveryRequest(pBuf);
    149                 break;
    150          
    151               case MT_NLME_ROUTE_DISCOVERY_REQ:
    152                 MT_NlmeRouteDiscoveryRequest(pBuf);
    153                 break;
    154          
    155               case MT_NLME_DIRECT_JOIN_REQ:
    156                 MT_NlmeDirectJoinRequest(pBuf);
    157                 break;
    158          
    159               case MT_NLME_ORPHAN_JOIN_REQ:
    160                 MT_NlmeOrphanJoinRequest(pBuf);
    161                 break;
    162          
    163              case MT_NLME_START_ROUTER_REQ:
    164                MT_NlmeStartRouterRequest(pBuf);
    165                break;
    166          
    167              default:
    168                status = MT_RPC_ERR_COMMAND_ID;
    169                break;
    170            }
    171          
    172            return status;
    173          }
    174          
    175          /***************************************************************************************************
    176           * @fn      MT_NldeDataReq
    177           *
    178           * @brief   Process NLDE Data Request commands
    179           *
    180           * @param   pBuf - pointer to received buffer
    181           *
    182           * @return  void
    183           ***************************************************************************************************/
    184          void MT_NldeDataRequest(uint8 *pBuf)
    185          {
    186            uint8 retValue = ZFailure;
    187            uint16 dstAddr;
    188            uint8 dataLen = 0;
    189            uint8 *dataPtr;
    190            uint8 cmdId;
    191          
    192            /* parse header */
    193            cmdId = pBuf[MT_RPC_POS_CMD1];
    194            pBuf += MT_RPC_FRAME_HDR_SZ;
    195          
    196            /* First read the DstAddr */
    197            dstAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
    198            pBuf += sizeof( dstAddr );
    199          
    200            /* Get the NSDU details */
    201            dataLen = *pBuf++;
    202            dataPtr = pBuf;
    203          
    204            /* Skip a length of ZTEST_DEFAULT_DATA_LEN */
    205            pBuf += ZTEST_DEFAULT_DATA_LEN;
    206          
    207            /* Send out Data Request */
    208            retValue = MT_Nwk_DataRequest(dstAddr, dataLen, dataPtr, pBuf[0], BUILD_UINT16(pBuf[1], pBuf[2]),
    209                                          pBuf[3], pBuf[4], pBuf[5]);
    210          
    211            /* Build and send back the response */
    212            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    213          }
    214          
    215          
    216          /***************************************************************************************************
    217           * @fn      MT_NlmeNetworkFormationRequest
    218           *
    219           * @brief   Network Formation Request
    220           *
    221           * @param   pBuf - pointer to the received buffer
    222           *
    223           * @return  void
    224           ***************************************************************************************************/
    225          void MT_NlmeNetworkFormationRequest(uint8 *pBuf)
    226          {
    227            uint8 retValue = ZFailure;
    228          	uint16 panId;
    229            uint32 channelList;
    230            uint8 cmdId;
    231          
    232            /* parse header */
    233            cmdId = pBuf[MT_RPC_POS_CMD1];
    234            pBuf += MT_RPC_FRAME_HDR_SZ;
    235          
    236            /* Build panId */
    237            panId = BUILD_UINT16( pBuf[0], pBuf[1]);
    238            pBuf += sizeof(uint16);
    239          			
    240            /* Build the channel list */
    241            channelList = osal_build_uint32(pBuf, 4);
    242            pBuf += sizeof(uint32);
    243          
    244            if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    245            {
    246              retValue = NLME_NetworkFormationRequest( panId, NULL, channelList, pBuf[0], pBuf[1], pBuf[2], pBuf[3] );
    247            }
    248            else
    249            {
    250              retValue = ZUnsupportedMode;
    251            }
    252          
    253            /* Build and send back the response */
    254            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    255          }
    256          
    257          /***************************************************************************************************
    258           * @fn      MT_NlmePermitJoiningRequest
    259           *
    260           * @brief   Permit Joining Request
    261           *
    262           * @param   pBuf - pointer to the received buffer
    263           *
    264           * @return  void
    265           ***************************************************************************************************/
    266          void MT_NlmePermitJoiningRequest(uint8 *pBuf)
    267          {
    268            uint8 retValue = ZFailure;
    269            uint8 cmdId;
    270          
    271            /* parse header */
    272            cmdId = pBuf[MT_RPC_POS_CMD1];
    273            pBuf += MT_RPC_FRAME_HDR_SZ;
    274          
    275            if (ZSTACK_ROUTER_BUILD)
    276            {
    277              retValue = NLME_PermitJoiningRequest(*pBuf);
    278            }
    279            else
    280            {
    281              retValue = ZUnsupportedMode;
    282            }
    283          
    284            /* Build and send back the response */
    285            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    286          }
    287          
    288          /***************************************************************************************************
    289           * @fn      MT_NlmeStartRouterRequest
    290           *
    291           * @brief   Start Router Request
    292           *
    293           * @param   pBuf - pointer to the received buffer
    294           *
    295           * @return  void
    296           ***************************************************************************************************/
    297          void MT_NlmeStartRouterRequest(uint8 *pBuf)
    298          {
    299            uint8 retValue = ZFailure;
    300            uint8 cmdId;
    301          
    302            /* parse header */
    303            cmdId = pBuf[MT_RPC_POS_CMD1];
    304            pBuf += MT_RPC_FRAME_HDR_SZ;
    305          
    306            if ( ZSTACK_ROUTER_BUILD )
    307            {
    308              retValue = (uint8)NLME_StartRouterRequest(pBuf[0], pBuf[1], pBuf[2]);
    309            }
    310            else
    311            {
    312              retValue = ZUnsupportedMode;
    313            }
    314          
    315            /* Build and send back the response */
    316            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    317          }
    318          
    319          /***************************************************************************************************
    320           * @fn      MT_NlmeJoinRequest
    321           *
    322           * @brief   Join Request
    323           *
    324           * @param   pBuf - pointer to the received buffer
    325           *
    326           * @return  void
    327           ***************************************************************************************************/
    328          void MT_NlmeJoinRequest(uint8 *pBuf)
    329          {
    330            uint8 retValue = ZFailure;
    331            uint8 dummyExPANID[Z_EXTADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    332            uint16 panID;
    333            uint8 cmdId;
    334            networkDesc_t *pNwkDesc;   
    335            
    336            /* parse header */
    337            cmdId = pBuf[MT_RPC_POS_CMD1];
    338            pBuf += MT_RPC_FRAME_HDR_SZ;     
    339            panID = BUILD_UINT16(pBuf[0], pBuf[1]);
    340            
    341            if((pNwkDesc = nwk_getNetworkDesc(dummyExPANID,panID, pBuf[2])) != NULL )
    342            {  
    343              if (pNwkDesc->chosenRouter == INVALID_NODE_ADDR )
    344              {
    345                retValue = ZNwkNotPermitted;
    346              }
    347              else
    348              {      
    349                retValue = NLME_JoinRequest( dummyExPANID, panID, pBuf[2], pBuf[3],
    350                                             pNwkDesc->chosenRouter, pNwkDesc->chosenRouterDepth );
    351              }
    352            }
    353            else
    354            {
    355              retValue = ZNwkNotPermitted;    
    356            }
    357          
    358            if ( pBuf[3] & CAPINFO_RCVR_ON_IDLE )
    359            {
    360              /* The receiver is on, turn network layer polling off. */
    361              NLME_SetPollRate( 0 );
    362              NLME_SetQueuedPollRate( 0 );
    363              NLME_SetResponseRate( 0 );
    364            }
    365          
    366            /* Build and send back the response */
    367            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    368          }
    369          
    370          /***************************************************************************************************
    371           * @fn      MT_NlmeLeaveRequest
    372           *
    373           * @brief   Leave Request
    374           *
    375           * @param   pBuf - pointer to the received buffer
    376           *
    377           * @return  void
    378           ***************************************************************************************************/
    379          void MT_NlmeLeaveRequest(uint8 *pBuf)
    380          {
    381            NLME_LeaveReq_t req;
    382            uint8 retValue = ZFailure;
    383            uint8 index, cmdId;
    384          
    385            /* parse header */
    386            cmdId = pBuf[MT_RPC_POS_CMD1];
    387            pBuf += MT_RPC_FRAME_HDR_SZ;
    388          
    389            /* If extAddr is all zeros, it means null pointer */
    390            for(index=0;((index < Z_EXTADDR_LEN) && (pBuf[index] == 0));index++);
    391          
    392            if (index == Z_EXTADDR_LEN)
    393            {
    394              req.extAddr = NULL;
    395            }
    396            else
    397            {
    398              req.extAddr = pBuf;
    399            }
    400          
    401            /* Increment the pointer */
    402            pBuf += Z_EXTADDR_LEN;
    403          
    404            req.removeChildren = FALSE;
    405            req.rejoin         = FALSE;
    406            req.silent         = FALSE;
    407          
    408            retValue = NLME_LeaveReq(&req);
    409          
    410            /* Build and send back the response */
    411            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    412          }
    413          
    414          
    415          /***************************************************************************************************
    416           * @fn      MT_NlmeResetRequest
    417           *
    418           * @brief   Leave Request
    419           *
    420           * @param   pBuf - pointer to the received buffer
    421           *
    422           * @return  void
    423           ***************************************************************************************************/
    424          void MT_NlmeResetRequest(uint8 *pBuf)
    425          {
    426            uint8 retValue = NLME_ResetRequest();
    427          
    428            /* Build and send back the response */
    429            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), MT_NLME_RESET_REQ, 1, &retValue);
    430          }
    431          
    432          /***************************************************************************************************
    433           * @fn      MT_NlmeGetRequest
    434           *
    435           * @brief   Get Request
    436           *
    437           * @param   pBuf - pointer to the received buffer
    438           *
    439           * @return  void
    440           ***************************************************************************************************/
    441          void MT_NlmeGetRequest(uint8 *pBuf)
    442          {
    443            uint8 dataBuf[11];
    444            uint8 attr, index, cmdId;
    445          
    446            /* parse header */
    447            cmdId = pBuf[MT_RPC_POS_CMD1];
    448            pBuf += MT_RPC_FRAME_HDR_SZ;
    449          
    450            attr = *pBuf++;
    451            index = *pBuf;
    452          
    453            dataBuf[0] = NLME_GetRequest((ZNwkAttributes_t )attr, index, &dataBuf[1]);
    454          
    455            /* Build and send back the response */
    456            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId,
    457                                         11, dataBuf );
    458          }
    459          
    460          /***************************************************************************************************
    461           * @fn      MT_NlmeSetRequest
    462           *
    463           * @brief   Set Request
    464           *
    465           * @param   pBuf - pointer to the received buffer
    466           *
    467           * @return  void
    468           ***************************************************************************************************/
    469          void MT_NlmeSetRequest(uint8 *pBuf)
    470          {
    471            uint8 retValue = ZFailure;
    472            uint8 cmdId;
    473          
    474            /* parse header */
    475            cmdId = pBuf[MT_RPC_POS_CMD1];
    476            pBuf += MT_RPC_FRAME_HDR_SZ;
    477          
    478            retValue = NLME_SetRequest((ZNwkAttributes_t)pBuf[0], pBuf[1], &pBuf[2]);
    479          
    480            /* Update NV */
    481            ZDApp_NVUpdate();
    482          
    483            /* Build and send back the response */
    484            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue );
    485          }
    486          
    487          /***************************************************************************************************
    488           * @fn      MT_NlmeNetworkDiscoveryRequest
    489           *
    490           * @brief   Network Discovery Request
    491           *
    492           * @param   pBuf - pointer to the received buffer
    493           *
    494           * @return  void
    495           ***************************************************************************************************/
    496          void MT_NlmeNetworkDiscoveryRequest(uint8 *pBuf)
    497          {
    498            uint8 retValue = ZFailure;
    499            uint8 cmdId;
    500            uint32 scanChannels;
    501          
    502            /* parse header */
    503            cmdId = pBuf[MT_RPC_POS_CMD1];
    504            pBuf += MT_RPC_FRAME_HDR_SZ;
    505          
    506            /* Scan channels */
    507            scanChannels = osal_build_uint32(pBuf, 4);
    508            pBuf += sizeof(uint32);
    509          
    510            retValue = NLME_NetworkDiscoveryRequest(scanChannels, *pBuf);
    511          
    512            /* Build and send back the response */
    513            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue );
    514          }
    515          
    516          /***************************************************************************************************
    517           * @fn      MT_NlmeRouteDiscoveryRequest
    518           *
    519           * @brief   Route Discovery Request
    520           *
    521           * @param   pBuf - pointer to the received buffer
    522           *
    523           * @return  void
    524           ***************************************************************************************************/
    525          void MT_NlmeRouteDiscoveryRequest(uint8 *pBuf)
    526          {
    527            uint8 retValue = ZFailure;
    528            uint8 cmdId;
    529          
    530            /* parse header */
    531            cmdId = pBuf[MT_RPC_POS_CMD1];
    532            pBuf += MT_RPC_FRAME_HDR_SZ;
    533          
    534            if ( ZSTACK_ROUTER_BUILD )
    535            {
    536              retValue = NLME_RouteDiscoveryRequest(BUILD_UINT16(pBuf[0], pBuf[1]), pBuf[2], pBuf[3]);
    537            }
    538            else
    539            {
    540              retValue = ZUnsupportedMode;
    541            }
    542          
    543            /* Build and send back the response */
    544            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    545          }
    546          
    547          /***************************************************************************************************
    548           * @fn      MT_NlmeDirectJoinRequest
    549           *
    550           * @brief   Direct Join Request
    551           *
    552           * @param   pBuf - pointer to the received buffer
    553           *
    554           * @return  void
    555           ***************************************************************************************************/
    556          void MT_NlmeDirectJoinRequest(uint8 *pBuf)
    557          {
    558            uint8 retValue = ZFailure;
    559            uint8 cmdId;
    560          
    561            /* parse header */
    562            cmdId = pBuf[MT_RPC_POS_CMD1];
    563            pBuf += MT_RPC_FRAME_HDR_SZ;
    564          
    565            if ( ZSTACK_ROUTER_BUILD )
    566            {
    567              retValue = NLME_DirectJoinRequest( pBuf, pBuf[8] );
    568            }
    569            else
    570            {
    571              retValue = ZUnsupportedMode;
    572            }
    573          
    574            /* Build and send back the response */
    575            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    576          }
    577          
    578          /***************************************************************************************************
    579           * @fn      MT_NlmeOrphanJoinRequest
    580           *
    581           * @brief   Orphan Join Request
    582           *
    583           * @param   pBuf - pointer to the received buffer
    584           *
    585           * @return  void
    586           ***************************************************************************************************/
    587          void MT_NlmeOrphanJoinRequest(uint8 *pBuf)
    588          {
    589            uint8 i, j, attr;
    590            uint8 retValue = ZFailure;
    591            uint32 channelList;
    592            uint8 cmdId;
    593          
    594            if ( ZSTACK_END_DEVICE_BUILD )
    595            {
    596              /* parse header */
    597              cmdId = pBuf[MT_RPC_POS_CMD1];
    598              pBuf += MT_RPC_FRAME_HDR_SZ;
    599          
    600              /* Channel list bit mask */
    601              channelList = osal_build_uint32(pBuf, 4);
    602              pBuf += sizeof(uint32);
    603          
    604              /* Count number of channels */
    605              j = attr = 0;
    606          
    607              for (i = 0; i < ED_SCAN_MAXCHANNELS; i++)
    608              {
    609                if (channelList & (1 << i))
    610                {
    611                  j++;
    612                  attr = i;
    613                }
    614              }
    615          
    616              /* If only one channel specified */
    617              if (j == 1)
    618              {
    619                _NIB.scanDuration = *pBuf;
    620                _NIB.nwkLogicalChannel = attr;
    621                _NIB.channelList = channelList;
    622                if ( !_NIB.CapabilityFlags )
    623                {
    624                  _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;
    625                }
    626          
    627                devState = DEV_NWK_ORPHAN;
    628                retValue = (uint8)NLME_OrphanJoinRequest(channelList, *pBuf);
    629              }
    630              else
    631              {
    632                retValue = ZNwkInvalidParam;
    633              }
    634             }
    635             else
    636             {
    637               retValue = ZUnsupportedMode;
    638             }
    639          
    640            /* Build and send back the response */
    641            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_NWK), cmdId, 1, &retValue);
    642          }
    643          
    644          /***************************************************************************************************
    645           * @fn      MT_Nwk_DataRequest
    646           *
    647           * @brief   Nwk Data Request
    648           *
    649           * @param   dstAddr, nsduLen, nsdu, nsduHandle, nsduHandleOptions, secure, discoverRoute, radius
    650           *
    651           * @return  void
    652           ***************************************************************************************************/
    653          uint8 MT_Nwk_DataRequest(uint16 dstAddr, uint8 nsduLen, uint8* nsdu,
    654                                   uint8 nsduHandle, uint16 nsduHandleOptions,
    655                                   uint8 secure, uint8 discoverRoute,
    656                                   uint8 radius)
    657          {
    658              uint8               status;
    659              NLDE_DataReqAlloc_t dra;
    660              NLDE_DataReq_t*     req;
    661          
    662          
    663              dra.overhead = sizeof(NLDE_DataReq_t);
    664              dra.nsduLen  = nsduLen;
    665              dra.secure   = secure;
    666          
    667              req = NLDE_DataReqAlloc(&dra);
    668          
    669              if ( req != NULL )
    670              {
    671                osal_memcpy(req->nfd.nsdu, nsdu, nsduLen);
    672          
    673                req->nfd.dstAddr           = dstAddr;
    674                req->nfd.nsduHandleOptions = nsduHandleOptions;
    675                req->nfd.discoverRoute     = discoverRoute;
    676                req->nfd.radius            = radius;
    677          
    678                status = NLDE_DataReq( req );
    679              }
    680              else
    681              {
    682                status = ZMemError;
    683              }
    684          
    685              return status;
    686          }
    687          #endif /* MT_NWK_FUNC */
    688          
    689          #if defined ( MT_NWK_CB_FUNC )             //NWK callback commands
    690          /***************************************************************************************************
    691           * @fn          nwk_MTCallbackSubDataConfirm
    692           *
    693           * @brief       Process the callback subscription for NLDE-DATA.confirm
    694           *
    695           * @param       nsduHandle  - APS handle
    696           * @param       Status      - result of data request
    697           *
    698           * @return      none
    699           ***************************************************************************************************/
    700          void nwk_MTCallbackSubDataConfirm(uint8 nsduHandle, ZStatus_t status)
    701          {
    702            uint8 buf[2];
    703          
    704            buf[0] = nsduHandle;
    705            buf[1] = (uint8)status;
    706          
    707            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLDE_DATA_CONF, 2, buf );
    708          }
    709          
    710          /***************************************************************************************************
    711           * @fn          nwk_MTCallbackSubDataIndication
    712           *
    713           * @brief       Process the callback subscription for NLDE-DATA.indication
    714           *
    715           * @param       SrcAddress      - 16 bit address
    716           * @param       nsduLength      - Length of incoming data
    717           * @param       nsdu            - Pointer to incoming data
    718           * @param       LinkQuality     - Link quality measured during
    719           *                                reception.
    720           *
    721           * @return      none
    722           ***************************************************************************************************/
    723          void nwk_MTCallbackSubDataIndication(uint16 SrcAddress, int16 nsduLength, uint8 *nsdu, uint8 LinkQuality)
    724          {
    725            uint8 *msgPtr;
    726            uint8 *msg;
    727            uint8 msgLen;
    728          
    729            msgLen = sizeof( uint16 ) + sizeof( uint8 ) + ZTEST_DEFAULT_DATA_LEN
    730                      + sizeof( uint8);
    731          
    732            msgPtr = osal_mem_alloc( msgLen );
    733            if ( msgPtr )
    734            {
    735              //Fill up the data bytes
    736              msg = msgPtr;
    737          
    738              //First fill in details
    739              *msg++ = LO_UINT16( SrcAddress );
    740              *msg++ = HI_UINT16( SrcAddress );
    741          
    742              //Since the max packet size is less than 255 bytes, a byte is enough
    743              //to represent nsdu length
    744              *msg++ = ( uint8 ) nsduLength;
    745          
    746              osal_memset( msg, NULL, ZTEST_DEFAULT_DATA_LEN ); // Clear the mem
    747              osal_memcpy( msg, nsdu, nsduLength );
    748              msg += ZTEST_DEFAULT_DATA_LEN;
    749          
    750              *msg++ = LinkQuality;
    751          
    752              MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLDE_DATA_IND, msgLen, msgPtr );
    753          
    754              osal_mem_free( msgPtr );
    755            }
    756          }
    757          
    758          /***************************************************************************************************
    759           * @fn          nwk_MTCallbackSubInitCoordConfirm
    760           *
    761           * @brief       Process the callback subscription for NLME-INIT-COORD.confirm
    762           *
    763           * @param       Status - Result of NLME_InitCoordinatorRequest()
    764           *
    765           * @return      none
    766           ***************************************************************************************************/
    767          void nwk_MTCallbackSubInitCoordConfirm( ZStatus_t Status )
    768          {
    769            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_NETWORK_FORMATION_CONF,
    770                                    sizeof(uint8), (uint8*)&Status);
    771          }
    772          
    773          /***************************************************************************************************
    774           * @fn          nwk_MTCallbackSubStartRouterConfirm
    775           *
    776           * @brief       Process the callback subscription for NLME-START-ROUTER.confirm
    777           *
    778           * @param       Status - Result of NLME_StartRouterRequest()
    779           *
    780           * @return      none
    781           ***************************************************************************************************/
    782          void nwk_MTCallbackSubStartRouterConfirm( ZStatus_t Status )
    783          {
    784            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_START_ROUTER_CONF,
    785                                    sizeof(uint8), (uint8*)&Status);
    786          }
    787          
    788          /***************************************************************************************************
    789           * @fn          nwk_MTCallbackSubJoinConfirm
    790           *
    791           * @brief       Process the callback subscription for NLME-JOIN.confirm
    792           *
    793           * @param       Status - Result of NLME_JoinRequest()
    794           *
    795           * @return      none
    796           ***************************************************************************************************/
    797          void nwk_MTCallbackSubJoinConfirm(uint16 PanId, ZStatus_t Status)
    798          {
    799            uint8 msg[Z_EXTADDR_LEN + 3];
    800          
    801            /* This device's 64-bit address */
    802            ZMacGetReq( ZMacExtAddr, msg );
    803          
    804            msg[Z_EXTADDR_LEN + 0] = LO_UINT16(PanId);
    805            msg[Z_EXTADDR_LEN + 1] = HI_UINT16(PanId);
    806            msg[Z_EXTADDR_LEN + 2] = (uint8)Status;
    807          
    808            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_JOIN_CONF, Z_EXTADDR_LEN + 3, msg );
    809          }
    810          /***************************************************************************************************
    811           * @fn          nwk_MTCallbackSubNetworkDiscoveryConfirm
    812           *
    813           * @brief       Process the callback subscription for NLME-NWK_DISC.confirm
    814           *
    815           * @param       ResultCount			- number of networks discovered
    816           * @param				NetworkList			- pointer to list of network descriptors
    817           *
    818           * @return      void
    819           ***************************************************************************************************/
    820          void nwk_MTCallbackSubNetworkDiscoveryConfirm( uint8 ResultCount, networkDesc_t *NetworkList )
    821          {
    822          	uint8 len;
    823          	uint8 *msgPtr;
    824          	uint8 *msg;
    825          	uint8 i;
    826          
    827            // The message cannot be bigger then SPI_TX_BUFF_MAX.  Reduce resultCount if necessary
    828            if (ResultCount * sizeof(networkDesc_t) > MT_UART_TX_BUFF_MAX - (1 + SPI_0DATA_MSG_LEN))
    829            {
    830              ResultCount = (MT_UART_TX_BUFF_MAX - (1 + SPI_0DATA_MSG_LEN)) / sizeof(networkDesc_t);
    831            }
    832          
    833          	len = 1 + ResultCount * sizeof(networkDesc_t);
    834            msgPtr = osal_mem_alloc( len );
    835          	if ( msgPtr )
    836          	{
    837          	  /* Fill up the data bytes */
    838              msg = msgPtr;
    839          
    840          		*msg++ = ResultCount;
    841          
    842          		for ( i = 0; i < ResultCount; i++ )
    843          		{
    844          		  *msg++ = LO_UINT16( NetworkList->panId );
    845          		  *msg++ = HI_UINT16( NetworkList->panId );
    846          		  *msg++ = NetworkList->logicalChannel;
    847          		  *msg++ = BEACON_ORDER_NO_BEACONS;
    848          		  *msg++ = BEACON_ORDER_NO_BEACONS;
    849          		  *msg++ = NetworkList->routerCapacity;
    850          		  *msg++ = NetworkList->deviceCapacity;
    851          		  *msg++ = NetworkList->version;
    852          		  *msg++ = NetworkList->stackProfile;
    853          		  //*msg++ = NetworkList->securityLevel;
    854          		
    855          			NetworkList = (networkDesc_t*)NetworkList->nextDesc;
    856          		}
    857          
    858              MT_BuildAndSendZToolResponse (((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_NETWORK_DISCOVERY_CONF, len, msgPtr);
    859          
    860              osal_mem_free( msgPtr );
    861          	}
    862          }
    863          /***************************************************************************************************
    864           * @fn          nwk_MTCallbackSubJoinIndication
    865           *
    866           * @brief       Process the callback subscription for NLME-INIT-COORD.indication
    867           *
    868           * @param       ShortAddress - 16-bit address
    869           * @param       ExtendedAddress - IEEE (64-bit) address
    870           * @param       CapabilityFlags - Association Capability Information
    871           *
    872           * @return      ZStatus_t
    873           ***************************************************************************************************/
    874          void nwk_MTCallbackSubJoinIndication( uint16 ShortAddress, uint8 *ExtendedAddress,
    875                                                uint8 CapabilityFlags )
    876          {
    877            uint8 *msgPtr;
    878            uint8 *msg;
    879            uint8 len;
    880          
    881            len = sizeof( uint16 ) + Z_EXTADDR_LEN + sizeof( uint8 );
    882            msgPtr = osal_mem_alloc( len );
    883          
    884            if ( msgPtr )
    885            {
    886              /* Fill up the data bytes */
    887              msg = msgPtr;
    888          
    889              /* First fill in details */
    890              *msg++ = LO_UINT16( ShortAddress );
    891              *msg++ = HI_UINT16( ShortAddress );
    892          
    893              osal_cpyExtAddr( msg, ExtendedAddress );
    894              msg += Z_EXTADDR_LEN;
    895          
    896              *msg = CapabilityFlags;
    897          
    898              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_JOIN_IND, len, msgPtr );
    899          
    900              osal_mem_free( msgPtr );
    901            }
    902          }
    903          
    904          /***************************************************************************************************
    905           * @fn          nwk_MTCallbackSubLeaveConfirm
    906           *
    907           * @brief       Process the callback subscription for NLME-LEAVE.confirm
    908           *
    909           * @param       DeviceAddress - IEEE (64-bit) address
    910           * @param       Status - Result of NLME_LeaveRequest()
    911           *
    912           * @return      none
    913           ***************************************************************************************************/
    914          void nwk_MTCallbackSubLeaveConfirm( uint8 *DeviceAddress, ZStatus_t Status )
    915          {
    916            uint8 *msgPtr;
    917            uint8 *msg;
    918          
    919            msgPtr = osal_mem_alloc( Z_EXTADDR_LEN + sizeof( uint8 ) );
    920            if ( msgPtr )
    921            {
    922              /* Fill up the data bytes */
    923              msg = msgPtr;
    924          
    925              /* First fill in details */
    926              osal_cpyExtAddr( msg, DeviceAddress );
    927              msg += Z_EXTADDR_LEN;
    928          
    929              *msg = (uint8)Status;
    930          
    931              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_LEAVE_CONF,
    932                                      Z_EXTADDR_LEN + sizeof( uint8 ), msgPtr );
    933          
    934              osal_mem_free( msgPtr );
    935            }
    936          }
    937          /***************************************************************************************************
    938           * @fn          nwk_MTCallbackSubLeaveIndication
    939           *
    940           * @brief       Process the callback subscription for NLME-LEAVE.indication
    941           *
    942           * @param       DeviceAddress - IEEE (64-bit) address
    943           *
    944           * @return      NULL
    945           ***************************************************************************************************/
    946          void nwk_MTCallbackSubLeaveIndication( uint8 *DeviceAddress )
    947          {
    948            uint8 msg[Z_EXTADDR_LEN+1];
    949          
    950            /* First fill in details */
    951            if ( DeviceAddress )
    952            {
    953              osal_cpyExtAddr( msg, DeviceAddress );
    954            }
    955            else
    956            {
    957              osal_memset( msg, 0, Z_EXTADDR_LEN );
    958            }
    959          
    960            /* Status, assume good if we get this far */
    961            msg[Z_EXTADDR_LEN] = 0;
    962          
    963            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_LEAVE_IND, Z_EXTADDR_LEN+1, msg );
    964          }
    965          /***************************************************************************************************
    966           * @fn          nwk_MTCallbackSubSyncIndication
    967           *
    968           * @brief       Process the callback subscription for NLME-SYNC.indication
    969           *
    970           * @param       none
    971           *
    972           * @return      none
    973           ***************************************************************************************************/
    974          void nwk_MTCallbackSubSyncIndication( void )
    975          {
    976            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_SYNC_IND, 0, NULL );
    977          }
    978          
    979          /***************************************************************************************************
    980           * @fn          nwk_MTCallbackSubPollConfirm
    981           *
    982           * @brief       Process the callback subscription for NLME-POLL.confirm
    983           *
    984           * @param       status - status of the poll operation
    985           *
    986           * @return      none
    987           ***************************************************************************************************/
    988          void nwk_MTCallbackSubPollConfirm( uint8 status )
    989          {
    990            uint8 msg = status;
    991          
    992            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_NWK), MT_NLME_POLL_CONF, 1, &msg );
    993          }
    994          
    995          #endif /* NWK Callback commands */
    996          
    997          /***************************************************************************************************
    998           ***************************************************************************************************/
    999          


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  _nwkCallbackSub

 
 2 bytes in segment XDATA_Z
 
 2 bytes of XDATA memory

Errors: none
Warnings: none
