###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Apr/2019  16:49:35
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_FrameWork.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWF20B.tmp
#        (E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_FrameWork.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK_DEMO -lC
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        -lA
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0056
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\List\SAPP_FrameWork.lst
#    Object file        =  
#        E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Demo\Obj\SAPP_FrameWork.r51
#
###############################################################################

E:\qq下载文件\结课作业\ZigBee\实验指导书\实验指导书\Code\Cap2_ZStack\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\SAPP_FrameWork.c
      1          #if defined(SAPP_ZSTACK)
      2          #include "SAPP_FrameWork.h"
      3          #include <string.h>
      4          
      5          /*********************************************************************
      6           * FUNCTIONS
      7           *********************************************************************/
      8          static void createEndPoint(struct ep_info_t *epInfo, uint8 *task_id, uint8 ep);
      9          #if defined(ZDO_COORDINATOR)
     10          static uint8 uartMsgProcesser(uint8 *msg);
     11          #endif
     12          
     13          /*********************************************************************
     14           * Local Variables
     15           *********************************************************************/
     16          //uint8 ctrlBuffer[sizeof(TOPOINFO) + sizeof(FUNCTABLE) + FUNC_NUM * sizeof(FUNCINFO)];
     17          static TOPOINFO topoBuffer = { 0x02 };
     18          FUNCTABLE *funcTableBuffer;// = (FUNCTABLE *)(&ctrlBuffer[sizeof(TOPOINFO)]);
     19          
     20          static devStates_t curNwkState;
     21          static uint8 controlTaskId;
     22          static uint8 functionTaskId;
     23          static struct ep_info_t controlEndPointInfo;
     24          static uint8 isUserTimerRunning = 0;
     25          
     26          void sapp_taskInitProcess(void)
     27          {
     28           #if defined ( BUILD_ALL_DEVICES )
     29              // The "Demo" target is setup to have BUILD_ALL_DEVICES and HOLD_AUTO_START
     30              // We are looking at a jumper (defined in SampleAppHw.c) to be jumpered
     31              // together - if they are - we will start up a coordinator. Otherwise,
     32              // the device will start as a router.
     33              if ( readCoordinatorJumper() )
     34                  zgDeviceLogicalType = ZG_DEVICETYPE_COORDINATOR;
     35              else
     36                  zgDeviceLogicalType = ZG_DEVICETYPE_ROUTER;
     37          #endif // BUILD_ALL_DEVICES
     38          
     39          #if defined ( HOLD_AUTO_START )
     40              // HOLD_AUTO_START is a compile option that will surpress ZDApp
     41              //  from starting the device and wait for the application to
     42              //  start the device.
     43              ZDOInitDevice(0);
     44          #endif
     45          
     46              // 构造功能列表
     47              funcTableBuffer = createFuncTable(funcCount);
     48              funcTableBuffer->ft_type = 0x01;
     49              funcTableBuffer->ft_count = funcCount;
     50              int i;
     51              for(i = 0; i < funcCount; i++)
     52              {
     53                  funcTableBuffer->ft_list[i].type = funcList[i].function.type;
     54                  funcTableBuffer->ft_list[i].id = funcList[i].function.id;
     55                  funcTableBuffer->ft_list[i].cycle = funcList[i].function.cycle;
     56              }
     57              controlTaskId = tasksCnt - 2;
     58              functionTaskId = tasksCnt - 1;
     59              HalIOInit(functionTaskId);
     60              createEndPoint(&controlEndPointInfo, &controlTaskId, CONTROL_ENDPOINT);
     61              for(i = 0; i < funcCount; i++)
     62              {
     63                  struct ep_info_t *ep = &funcList[i];
     64                  createEndPoint(ep, &functionTaskId, i + 1);
     65                  if(ep->res_available)
     66                    (*ep->res_available)(ep, ResInit, NULL);
     67              }
     68          #if defined(ZDO_COORDINATOR)// || defined(RTR_NWK)
     69          //    RegisterForKeys( SampleApp_TaskID );
     70              MT_UartRegisterTaskID(controlTaskId);
     71          #endif
     72          }
     73          /*********************************************************************
     74           * LOCAL FUNCTIONS
     75           */
     76          
     77          static void createEndPoint(struct ep_info_t *epInfo, uint8 *task_id, uint8 ep)
     78          {
     79              static cId_t commonClusterId = SAPP_PERIODIC_CLUSTERID;
     80              // Fill out the endpoint description.
     81              epInfo->task_id = *task_id;
     82              epInfo->ep = ep;
     83              epInfo->timerTick = epInfo->function.cycle;
     84              epInfo->userTimer = 0;
     85          
     86              epInfo->simpleDesc.EndPoint = ep;
     87              epInfo->simpleDesc.AppProfId = SAPP_PROFID;
     88              epInfo->simpleDesc.AppDeviceId = SAPP_DEVICEID;
     89              epInfo->simpleDesc.AppDevVer = SAPP_DEVICE_VERSION;
     90              epInfo->simpleDesc.Reserved = 0;
     91              epInfo->simpleDesc.AppNumInClusters = 1;
     92              epInfo->simpleDesc.pAppInClusterList = &commonClusterId;
     93              epInfo->simpleDesc.AppNumOutClusters = 1;
     94              epInfo->simpleDesc.pAppOutClusterList = &commonClusterId;
     95          
     96              epInfo->SampleApp_epDesc.endPoint = ep;
     97              epInfo->SampleApp_epDesc.task_id = task_id;
     98              epInfo->SampleApp_epDesc.simpleDesc = &epInfo->simpleDesc;
     99              epInfo->SampleApp_epDesc.latencyReq = noLatencyReqs;
    100          
    101              // Register the endpoint description with the AF
    102              afRegister(&epInfo->SampleApp_epDesc);
    103          }
    104          
    105          uint16 sapp_controlEpProcess(uint8 task_id, uint16 events)
    106          {
    107              afIncomingMSGPacket_t *MSGpkt;
    108          
    109              if ( events & SYS_EVENT_MSG )
    110              {
    111                  MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive(task_id);
    112                  while ( MSGpkt )
    113                  {
    114                      switch ( MSGpkt->hdr.event )
    115                      {
    116          #if defined(ZDO_COORDINATOR)
    117                      case CMD_SERIAL_MSG:
    118          //                SampleApp_UartMessage((uint8 *)MSGpkt);
    119                          uartMsgProcesser((uint8 *)MSGpkt);
    120                          HalLedBlink( HAL_LED_1, 2, 50, 90 );
    121                          break;
    122          #endif
    123                          // Received when a messages is received (OTA) for this endpoint
    124                      case AF_INCOMING_MSG_CMD:
    125                      {
    126                          // TODO: QueryProfile or QueryTopo
    127                          switch(MSGpkt->clusterId)
    128                          {
    129                          case SAPP_PERIODIC_CLUSTERID:
    130                              switch(MSGpkt->cmd.Data[0])
    131                              {
    132                              case 0x01:
    133                                  // CtrlQueryProfile
    134                                  // 获取到数据包的来源地址来当做发送数据的目标
    135                                  SendData(CONTROL_ENDPOINT, funcTableBuffer->ft_data, MSGpkt->srcAddr.addr.shortAddr, MSGpkt->srcAddr.endPoint, sizeof(FUNCTABLE) + funcCount * sizeof(FUNCINFO));
    136                                  break;
    137                              case 0x02:
    138                                  // CtrlQueryTopo
    139                                  // 获取到数据包的来源地址来当做发送数据的目标
    140                                  SendData(CONTROL_ENDPOINT, (unsigned char *)&topoBuffer, MSGpkt->srcAddr.addr.shortAddr, MSGpkt->srcAddr.endPoint, sizeof(TOPOINFO));
    141                                  break;
    142                              case 0x03:
    143                                  // CtrlQuerySpecialFunction
    144                                  // cmd.Data[0] = 3, cmd.Data[1] = funcCode, cmd.Data[2] = funcID
    145                                  {
    146                                      uint8 i;
    147                                      for(i = 0; i < funcTableBuffer->ft_count; i++)
    148                                      {
    149                                          if((funcTableBuffer->ft_list[i].type == MSGpkt->cmd.Data[1])
    150                                             && (funcTableBuffer->ft_list[i].id == MSGpkt->cmd.Data[2]))
    151                                          {
    152                                              // 0x03, EndPoint, rCycle
    153                                              uint8 specialFunc[3] = { 0x03, i + 1, funcTableBuffer->ft_list[i].cycle };
    154                                              SendData(CONTROL_ENDPOINT, specialFunc, MSGpkt->srcAddr.addr.shortAddr, MSGpkt->srcAddr.endPoint, sizeof(specialFunc));
    155                                              break;
    156                                          }
    157                                      }
    158                                  }
    159                                  break;
    160                              default:
    161                                  {
    162                                      int i;
    163                                      for(i = 0; i < funcCount; i++)
    164                                      {
    165                                          struct ep_info_t *ep = &funcList[i];
    166                                          if(ep->res_available)   (*ep->res_available)(ep, ResControlPkg, MSGpkt);
    167                                      }
    168                                  }
    169                                  break;
    170                              }
    171                              HalLedBlink( HAL_LED_2, 1, 50, 250 );
    172                              break;
    173                          }
    174                          break;
    175                      }
    176                      // Received whenever the device changes state in the network
    177                      case ZDO_STATE_CHANGE:
    178                      {
    179                          devStates_t st = (devStates_t)(MSGpkt->hdr.status);
    180                          if ( (st == DEV_ZB_COORD)
    181                                  || (st == DEV_ROUTER)
    182                                  || (st == DEV_END_DEVICE) )
    183                          {
    184          //                    topoBuffer->type = 0x02;
    185                              memcpy(topoBuffer.IEEE, NLME_GetExtAddr(), 8);
    186          #if !defined(ZDO_COORDINATOR)
    187                              topoBuffer.PAddr = NLME_GetCoordShortAddr();
    188          #else
    189                              topoBuffer.PAddr = 0xFFFF;
    190          #endif
    191                              osal_memcpy(&topoBuffer.panid, &_NIB.nwkPanId, sizeof(uint16));
    192                              osal_memcpy(&topoBuffer.channel, &_NIB.nwkLogicalChannel, sizeof(uint8));
    193                              //向协调器发送拓扑信息
    194                              SendData(CONTROL_ENDPOINT, (unsigned char *)&topoBuffer, 0x0000, TRANSFER_ENDPOINT, sizeof(TOPOINFO));
    195                              HalLedBlink( HAL_LED_2, 4, 50, 250 );
    196                          }
    197                      }
    198                      break;
    199                      default:
    200                          break;
    201                      }
    202                      // Release the memory
    203                      osal_msg_deallocate( (uint8 *)MSGpkt );
    204                      // Next - if one is available
    205                      MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
    206                  }
    207                  // return unprocessed events
    208                  return (events ^ SYS_EVENT_MSG);
    209              }
    210              // 定时器时间到, 遍历所有端点看是否有userTimer
    211              if(events & SAPP_SEND_PERIODIC_MSG_EVT)
    212              {
    213                  int i;
    214                  uint8 hasUserTimer = 0;
    215                  for(i = 0; i < funcCount; i++)
    216                  {
    217                      struct ep_info_t *ep = &funcList[i];
    218                      if(ep->userTimer && ep->res_available)
    219                      {
    220                          hasUserTimer = 1;
    221                          ep->userTimer = ep->userTimer - 1;
    222                          if(ep->userTimer <= 1)
    223                          {
    224                              ep->userTimer = 0;
    225                              (*ep->res_available)(ep, ResUserTimer, NULL);
    226                          }
    227                      }
    228                  }
    229                  if(hasUserTimer)
    230                  {
    231                      // 重新启动定时器
    232                      osal_start_timerEx(task_id, SAPP_SEND_PERIODIC_MSG_EVT, 1000);
    233                  }
    234                  else
    235                  {
    236                      isUserTimerRunning = 0;
    237                      osal_stop_timerEx(task_id, SAPP_SEND_PERIODIC_MSG_EVT);
    238                  }
    239                  // return unprocessed events
    240                  return (events ^ SAPP_SEND_PERIODIC_MSG_EVT);
    241              }
    242              // Discard unknown events
    243              return 0;
    244          }
    245          
    246          uint16 sapp_functionEpProcess(uint8 task_id, uint16 events)
    247          {
    248              afIncomingMSGPacket_t *MSGpkt;
    249              if(events & SYS_EVENT_MSG)
    250              {
    251                  MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
    252                  while ( MSGpkt )
    253                  {
    254                      switch ( MSGpkt->hdr.event )
    255                      {
    256                      // 接收到数据包
    257                      case AF_INCOMING_MSG_CMD:
    258                          {
    259                              switch ( MSGpkt->clusterId )
    260                              {
    261                              case SAPP_PERIODIC_CLUSTERID:
    262                                  if(MSGpkt->endPoint <= funcCount)
    263                                  {
    264                                      struct ep_info_t *ep = &funcList[MSGpkt->endPoint - 1];
    265                                      if(ep->incoming_data)
    266                                          (*ep->incoming_data)(ep, MSGpkt->srcAddr.addr.shortAddr, MSGpkt->srcAddr.endPoint, &MSGpkt->cmd);
    267                                  }
    268                                  HalLedBlink( HAL_LED_2, 1, 50, 250 );
    269                                  break;
    270                              }
    271                          }
    272                          break;
    273          
    274                      case ZDO_STATE_CHANGE:
    275                          {
    276                              curNwkState = (devStates_t)(MSGpkt->hdr.status);
    277                              if ( (curNwkState == DEV_ZB_COORD)
    278                                      || (curNwkState == DEV_ROUTER)
    279                                      || (curNwkState == DEV_END_DEVICE) )
    280                              {
    281                                  int i;
    282                                  int hasTimeOut = 0;
    283                                  for(i = 0; i < funcCount; i++)
    284                                  {
    285                                      struct ep_info_t *ep = &funcList[i];
    286                                      if(ep->nwk_stat_change)
    287                                          (*ep->nwk_stat_change)(ep);
    288                                      // 重置端点计数器
    289                                      if(ep->time_out && ep->function.cycle)
    290                                      {
    291                                          ep->timerTick = ep->function.cycle;
    292                                          hasTimeOut = 1;
    293                                      }
    294                                  }
    295                                  if(hasTimeOut)
    296                                  {
    297                                      // 加入网络成功,启动定时器,为各个端点提供定时
    298                                      osal_start_timerEx(task_id,
    299                                                         SAPP_SEND_PERIODIC_MSG_EVT,
    300                                                         1000);
    301                                  }
    302                              }
    303                              else
    304                                  osal_stop_timerEx(task_id, SAPP_SEND_PERIODIC_MSG_EVT);
    305                          }
    306                          break;
    307                      case IOPORT_INT_EVENT:
    308                        {
    309                          OSALIOIntData_t* IOIntData;
    310                          IOIntData =(OSALIOIntData_t*)MSGpkt;
    311                          if(IOIntData->endPoint <= funcCount)
    312                          {
    313                              struct ep_info_t *ep = &funcList[IOIntData->endPoint - 1];
    314                              if(ep->res_available)
    315                                  (*ep->res_available)(ep, ResIOInt, IOIntData->arg);
    316                          }
    317                        }
    318                        break;
    319          #if defined(HAL_IRDEC) && (HAL_IRDEC == TRUE)
    320                      case IRDEC_INT_EVENT:   //
    321                        {
    322                          OSALIRDecIntData_t* TimerIntData = (OSALIRDecIntData_t*)MSGpkt;
    323                          if(TimerIntData->endPoint <= funcCount)
    324                          {
    325                              struct ep_info_t *ep = &funcList[TimerIntData->endPoint - 1];
    326                              if(ep->res_available)
    327                                  (*ep->res_available)(ep, ResTimerInt, TimerIntData->data);
    328                          }
    329                        }
    330                        break;
    331          #endif
    332                      default:
    333                          break;
    334                      }
    335                      // Release the memory
    336                      osal_msg_deallocate( (uint8 *)MSGpkt );
    337                      // Next - if one is available
    338                      MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
    339                  }
    340                  // return unprocessed events
    341                  return (events ^ SYS_EVENT_MSG);
    342              }
    343          
    344              // 定时器时间到, 遍历所有端点看是否有需要调用time_out
    345              if(events & SAPP_SEND_PERIODIC_MSG_EVT)
    346              {
    347                  int i;
    348                  for(i = 0; i < funcCount; i++)
    349                  {
    350                      struct ep_info_t *ep = &funcList[i];
    351                      if(ep->time_out && ep->function.cycle)
    352                      {
    353                          // 端点需要周期执行
    354                          ep->timerTick = ep->timerTick - 1;
    355                          if(ep->timerTick == 0)
    356                          {
    357                            // 定时时间到,执行time_out函数
    358                            (*ep->time_out)(ep);
    359                            ep->timerTick = ep->function.cycle;
    360                          }
    361                      }
    362          #if 0
    363                      if(ep->userTimer && ep->res_available)
    364                      {
    365                          ep->userTimer = ep->userTimer - 1;
    366                          if(ep->userTimer <= 1)
    367                          {
    368                              (*ep->res_available)(ep, ResUserTimer, NULL);
    369                              ep->userTimer = 0;
    370                          }
    371                      }
    372          #endif
    373                  }
    374                  // 重新启动定时器
    375                  osal_start_timerEx(task_id, SAPP_SEND_PERIODIC_MSG_EVT, 1000);
    376                  // return unprocessed events
    377                  return (events ^ SAPP_SEND_PERIODIC_MSG_EVT);
    378              }
    379              // Discard unknown events
    380              return 0;
    381          }
    382          
    383          #if defined(ZDO_COORDINATOR)
    384          static uint8 uartMsgProcesser(uint8 *msg)
    385          {
    386              mtOSALSerialData_t *pMsg = (mtOSALSerialData_t *)msg;
    387              mtUserSerialMsg_t *pMsgBody = (mtUserSerialMsg_t *)pMsg->msg;
    388              if ( (curNwkState != DEV_ZB_COORD)
    389                      && (curNwkState != DEV_ROUTER)
    390                      && (curNwkState != DEV_END_DEVICE) )
    391                  return 1;
    392              switch(pMsgBody->cmd)
    393              {
    394              case 0x0018:
    395                  {
    396                      switch(pMsgBody->cmdEndPoint)
    397                      {
    398                      case 0xF1:
    399                          {
    400                              // 转发数据
    401                              SendData(TRANSFER_ENDPOINT, pMsgBody->data,
    402                                       pMsgBody->addr, pMsgBody->endPoint,
    403                                       pMsgBody->len - 6);
    404                          }
    405                          break;
    406                      }
    407                  }
    408                  break;
    409              }
    410              return 1;
    411          }
    412          #endif
    413          
    414          uint8 SendData(uint8 srcEP, const void *buf, uint16 addr, uint8 dstEP, uint8 Len)
    415          {
    416              static uint8 transID = 0;
    417              afAddrType_t SendDataAddr;
    418              struct ep_info_t *epInfo;
    419          
    420              if(srcEP <= funcCount)
    421                  epInfo = &funcList[srcEP - 1];
    422              else
    423                  epInfo = &controlEndPointInfo;
    424          
    425              SendDataAddr.addrMode = (afAddrMode_t)Addr16Bit;         //短地址发送
    426              SendDataAddr.endPoint = dstEP;
    427              SendDataAddr.addr.shortAddr = addr;
    428              if ( AF_DataRequest( &SendDataAddr, //发送的地址和模式
    429                                   // TODO:
    430                                   &epInfo->SampleApp_epDesc,   //终端（比如操作系统中任务ID等）
    431                                   SAPP_PERIODIC_CLUSTERID,//发送串ID
    432                                   Len,
    433                                   (uint8*)buf,
    434                                   &transID,  //信息ID（操作系统参数）
    435                                   AF_DISCV_ROUTE,
    436                                   AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    437              {
    438                  HalLedBlink( HAL_LED_1, 1, 50, 250 );
    439                  return 1;
    440              }
    441              else
    442              {
    443                  return 0;
    444              }
    445          }
    446          
    447          void CreateUserTimer(struct ep_info_t *ep, uint8 seconds)
    448          {
    449              if(ep == NULL)
    450                  return;
    451              if(ep->res_available == NULL)
    452                  return;
    453              ep->userTimer = seconds;
    454              if(isUserTimerRunning == 0)
    455              {
    456                  osal_start_timerEx(controlTaskId,
    457                                     SAPP_SEND_PERIODIC_MSG_EVT,
    458                                     1000);
    459                  isUserTimerRunning = 1;
    460              }
    461          }
    462          
    463          void DeleteUserTimer(struct ep_info_t *ep)
    464          {
    465              if(ep == NULL)
    466                  return;
    467              ep->userTimer = 0;
    468          }
    469          
    470          void ModifyRefreshCycle(struct ep_info_t *ep, uint8 seconds)
    471          {
    472              if(ep == NULL)
    473                  return;
    474              if(ep->time_out == NULL)
    475                  return;
    476              ep->function.cycle = seconds;
    477              if(ep->timerTick > seconds)
    478                  ep->timerTick = seconds;
    479          }
    480          
    481          #if ! defined(ZDO_COORDINATOR) && defined(RTR_NWK)
    482          void RouterTimeoutRoutine(struct ep_info_t *ep)
    483          {
    484              SendData(ep->ep, (unsigned char *)&topoBuffer, 0x0000, TRANSFER_ENDPOINT, sizeof(TOPOINFO)); //节点向协调器发送采集数据
    485          }
    486          #endif
    487          
    488          #if defined(ZDO_COORDINATOR)
    489          void CoordinatorIncomingRoutine(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    490          {
    491              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    492              // 转发数据到串口
    493              if(msg->DataLength > 0)
    494              {
    495                  mtUserSerialMsg_t *pMsg = osal_mem_alloc(sizeof(mtUserSerialMsg_t) + msg->DataLength - 1);
    496                  pMsg->sop = MT_UART_SOF;
    497                  pMsg->len = msg->DataLength + 6;
    498                  pMsg->cmd = 0x0018;
    499                  pMsg->cmdEndPoint = 0xF1;
    500                  pMsg->addr = addr;
    501                  pMsg->endPoint = endPoint;
    502                  memcpy(pMsg->data, msg->Data, msg->DataLength);
    503                  pMsg->fsc = MT_UartCalcFCS(0, &pMsg->len, 1);
    504                  pMsg->fsc = MT_UartCalcFCS(pMsg->fsc, pMsg->dataBody, pMsg->len);
    505                  HalUARTWrite(HAL_UART_PORT_0, &pMsg->sop, sizeof(mtUserSerialMsg_t) - 2 + msg->DataLength);
    506                  HalUARTWrite(HAL_UART_PORT_0, &pMsg->fsc, 1);
    507                  osal_mem_free(pMsg);
    508              }
    509          }
    510          #endif
    511          #endif//SAPP_ZSTACK


 

 


Errors: none
Warnings: none
